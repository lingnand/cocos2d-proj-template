{{=<% %>=}}
{-# START_FILE Classes/AppDelegate.cpp #-}
#include "AppDelegate.h"
#include "<%name-as-module%>_stub.h"
#include "HsFFI.h"

USING_NS_CC;

AppDelegate::AppDelegate() {
    hs_init(NULL, NULL);
}

AppDelegate::~AppDelegate() 
{
    hs_exit();
}

//if you want a different context,just modify the value of glContextAttrs
//it will takes effect on all platforms
void AppDelegate::initGLContextAttrs()
{
    //set OpenGL context attributions,now can only set six attributions:
    //red,green,blue,alpha,depth,stencil
    GLContextAttrs glContextAttrs = {8, 8, 8, 8, 24, 8};

    GLView::setGLContextAttrs(glContextAttrs);
}

bool AppDelegate::applicationDidFinishLaunching() {
    // initialize director
    auto director = Director::getInstance();
    auto glview = director->getOpenGLView();
    if(!glview) {
        glview = GLViewImpl::createWithRect("Game", Rect(0, 0, 960, 640));
        director->setOpenGLView(glview);
    }

    director->getOpenGLView()->setDesignResolutionSize(960, 640, ResolutionPolicy::SHOW_ALL);

    // turn on display FPS
    director->setDisplayStats(true);

    // set FPS. the default value is 1.0/60 if you don't call this
    director->setAnimationInterval(1.0 / 60);

    FileUtils::getInstance()->addSearchPath("res");

    // run
    runGame();

    return true;
}

// This function will be called when the app is inactive. When comes a phone call,it's be invoked too
void AppDelegate::applicationDidEnterBackground() {
    Director::getInstance()->stopAnimation();

    // if you use SimpleAudioEngine, it must be pause
    // SimpleAudioEngine::getInstance()->pauseBackgroundMusic();
}

// this function will be called when the app is active again
void AppDelegate::applicationWillEnterForeground() {
    Director::getInstance()->startAnimation();

    // if you use SimpleAudioEngine, it must resume here
    // SimpleAudioEngine::getInstance()->resumeBackgroundMusic();
}
{-# START_FILE Classes/AppDelegate.h #-}
#ifndef  _APP_DELEGATE_H_
#define  _APP_DELEGATE_H_

#include "cocos2d.h"

/**
@brief    The cocos2d Application.

The reason for implement as private inheritance is to hide some interface call by Director.
*/
class  AppDelegate : private cocos2d::Application
{
public:
    AppDelegate();
    virtual ~AppDelegate();

    virtual void initGLContextAttrs();

    /**
    @brief    Implement Director and Scene init code here.
    @return true    Initialize success, app continue.
    @return false   Initialize failed, app terminate.
    */
    virtual bool applicationDidFinishLaunching();

    /**
    @brief  The function be called when the application enter background
    @param  the pointer of the application
    */
    virtual void applicationDidEnterBackground();

    /**
    @brief  The function be called when the application enter foreground
    @param  the pointer of the application
    */
    virtual void applicationWillEnterForeground();
};

#endif // _APP_DELEGATE_H_

{-# START_FILE Classes/<%name-as-module%>_stub.h #-}
#include "HsFFI.h"
#ifdef __cplusplus
extern "C" {
#endif
extern void runGame(void);
#ifdef __cplusplus
}
#endif

{-# START_FILE Dockerfile.nix-cross-android #-}
FROM lynnard/reflex-cocos2d-android-builder

# use like this: docker run --rm -v `pwd`:/target image_tag [make_target]
ENTRYPOINT ["/nix-build-ghc-android-runner", "--arg", "extraGhcPkgs", "import /cocos2d.nix", "--", "make", "-C", "/app", "TARGET=android"]

# add additional packages by
# RUN /nix-build-ghc-android-runner --arg extraGhcPkgs 'p: [ p.MonadPrompt ]'

COPY . /app
{-# START_FILE LICENSE #-}
Copyright <%author-name%><%^author-name%>Author name here<%/author-name%> (c) <%year%><%^year%>2017<%/year%>

All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above
      copyright notice, this list of conditions and the following
      disclaimer in the documentation and/or other materials provided
      with the distribution.

    * Neither the name of <%author-name%><%^author-name%>Author name here<%/author-name%> nor the names of other
      contributors may be used to endorse or promote products derived
      from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
{-# START_FILE Makefile #-}
ifndef TARGET
$(error TARGET is not set; should be one of [mac, android])
endif

.PHONY: configure build debug clean newbuild

ifeq ($(TARGET),android)

newbuild: clean configure build

# if inside the nixos container
ifneq ("$(wildcard /nix/store)","")

configure:
	cabal configure --with-ghc=arm-unknown-linux-androideabi-ghc --with-ld=arm-linux-androideabi-ld.gold --with-ghc-pkg=arm-unknown-linux-androideabi-ghc-pkg -f target-android && \
	cp -rv dist /target/
build:
	cabal -v build && \
	cp -rv dist /target/ && \
	mv -v dist/build/<%name%>/<%name%> proj.android-studio/app/jni/lib<%name-as-varid%>.so && \
	ndk-build -C proj.android-studio/app NDK_MODULE_PATH=$$(eval "echo $$(jq -r '.ndk_module_path | join(":")' proj.android-studio/build-cfg.json)") NDK_TOOLCHAIN_VERSION=4.9 NDK_DEBUG=1 && \
	{ mkdir -p /target/proj.android-studio/app/libs/armeabi 2>/dev/null || true; } && \
	cp -v proj.android-studio/app/libs/armeabi/*.so /target/proj.android-studio/app/libs/armeabi/
clean:
	cabal clean

# else we should make use of the docker container
else

# need to have ANDROID_HOME set to a correct sdk location
ifndef ANDROID_HOME
$(error ANDROID_HOME is not set; must be pointing to a valid android sdk)
endif

configure:
	docker build -t nix-cross-android -f Dockerfile.nix-cross-android . && \
	docker run --rm -v `pwd`:/target nix-cross-android configure
build:
	{ mkdir -p proj.android-studio/app/assets 2>/dev/null || true; } && \
	{ if [ -n "$$(ls Resources)" ]; then rsync -av Resources/* proj.android-studio/app/assets/; fi; } && \
	docker build -t nix-cross-android -f Dockerfile.nix-cross-android . && \
	docker run --rm -v `pwd`:/target nix-cross-android build
debug: build
	cd proj.android-studio && bash ./gradlew openDebug && \
	sleep 0.5 && \
	adb shell ps | grep -m1 'org\.cocos' | awk '{ print $$2 }' | xargs adb logcat --pid
clean:
	rm -rf dist; docker rmi nix-cross-android 2>/dev/null || true

endif

else ifeq ($(TARGET),mac)

# assume on a mac
build:
	stack build --flag <%name%>:target-mac --flag cocos2d-hs:target-mac 2>&1 | awk '/^<%name%>-[0-9.]+: copy\/register$$/{ stop=1 } !stop{ print } END{ exit !stop }' && \
	mv -v <%name%>.a proj.ios_mac/mac/libs/<%name%>.a
clean:
	stack clean

endif
{-# START_FILE Resources/.gitkeep #-}
{-# START_FILE Setup.hs #-}
import Distribution.Simple
main = defaultMain
{-# START_FILE <%name%>.ccs #-}
<Solution>
  <PropertyGroup Name="<%name%>" Version="2.3.3.0" Type="CocosStudio" />
  <SolutionFolder>
    <Group ctype="ResourceGroup">
      <RootFolder Name="." />
    </Group>
  </SolutionFolder>
</Solution>
{-# START_FILE <%name%>.cfg #-}
<SolutionConfig Version="2.3.3.0">
  <PublishDirectory Value="Resources/res/" />
  <PackageDirectory Value="package/" />
  <PublishType Value="Reference" />
  <SolutionSize Value="960 * 640" />
  <ResolutionName Value="iPhone 4/4S" />
  <DefaultSerializer Value="Serializer_FlatBuffers" />
  <CustomSerializer Value="Serializer_FlatBuffers" />
  <IsNameStandardized Value="False" />
  <CustomProperties>
    <Item Key="CCS_CocosPropertis">
      <Value ctype="CocosProperties">
        <SolutionCodeType Value="Complete" />
        <ProgramLanguage Value="cpp" />
        <CreateFrameworkVersion Value="cocos2d-x-3.9" />
        <CurrentFrameworkVersion Value="cocos2d-x-3.9" />
      </Value>
    </Item>
  </CustomProperties>
</SolutionConfig>
{-# START_FILE config.json #-}
{
  "init_cfg": {
    "isLandscape": true,
    "width": 960,
    "height": 640
  }
}
{-# START_FILE hs-src/<%name-as-module%>.hs #-}
{-# LANGUAGE ForeignFunctionInterface #-}
module <%name-as-module%>
    ( runGame
    )
  where

import qualified <%name-as-module%>.Main as M

runGame :: IO ()
runGame = M.main

foreign export ccall runGame :: IO ()
{-# START_FILE hs-src/<%name-as-module%>/Main.hs #-}
module <%name-as-module%>.Main
  (
    main
  ) where

import Diagrams.Coordinates
import Data.Colour.Names (yellow)
import Data.Colour

import Reflex.Cocos2d

main :: IO ()
main = mainScene $ layerColor_
  [ alphaColor   := opaque yellow
  , contentSize  := 500 ^& 500
  , position     := 0 ^& 0
  ]
{-# START_FILE include/ghc-7.10.2/Cmm.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The University of Glasgow 2004-2013
 *
 * This file is included at the top of all .cmm source files (and
 * *only* .cmm files).  It defines a collection of useful macros for
 * making .cmm code a bit less error-prone to write, and a bit easier
 * on the eye for the reader.
 *
 * For the syntax of .cmm files, see the parser in ghc/compiler/cmm/CmmParse.y.
 *
 * Accessing fields of structures defined in the RTS header files is
 * done via automatically-generated macros in DerivedConstants.h.  For
 * example, where previously we used
 *
 *          CurrentTSO->what_next = x
 *
 * in C-- we now use
 *
 *          StgTSO_what_next(CurrentTSO) = x
 *
 * where the StgTSO_what_next() macro is automatically generated by
 * mkDerivedConstants.c.  If you need to access a field that doesn't
 * already have a macro, edit that file (it's pretty self-explanatory).
 *
 * -------------------------------------------------------------------------- */

#ifndef CMM_H
#define CMM_H

/*
 * In files that are included into both C and C-- (and perhaps
 * Haskell) sources, we sometimes need to conditionally compile bits
 * depending on the language.  CMINUSMINUS==1 in .cmm sources:
 */
#define CMINUSMINUS 1

#include "ghcconfig.h"

/* -----------------------------------------------------------------------------
   Types

   The following synonyms for C-- types are declared here:

     I8, I16, I32, I64    MachRep-style names for convenience

     W_                   is shorthand for the word type (== StgWord)
     F_                   shorthand for float  (F_ == StgFloat == C's float)
     D_                   shorthand for double (D_ == StgDouble == C's double)

     CInt                 has the same size as an int in C on this platform
     CLong                has the same size as a long in C on this platform

  --------------------------------------------------------------------------- */

#define I8  bits8
#define I16 bits16
#define I32 bits32
#define I64 bits64
#define P_  gcptr

#if SIZEOF_VOID_P == 4
#define W_ bits32
/* Maybe it's better to include MachDeps.h */
#define TAG_BITS                2
#elif SIZEOF_VOID_P == 8
#define W_ bits64
/* Maybe it's better to include MachDeps.h */
#define TAG_BITS                3
#else
#error Unknown word size
#endif

/*
 * The RTS must sometimes UNTAG a pointer before dereferencing it.
 * See the wiki page Commentary/Rts/HaskellExecution/PointerTagging
 */
#define TAG_MASK ((1 << TAG_BITS) - 1)
#define UNTAG(p) (p & ~TAG_MASK)
#define GETTAG(p) (p & TAG_MASK)

#if SIZEOF_INT == 4
#define CInt bits32
#elif SIZEOF_INT == 8
#define CInt bits64
#else
#error Unknown int size
#endif

#if SIZEOF_LONG == 4
#define CLong bits32
#elif SIZEOF_LONG == 8
#define CLong bits64
#else
#error Unknown long size
#endif

#define F_   float32
#define D_   float64
#define L_   bits64
#define V16_ bits128
#define V32_ bits256
#define V64_ bits512

#define SIZEOF_StgDouble 8
#define SIZEOF_StgWord64 8

/* -----------------------------------------------------------------------------
   Misc useful stuff
   -------------------------------------------------------------------------- */

#define ccall foreign "C"

#define NULL (0::W_)

#define STRING(name,str)                        \
  section "rodata" {                            \
        name : bits8[] str;                     \
  }                                             \

#ifdef TABLES_NEXT_TO_CODE
#define RET_LBL(f) f##_info
#else
#define RET_LBL(f) f##_ret
#endif

#ifdef TABLES_NEXT_TO_CODE
#define ENTRY_LBL(f) f##_info
#else
#define ENTRY_LBL(f) f##_entry
#endif

/* -----------------------------------------------------------------------------
   Byte/word macros

   Everything in C-- is in byte offsets (well, most things).  We use
   some macros to allow us to express offsets in words and to try to
   avoid byte/word confusion.
   -------------------------------------------------------------------------- */

#define SIZEOF_W  SIZEOF_VOID_P
#define W_MASK    (SIZEOF_W-1)

#if SIZEOF_W == 4
#define W_SHIFT 2
#elif SIZEOF_W == 8
#define W_SHIFT 3
#endif

/* Converting quantities of words to bytes */
#define WDS(n) ((n)*SIZEOF_W)

/*
 * Converting quantities of bytes to words
 * NB. these work on *unsigned* values only
 */
#define BYTES_TO_WDS(n) ((n) / SIZEOF_W)
#define ROUNDUP_BYTES_TO_WDS(n) (((n) + SIZEOF_W - 1) / SIZEOF_W)

/* TO_W_(n) converts n to W_ type from a smaller type */
#if SIZEOF_W == 4
#define TO_W_(x) %sx32(x)
#define HALF_W_(x) %lobits16(x)
#elif SIZEOF_W == 8
#define TO_W_(x) %sx64(x)
#define HALF_W_(x) %lobits32(x)
#endif

#if SIZEOF_INT == 4 && SIZEOF_W == 8
#define W_TO_INT(x) %lobits32(x)
#elif SIZEOF_INT == SIZEOF_W
#define W_TO_INT(x) (x)
#endif

#if SIZEOF_LONG == 4 && SIZEOF_W == 8
#define W_TO_LONG(x) %lobits32(x)
#elif SIZEOF_LONG == SIZEOF_W
#define W_TO_LONG(x) (x)
#endif

/* -----------------------------------------------------------------------------
   Heap/stack access, and adjusting the heap/stack pointers.
   -------------------------------------------------------------------------- */

#define Sp(n)  W_[Sp + WDS(n)]
#define Hp(n)  W_[Hp + WDS(n)]

#define Sp_adj(n) Sp = Sp + WDS(n)  /* pronounced "spadge" */
#define Hp_adj(n) Hp = Hp + WDS(n)

/* -----------------------------------------------------------------------------
   Assertions and Debuggery
   -------------------------------------------------------------------------- */

#ifdef DEBUG
#define ASSERT(predicate)                       \
        if (predicate) {                        \
            /*null*/;                           \
        } else {                                \
            foreign "C" _assertFail(NULL, __LINE__) never returns; \
        }
#else
#define ASSERT(p) /* nothing */
#endif

#ifdef DEBUG
#define DEBUG_ONLY(s) s
#else
#define DEBUG_ONLY(s) /* nothing */
#endif

/*
 * The IF_DEBUG macro is useful for debug messages that depend on one
 * of the RTS debug options.  For example:
 *
 *   IF_DEBUG(RtsFlags_DebugFlags_apply,
 *      foreign "C" fprintf(stderr, stg_ap_0_ret_str));
 *
 * Note the syntax is slightly different to the C version of this macro.
 */
#ifdef DEBUG
#define IF_DEBUG(c,s)  if (RtsFlags_DebugFlags_##c(RtsFlags) != 0::I32) { s; }
#else
#define IF_DEBUG(c,s)  /* nothing */
#endif

/* -----------------------------------------------------------------------------
   Entering

   It isn't safe to "enter" every closure.  Functions in particular
   have no entry code as such; their entry point contains the code to
   apply the function.

   ToDo: range should end in N_CLOSURE_TYPES-1, not N_CLOSURE_TYPES,
   but switch doesn't allow us to use exprs there yet.

   If R1 points to a tagged object it points either to
   * A constructor.
   * A function with arity <= TAG_MASK.
   In both cases the right thing to do is to return.
   Note: it is rather lucky that we can use the tag bits to do this
         for both objects. Maybe it points to a brittle design?

   Indirections can contain tagged pointers, so their tag is checked.
   -------------------------------------------------------------------------- */

#ifdef PROFILING

// When profiling, we cannot shortcut ENTER() by checking the tag,
// because LDV profiling relies on entering closures to mark them as
// "used".

#define LOAD_INFO(ret,x)                        \
    info = %INFO_PTR(UNTAG(x));

#define UNTAG_IF_PROF(x) UNTAG(x)

#else

#define LOAD_INFO(ret,x)                        \
  if (GETTAG(x) != 0) {                         \
      ret(x);                                   \
  }                                             \
  info = %INFO_PTR(x);

#define UNTAG_IF_PROF(x) (x) /* already untagged */

#endif

// We need two versions of ENTER():
//  - ENTER(x) takes the closure as an argument and uses return(),
//    for use in civilized code where the stack is handled by GHC
//
//  - ENTER_NOSTACK() where the closure is in R1, and returns are
//    explicit jumps, for use when we are doing the stack management
//    ourselves.

#define ENTER(x) ENTER_(return,x)
#define ENTER_R1() ENTER_(RET_R1,R1)

#define RET_R1(x) jump %ENTRY_CODE(Sp(0)) [R1]

#define ENTER_(ret,x)                                   \
 again:                                                 \
  W_ info;                                              \
  LOAD_INFO(ret,x)                                       \
  switch [INVALID_OBJECT .. N_CLOSURE_TYPES]            \
         (TO_W_( %INFO_TYPE(%STD_INFO(info)) )) {       \
  case                                                  \
    IND,                                                \
    IND_PERM,                                           \
    IND_STATIC:                                         \
   {                                                    \
      x = StgInd_indirectee(x);                         \
      goto again;                                       \
   }                                                    \
  case                                                  \
    FUN,                                                \
    FUN_1_0,                                            \
    FUN_0_1,                                            \
    FUN_2_0,                                            \
    FUN_1_1,                                            \
    FUN_0_2,                                            \
    FUN_STATIC,                                         \
    BCO,                                                \
    PAP:                                                \
   {                                                    \
       ret(x);                                          \
   }                                                    \
  default:                                              \
   {                                                    \
       x = UNTAG_IF_PROF(x);                            \
       jump %ENTRY_CODE(info) (x);                      \
   }                                                    \
  }

// The FUN cases almost never happen: a pointer to a non-static FUN
// should always be tagged.  This unfortunately isn't true for the
// interpreter right now, which leaves untagged FUNs on the stack.

/* -----------------------------------------------------------------------------
   Constants.
   -------------------------------------------------------------------------- */

#include "rts/Constants.h"
#include "DerivedConstants.h"
#include "rts/storage/ClosureTypes.h"
#include "rts/storage/FunTypes.h"
#include "rts/storage/SMPClosureOps.h"
#include "rts/OSThreads.h"

/*
 * Need MachRegs, because some of the RTS code is conditionally
 * compiled based on REG_R1, REG_R2, etc.
 */
#include "stg/RtsMachRegs.h"

#include "rts/prof/LDV.h"

#undef BLOCK_SIZE
#undef MBLOCK_SIZE
#include "rts/storage/Block.h"  /* For Bdescr() */


#define MyCapability()  (BaseReg - OFFSET_Capability_r)

/* -------------------------------------------------------------------------
   Info tables
   ------------------------------------------------------------------------- */

#if defined(PROFILING)
#define PROF_HDR_FIELDS(w_,hdr1,hdr2)          \
  w_ hdr1,                                     \
  w_ hdr2,
#else
#define PROF_HDR_FIELDS(w_,hdr1,hdr2) /* nothing */
#endif

/* -------------------------------------------------------------------------
   Allocation and garbage collection
   ------------------------------------------------------------------------- */

/*
 * ALLOC_PRIM is for allocating memory on the heap for a primitive
 * object.  It is used all over PrimOps.cmm.
 *
 * We make the simplifying assumption that the "admin" part of a
 * primitive closure is just the header when calculating sizes for
 * ticky-ticky.  It's not clear whether eg. the size field of an array
 * should be counted as "admin", or the various fields of a BCO.
 */
#define ALLOC_PRIM(bytes)                                       \
   HP_CHK_GEN_TICKY(bytes);                                     \
   TICK_ALLOC_PRIM(SIZEOF_StgHeader,bytes-SIZEOF_StgHeader,0);  \
   CCCS_ALLOC(bytes);

#define HEAP_CHECK(bytes,failure)                       \
    TICK_BUMP(HEAP_CHK_ctr);                            \
    Hp = Hp + (bytes);                                  \
    if (Hp > HpLim) { HpAlloc = (bytes); failure; }     \
    TICK_ALLOC_HEAP_NOCTR(bytes);

#define ALLOC_PRIM_WITH_CUSTOM_FAILURE(bytes,failure)           \
    HEAP_CHECK(bytes,failure)                                   \
    TICK_ALLOC_PRIM(SIZEOF_StgHeader,bytes-SIZEOF_StgHeader,0); \
    CCCS_ALLOC(bytes);

#define ALLOC_PRIM_(bytes,fun)                                  \
    ALLOC_PRIM_WITH_CUSTOM_FAILURE(bytes,GC_PRIM(fun));

#define ALLOC_PRIM_P(bytes,fun,arg)                             \
    ALLOC_PRIM_WITH_CUSTOM_FAILURE(bytes,GC_PRIM_P(fun,arg));

#define ALLOC_PRIM_N(bytes,fun,arg)                             \
    ALLOC_PRIM_WITH_CUSTOM_FAILURE(bytes,GC_PRIM_N(fun,arg));

/* CCS_ALLOC wants the size in words, because ccs->mem_alloc is in words */
#define CCCS_ALLOC(__alloc) CCS_ALLOC(BYTES_TO_WDS(__alloc), CCCS)

#define HP_CHK_GEN_TICKY(bytes)                 \
   HP_CHK_GEN(bytes);                           \
   TICK_ALLOC_HEAP_NOCTR(bytes);

#define HP_CHK_P(bytes, fun, arg)               \
   HEAP_CHECK(bytes, GC_PRIM_P(fun,arg))

// TODO I'm not seeing where ALLOC_P_TICKY is used; can it be removed?
//         -NSF March 2013
#define ALLOC_P_TICKY(bytes, fun, arg)          \
   HP_CHK_P(bytes);                             \
   TICK_ALLOC_HEAP_NOCTR(bytes);

#define CHECK_GC()                                                      \
  (bdescr_link(CurrentNursery) == NULL ||                               \
   generation_n_new_large_words(W_[g0]) >= TO_W_(CLong[large_alloc_lim]))

// allocate() allocates from the nursery, so we check to see
// whether the nursery is nearly empty in any function that uses
// allocate() - this includes many of the primops.
//
// HACK alert: the __L__ stuff is here to coax the common-block
// eliminator into commoning up the call stg_gc_noregs() with the same
// code that gets generated by a STK_CHK_GEN() in the same proc.  We
// also need an if (0) { goto __L__; } so that the __L__ label isn't
// optimised away by the control-flow optimiser prior to common-block
// elimination (it will be optimised away later).
//
// This saves some code in gmp-wrappers.cmm where we have lots of
// MAYBE_GC() in the same proc as STK_CHK_GEN().
//
#define MAYBE_GC(retry)                         \
    if (CHECK_GC()) {                           \
        HpAlloc = 0;                            \
        goto __L__;                             \
  __L__:                                        \
        call stg_gc_noregs();                   \
        goto retry;                             \
   }                                            \
   if (0) { goto __L__; }

#define GC_PRIM(fun)                            \
        jump stg_gc_prim(fun);

// Version of GC_PRIM for use in low-level Cmm.  We can call
// stg_gc_prim, because it takes one argument and therefore has a
// platform-independent calling convention (Note [Syntax of .cmm
// files] in CmmParse.y).
#define GC_PRIM_LL(fun)                         \
        R1 = fun;                               \
        jump stg_gc_prim [R1];

// We pass the fun as the second argument, because the arg is
// usually already in the first argument position (R1), so this
// avoids moving it to a different register / stack slot.
#define GC_PRIM_N(fun,arg)                      \
        jump stg_gc_prim_n(arg,fun);

#define GC_PRIM_P(fun,arg)                      \
        jump stg_gc_prim_p(arg,fun);

#define GC_PRIM_P_LL(fun,arg)                   \
        R1 = arg;                               \
        R2 = fun;                               \
        jump stg_gc_prim_p_ll [R1,R2];

#define GC_PRIM_PP(fun,arg1,arg2)               \
        jump stg_gc_prim_pp(arg1,arg2,fun);

#define MAYBE_GC_(fun)                          \
    if (CHECK_GC()) {                           \
        HpAlloc = 0;                            \
        GC_PRIM(fun)                            \
   }

#define MAYBE_GC_N(fun,arg)                     \
    if (CHECK_GC()) {                           \
        HpAlloc = 0;                            \
        GC_PRIM_N(fun,arg)                      \
   }

#define MAYBE_GC_P(fun,arg)                     \
    if (CHECK_GC()) {                           \
        HpAlloc = 0;                            \
        GC_PRIM_P(fun,arg)                      \
   }

#define MAYBE_GC_PP(fun,arg1,arg2)              \
    if (CHECK_GC()) {                           \
        HpAlloc = 0;                            \
        GC_PRIM_PP(fun,arg1,arg2)               \
   }

#define STK_CHK_LL(n, fun)                      \
    TICK_BUMP(STK_CHK_ctr);                     \
    if (Sp - (n) < SpLim) {                     \
        GC_PRIM_LL(fun)                         \
    }

#define STK_CHK_P_LL(n, fun, arg)               \
    TICK_BUMP(STK_CHK_ctr);                     \
    if (Sp - (n) < SpLim) {                     \
        GC_PRIM_P_LL(fun,arg)                   \
    }

#define STK_CHK_PP(n, fun, arg1, arg2)          \
    TICK_BUMP(STK_CHK_ctr);                     \
    if (Sp - (n) < SpLim) {                     \
        GC_PRIM_PP(fun,arg1,arg2)               \
    }

#define STK_CHK_ENTER(n, closure)               \
    TICK_BUMP(STK_CHK_ctr);                     \
    if (Sp - (n) < SpLim) {                     \
        jump __stg_gc_enter_1(closure);         \
    }

// A funky heap check used by AutoApply.cmm

#define HP_CHK_NP_ASSIGN_SP0(size,f)                    \
    HEAP_CHECK(size, Sp(0) = f; jump __stg_gc_enter_1 [R1];)

/* -----------------------------------------------------------------------------
   Closure headers
   -------------------------------------------------------------------------- */

/*
 * This is really ugly, since we don't do the rest of StgHeader this
 * way.  The problem is that values from DerivedConstants.h cannot be
 * dependent on the way (SMP, PROF etc.).  For SIZEOF_StgHeader we get
 * the value from GHC, but it seems like too much trouble to do that
 * for StgThunkHeader.
 */
#define SIZEOF_StgThunkHeader SIZEOF_StgHeader+SIZEOF_StgSMPThunkHeader

#define StgThunk_payload(__ptr__,__ix__) \
    W_[__ptr__+SIZEOF_StgThunkHeader+ WDS(__ix__)]

/* -----------------------------------------------------------------------------
   Closures
   -------------------------------------------------------------------------- */

/* The offset of the payload of an array */
#define BYTE_ARR_CTS(arr)  ((arr) + SIZEOF_StgArrWords)

/* The number of words allocated in an array payload */
#define BYTE_ARR_WDS(arr) ROUNDUP_BYTES_TO_WDS(StgArrWords_bytes(arr))

/* Getting/setting the info pointer of a closure */
#define SET_INFO(p,info) StgHeader_info(p) = info
#define GET_INFO(p) StgHeader_info(p)

/* Determine the size of an ordinary closure from its info table */
#define sizeW_fromITBL(itbl) \
  SIZEOF_StgHeader + WDS(%INFO_PTRS(itbl)) + WDS(%INFO_NPTRS(itbl))

/* NB. duplicated from InfoTables.h! */
#define BITMAP_SIZE(bitmap) ((bitmap) & BITMAP_SIZE_MASK)
#define BITMAP_BITS(bitmap) ((bitmap) >> BITMAP_BITS_SHIFT)

/* Debugging macros */
#define LOOKS_LIKE_INFO_PTR(p)                                  \
   ((p) != NULL &&                                              \
    LOOKS_LIKE_INFO_PTR_NOT_NULL(p))

#define LOOKS_LIKE_INFO_PTR_NOT_NULL(p)                         \
   ( (TO_W_(%INFO_TYPE(%STD_INFO(p))) != INVALID_OBJECT) &&     \
     (TO_W_(%INFO_TYPE(%STD_INFO(p))) <  N_CLOSURE_TYPES))

#define LOOKS_LIKE_CLOSURE_PTR(p) (LOOKS_LIKE_INFO_PTR(GET_INFO(UNTAG(p))))

/*
 * The layout of the StgFunInfoExtra part of an info table changes
 * depending on TABLES_NEXT_TO_CODE.  So we define field access
 * macros which use the appropriate version here:
 */
#ifdef TABLES_NEXT_TO_CODE
/*
 * when TABLES_NEXT_TO_CODE, slow_apply is stored as an offset
 * instead of the normal pointer.
 */

#define StgFunInfoExtra_slow_apply(fun_info)    \
        (TO_W_(StgFunInfoExtraRev_slow_apply_offset(fun_info))    \
               + (fun_info) + SIZEOF_StgFunInfoExtraRev + SIZEOF_StgInfoTable)

#define StgFunInfoExtra_fun_type(i)   StgFunInfoExtraRev_fun_type(i)
#define StgFunInfoExtra_arity(i)      StgFunInfoExtraRev_arity(i)
#define StgFunInfoExtra_bitmap(i)     StgFunInfoExtraRev_bitmap(i)
#else
#define StgFunInfoExtra_slow_apply(i) StgFunInfoExtraFwd_slow_apply(i)
#define StgFunInfoExtra_fun_type(i)   StgFunInfoExtraFwd_fun_type(i)
#define StgFunInfoExtra_arity(i)      StgFunInfoExtraFwd_arity(i)
#define StgFunInfoExtra_bitmap(i)     StgFunInfoExtraFwd_bitmap(i)
#endif

#define mutArrCardMask ((1 << MUT_ARR_PTRS_CARD_BITS) - 1)
#define mutArrPtrCardDown(i) ((i) >> MUT_ARR_PTRS_CARD_BITS)
#define mutArrPtrCardUp(i)   (((i) + mutArrCardMask) >> MUT_ARR_PTRS_CARD_BITS)
#define mutArrPtrsCardWords(n) ROUNDUP_BYTES_TO_WDS(mutArrPtrCardUp(n))

#if defined(PROFILING) || (!defined(THREADED_RTS) && defined(DEBUG))
#define OVERWRITING_CLOSURE(c) foreign "C" overwritingClosure(c "ptr")
#define OVERWRITING_CLOSURE_OFS(c,n) \
    foreign "C" overwritingClosureOfs(c "ptr", n)
#else
#define OVERWRITING_CLOSURE(c) /* nothing */
#define OVERWRITING_CLOSURE_OFS(c,n) /* nothing */
#endif

#ifdef THREADED_RTS
#define prim_write_barrier prim %write_barrier()
#else
#define prim_write_barrier /* nothing */
#endif

/* -----------------------------------------------------------------------------
   Ticky macros
   -------------------------------------------------------------------------- */

#ifdef TICKY_TICKY
#define TICK_BUMP_BY(ctr,n) CLong[ctr] = CLong[ctr] + n
#else
#define TICK_BUMP_BY(ctr,n) /* nothing */
#endif

#define TICK_BUMP(ctr)      TICK_BUMP_BY(ctr,1)

#define TICK_ENT_DYN_IND()              TICK_BUMP(ENT_DYN_IND_ctr)
#define TICK_ENT_DYN_THK()              TICK_BUMP(ENT_DYN_THK_ctr)
#define TICK_ENT_VIA_NODE()             TICK_BUMP(ENT_VIA_NODE_ctr)
#define TICK_ENT_STATIC_IND()           TICK_BUMP(ENT_STATIC_IND_ctr)
#define TICK_ENT_PERM_IND()             TICK_BUMP(ENT_PERM_IND_ctr)
#define TICK_ENT_PAP()                  TICK_BUMP(ENT_PAP_ctr)
#define TICK_ENT_AP()                   TICK_BUMP(ENT_AP_ctr)
#define TICK_ENT_AP_STACK()             TICK_BUMP(ENT_AP_STACK_ctr)
#define TICK_ENT_BH()                   TICK_BUMP(ENT_BH_ctr)
#define TICK_ENT_LNE()                  TICK_BUMP(ENT_LNE_ctr)
#define TICK_UNKNOWN_CALL()             TICK_BUMP(UNKNOWN_CALL_ctr)
#define TICK_UPDF_PUSHED()              TICK_BUMP(UPDF_PUSHED_ctr)
#define TICK_CATCHF_PUSHED()            TICK_BUMP(CATCHF_PUSHED_ctr)
#define TICK_UPDF_OMITTED()             TICK_BUMP(UPDF_OMITTED_ctr)
#define TICK_UPD_NEW_IND()              TICK_BUMP(UPD_NEW_IND_ctr)
#define TICK_UPD_NEW_PERM_IND()         TICK_BUMP(UPD_NEW_PERM_IND_ctr)
#define TICK_UPD_OLD_IND()              TICK_BUMP(UPD_OLD_IND_ctr)
#define TICK_UPD_OLD_PERM_IND()         TICK_BUMP(UPD_OLD_PERM_IND_ctr)

#define TICK_SLOW_CALL_FUN_TOO_FEW()    TICK_BUMP(SLOW_CALL_FUN_TOO_FEW_ctr)
#define TICK_SLOW_CALL_FUN_CORRECT()    TICK_BUMP(SLOW_CALL_FUN_CORRECT_ctr)
#define TICK_SLOW_CALL_FUN_TOO_MANY()   TICK_BUMP(SLOW_CALL_FUN_TOO_MANY_ctr)
#define TICK_SLOW_CALL_PAP_TOO_FEW()    TICK_BUMP(SLOW_CALL_PAP_TOO_FEW_ctr)
#define TICK_SLOW_CALL_PAP_CORRECT()    TICK_BUMP(SLOW_CALL_PAP_CORRECT_ctr)
#define TICK_SLOW_CALL_PAP_TOO_MANY()   TICK_BUMP(SLOW_CALL_PAP_TOO_MANY_ctr)

#define TICK_SLOW_CALL_fast_v16()       TICK_BUMP(SLOW_CALL_fast_v16_ctr)
#define TICK_SLOW_CALL_fast_v()         TICK_BUMP(SLOW_CALL_fast_v_ctr)
#define TICK_SLOW_CALL_fast_p()         TICK_BUMP(SLOW_CALL_fast_p_ctr)
#define TICK_SLOW_CALL_fast_pv()        TICK_BUMP(SLOW_CALL_fast_pv_ctr)
#define TICK_SLOW_CALL_fast_pp()        TICK_BUMP(SLOW_CALL_fast_pp_ctr)
#define TICK_SLOW_CALL_fast_ppv()       TICK_BUMP(SLOW_CALL_fast_ppv_ctr)
#define TICK_SLOW_CALL_fast_ppp()       TICK_BUMP(SLOW_CALL_fast_ppp_ctr)
#define TICK_SLOW_CALL_fast_pppv()      TICK_BUMP(SLOW_CALL_fast_pppv_ctr)
#define TICK_SLOW_CALL_fast_pppp()      TICK_BUMP(SLOW_CALL_fast_pppp_ctr)
#define TICK_SLOW_CALL_fast_ppppp()     TICK_BUMP(SLOW_CALL_fast_ppppp_ctr)
#define TICK_SLOW_CALL_fast_pppppp()    TICK_BUMP(SLOW_CALL_fast_pppppp_ctr)
#define TICK_VERY_SLOW_CALL()           TICK_BUMP(VERY_SLOW_CALL_ctr)

/* NOTE: TICK_HISTO_BY and TICK_HISTO
   currently have no effect.
   The old code for it didn't typecheck and I
   just commented it out to get ticky to work.
   - krc 1/2007 */

#define TICK_HISTO_BY(histo,n,i) /* nothing */

#define TICK_HISTO(histo,n) TICK_HISTO_BY(histo,n,1)

/* An unboxed tuple with n components. */
#define TICK_RET_UNBOXED_TUP(n)                 \
  TICK_BUMP(RET_UNBOXED_TUP_ctr++);             \
  TICK_HISTO(RET_UNBOXED_TUP,n)

/*
 * A slow call with n arguments.  In the unevald case, this call has
 * already been counted once, so don't count it again.
 */
#define TICK_SLOW_CALL(n)                       \
  TICK_BUMP(SLOW_CALL_ctr);                     \
  TICK_HISTO(SLOW_CALL,n)

/*
 * This slow call was found to be to an unevaluated function; undo the
 * ticks we did in TICK_SLOW_CALL.
 */
#define TICK_SLOW_CALL_UNEVALD(n)               \
  TICK_BUMP(SLOW_CALL_UNEVALD_ctr);             \
  TICK_BUMP_BY(SLOW_CALL_ctr,-1);               \
  TICK_HISTO_BY(SLOW_CALL,n,-1);

/* Updating a closure with a new CON */
#define TICK_UPD_CON_IN_NEW(n)                  \
  TICK_BUMP(UPD_CON_IN_NEW_ctr);                \
  TICK_HISTO(UPD_CON_IN_NEW,n)

#define TICK_ALLOC_HEAP_NOCTR(bytes)            \
    TICK_BUMP(ALLOC_RTS_ctr);                   \
    TICK_BUMP_BY(ALLOC_RTS_tot,bytes)

/* -----------------------------------------------------------------------------
   Saving and restoring STG registers

   STG registers must be saved around a C call, just in case the STG
   register is mapped to a caller-saves machine register.  Normally we
   don't need to worry about this the code generator has already
   loaded any live STG registers into variables for us, but in
   hand-written low-level Cmm code where we don't know which registers
   are live, we might have to save them all.
   -------------------------------------------------------------------------- */

#define SAVE_STGREGS                            \
    W_ r1, r2, r3,  r4,  r5,  r6,  r7,  r8;     \
    F_ f1, f2, f3, f4, f5, f6;                  \
    D_ d1, d2, d3, d4, d5, d6;                  \
    L_ l1;                                      \
                                                \
    r1 = R1;                                    \
    r2 = R2;                                    \
    r3 = R3;                                    \
    r4 = R4;                                    \
    r5 = R5;                                    \
    r6 = R6;                                    \
    r7 = R7;                                    \
    r8 = R8;                                    \
                                                \
    f1 = F1;                                    \
    f2 = F2;                                    \
    f3 = F3;                                    \
    f4 = F4;                                    \
    f5 = F5;                                    \
    f6 = F6;                                    \
                                                \
    d1 = D1;                                    \
    d2 = D2;                                    \
    d3 = D3;                                    \
    d4 = D4;                                    \
    d5 = D5;                                    \
    d6 = D6;                                    \
                                                \
    l1 = L1;


#define RESTORE_STGREGS                         \
    R1 = r1;                                    \
    R2 = r2;                                    \
    R3 = r3;                                    \
    R4 = r4;                                    \
    R5 = r5;                                    \
    R6 = r6;                                    \
    R7 = r7;                                    \
    R8 = r8;                                    \
                                                \
    F1 = f1;                                    \
    F2 = f2;                                    \
    F3 = f3;                                    \
    F4 = f4;                                    \
    F5 = f5;                                    \
    F6 = f6;                                    \
                                                \
    D1 = d1;                                    \
    D2 = d2;                                    \
    D3 = d3;                                    \
    D4 = d4;                                    \
    D5 = d5;                                    \
    D6 = d6;                                    \
                                                \
    L1 = l1;

/* -----------------------------------------------------------------------------
   Misc junk
   -------------------------------------------------------------------------- */

#define NO_TREC                   stg_NO_TREC_closure
#define END_TSO_QUEUE             stg_END_TSO_QUEUE_closure
#define STM_AWOKEN                stg_STM_AWOKEN_closure
#define END_INVARIANT_CHECK_QUEUE stg_END_INVARIANT_CHECK_QUEUE_closure

#define recordMutableCap(p, gen)                                        \
  W_ __bd;                                                              \
  W_ mut_list;                                                          \
  mut_list = Capability_mut_lists(MyCapability()) + WDS(gen);           \
 __bd = W_[mut_list];                                                   \
  if (bdescr_free(__bd) >= bdescr_start(__bd) + BLOCK_SIZE) {           \
      W_ __new_bd;                                                      \
      ("ptr" __new_bd) = foreign "C" allocBlock_lock();                 \
      bdescr_link(__new_bd) = __bd;                                     \
      __bd = __new_bd;                                                  \
      W_[mut_list] = __bd;                                              \
  }                                                                     \
  W_ free;                                                              \
  free = bdescr_free(__bd);                                             \
  W_[free] = p;                                                         \
  bdescr_free(__bd) = free + WDS(1);

#define recordMutable(p)                                        \
      P_ __p;                                                   \
      W_ __bd;                                                  \
      W_ __gen;                                                 \
      __p = p;                                                  \
      __bd = Bdescr(__p);                                       \
      __gen = TO_W_(bdescr_gen_no(__bd));                       \
      if (__gen > 0) { recordMutableCap(__p, __gen); }

/* -----------------------------------------------------------------------------
   Arrays
   -------------------------------------------------------------------------- */

/* Complete function body for the clone family of (mutable) array ops.
   Defined as a macro to avoid function call overhead or code
   duplication. */
#define cloneArray(info, src, offset, n)                       \
    W_ words, size;                                            \
    gcptr dst, dst_p, src_p;                                   \
                                                               \
    again: MAYBE_GC(again);                                    \
                                                               \
    size = n + mutArrPtrsCardWords(n);                         \
    words = BYTES_TO_WDS(SIZEOF_StgMutArrPtrs) + size;         \
    ("ptr" dst) = ccall allocate(MyCapability() "ptr", words); \
    TICK_ALLOC_PRIM(SIZEOF_StgMutArrPtrs, WDS(size), 0);       \
                                                               \
    SET_HDR(dst, info, CCCS);                                  \
    StgMutArrPtrs_ptrs(dst) = n;                               \
    StgMutArrPtrs_size(dst) = size;                            \
                                                               \
    dst_p = dst + SIZEOF_StgMutArrPtrs;                        \
    src_p = src + SIZEOF_StgMutArrPtrs + WDS(offset);          \
  while:                                                       \
    if (n != 0) {                                              \
        n = n - 1;                                             \
        W_[dst_p] = W_[src_p];                                 \
        dst_p = dst_p + WDS(1);                                \
        src_p = src_p + WDS(1);                                \
        goto while;                                            \
    }                                                          \
                                                               \
    return (dst);

#define copyArray(src, src_off, dst, dst_off, n)                  \
  W_ dst_elems_p, dst_p, src_p, dst_cards_p, bytes;               \
                                                                  \
    if ((n) != 0) {                                               \
        SET_HDR(dst, stg_MUT_ARR_PTRS_DIRTY_info, CCCS);          \
                                                                  \
        dst_elems_p = (dst) + SIZEOF_StgMutArrPtrs;               \
        dst_p = dst_elems_p + WDS(dst_off);                       \
        src_p = (src) + SIZEOF_StgMutArrPtrs + WDS(src_off);      \
        bytes = WDS(n);                                           \
                                                                  \
        prim %memcpy(dst_p, src_p, bytes, WDS(1));                \
                                                                  \
        dst_cards_p = dst_elems_p + WDS(StgMutArrPtrs_ptrs(dst)); \
        setCards(dst_cards_p, dst_off, n);                        \
    }                                                             \
                                                                  \
    return ();

#define copyMutableArray(src, src_off, dst, dst_off, n)           \
  W_ dst_elems_p, dst_p, src_p, dst_cards_p, bytes;               \
                                                                  \
    if ((n) != 0) {                                               \
        SET_HDR(dst, stg_MUT_ARR_PTRS_DIRTY_info, CCCS);          \
                                                                  \
        dst_elems_p = (dst) + SIZEOF_StgMutArrPtrs;               \
        dst_p = dst_elems_p + WDS(dst_off);                       \
        src_p = (src) + SIZEOF_StgMutArrPtrs + WDS(src_off);      \
        bytes = WDS(n);                                           \
                                                                  \
        if ((src) == (dst)) {                                     \
            prim %memmove(dst_p, src_p, bytes, WDS(1));           \
        } else {                                                  \
            prim %memcpy(dst_p, src_p, bytes, WDS(1));            \
        }                                                         \
                                                                  \
        dst_cards_p = dst_elems_p + WDS(StgMutArrPtrs_ptrs(dst)); \
        setCards(dst_cards_p, dst_off, n);                        \
    }                                                             \
                                                                  \
    return ();

/*
 * Set the cards in the cards table pointed to by dst_cards_p for an
 * update to n elements, starting at element dst_off.
 */
#define setCards(dst_cards_p, dst_off, n)                      \
    W_ __start_card, __end_card, __cards;                      \
    __start_card = mutArrPtrCardDown(dst_off);                 \
    __end_card = mutArrPtrCardDown((dst_off) + (n) - 1);       \
    __cards = __end_card - __start_card + 1;                   \
    prim %memset((dst_cards_p) + __start_card, 1, __cards, 1);

/* Complete function body for the clone family of small (mutable)
   array ops. Defined as a macro to avoid function call overhead or
   code duplication. */
#define cloneSmallArray(info, src, offset, n)                  \
    W_ words, size;                                            \
    gcptr dst, dst_p, src_p;                                   \
                                                               \
    again: MAYBE_GC(again);                                    \
                                                               \
    words = BYTES_TO_WDS(SIZEOF_StgSmallMutArrPtrs) + n;       \
    ("ptr" dst) = ccall allocate(MyCapability() "ptr", words); \
    TICK_ALLOC_PRIM(SIZEOF_StgSmallMutArrPtrs, WDS(n), 0);     \
                                                               \
    SET_HDR(dst, info, CCCS);                                  \
    StgSmallMutArrPtrs_ptrs(dst) = n;                          \
                                                               \
    dst_p = dst + SIZEOF_StgSmallMutArrPtrs;                   \
    src_p = src + SIZEOF_StgSmallMutArrPtrs + WDS(offset);     \
  while:                                                       \
    if (n != 0) {                                              \
        n = n - 1;                                             \
        W_[dst_p] = W_[src_p];                                 \
        dst_p = dst_p + WDS(1);                                \
        src_p = src_p + WDS(1);                                \
        goto while;                                            \
    }                                                          \
                                                               \
    return (dst);

#endif /* CMM_H */
{-# START_FILE include/ghc-7.10.2/DerivedConstants.h #-}
/* This file is created automatically.  Do not edit by hand.*/

#define STD_HDR_SIZE 1
#define PROF_HDR_SIZE 2
#define BLOCK_SIZE 4096
#define MBLOCK_SIZE 1048576
#define BLOCKS_PER_MBLOCK 252
#define OFFSET_StgRegTable_rR1 0
#define OFFSET_StgRegTable_rR2 8
#define OFFSET_StgRegTable_rR3 16
#define OFFSET_StgRegTable_rR4 24
#define OFFSET_StgRegTable_rR5 32
#define OFFSET_StgRegTable_rR6 40
#define OFFSET_StgRegTable_rR7 48
#define OFFSET_StgRegTable_rR8 56
#define OFFSET_StgRegTable_rR9 64
#define OFFSET_StgRegTable_rR10 72
#define OFFSET_StgRegTable_rF1 80
#define OFFSET_StgRegTable_rF2 84
#define OFFSET_StgRegTable_rF3 88
#define OFFSET_StgRegTable_rF4 92
#define OFFSET_StgRegTable_rF5 96
#define OFFSET_StgRegTable_rF6 100
#define OFFSET_StgRegTable_rD1 104
#define OFFSET_StgRegTable_rD2 112
#define OFFSET_StgRegTable_rD3 120
#define OFFSET_StgRegTable_rD4 128
#define OFFSET_StgRegTable_rD5 136
#define OFFSET_StgRegTable_rD6 144
#define OFFSET_StgRegTable_rXMM1 152
#define OFFSET_StgRegTable_rXMM2 168
#define OFFSET_StgRegTable_rXMM3 184
#define OFFSET_StgRegTable_rXMM4 200
#define OFFSET_StgRegTable_rXMM5 216
#define OFFSET_StgRegTable_rXMM6 232
#define OFFSET_StgRegTable_rYMM1 248
#define OFFSET_StgRegTable_rYMM2 280
#define OFFSET_StgRegTable_rYMM3 312
#define OFFSET_StgRegTable_rYMM4 344
#define OFFSET_StgRegTable_rYMM5 376
#define OFFSET_StgRegTable_rYMM6 408
#define OFFSET_StgRegTable_rZMM1 440
#define OFFSET_StgRegTable_rZMM2 504
#define OFFSET_StgRegTable_rZMM3 568
#define OFFSET_StgRegTable_rZMM4 632
#define OFFSET_StgRegTable_rZMM5 696
#define OFFSET_StgRegTable_rZMM6 760
#define OFFSET_StgRegTable_rL1 824
#define OFFSET_StgRegTable_rSp 832
#define OFFSET_StgRegTable_rSpLim 840
#define OFFSET_StgRegTable_rHp 848
#define OFFSET_StgRegTable_rHpLim 856
#define OFFSET_StgRegTable_rCCCS 864
#define OFFSET_StgRegTable_rCurrentTSO 872
#define OFFSET_StgRegTable_rCurrentNursery 888
#define OFFSET_StgRegTable_rHpAlloc 904
#define OFFSET_StgRegTable_rRet 912
#define REP_StgRegTable_rRet b64
#define StgRegTable_rRet(__ptr__) REP_StgRegTable_rRet[__ptr__+OFFSET_StgRegTable_rRet]
#define OFFSET_StgRegTable_rNursery 880
#define REP_StgRegTable_rNursery b64
#define StgRegTable_rNursery(__ptr__) REP_StgRegTable_rNursery[__ptr__+OFFSET_StgRegTable_rNursery]
#define OFFSET_stgEagerBlackholeInfo -24
#define OFFSET_stgGCEnter1 -16
#define OFFSET_stgGCFun -8
#define OFFSET_Capability_r 24
#define OFFSET_Capability_lock 1080
#define OFFSET_Capability_no 944
#define REP_Capability_no b32
#define Capability_no(__ptr__) REP_Capability_no[__ptr__+OFFSET_Capability_no]
#define OFFSET_Capability_mut_lists 1000
#define REP_Capability_mut_lists b64
#define Capability_mut_lists(__ptr__) REP_Capability_mut_lists[__ptr__+OFFSET_Capability_mut_lists]
#define OFFSET_Capability_context_switch 1048
#define REP_Capability_context_switch b32
#define Capability_context_switch(__ptr__) REP_Capability_context_switch[__ptr__+OFFSET_Capability_context_switch]
#define OFFSET_Capability_interrupt 1052
#define REP_Capability_interrupt b32
#define Capability_interrupt(__ptr__) REP_Capability_interrupt[__ptr__+OFFSET_Capability_interrupt]
#define OFFSET_Capability_sparks 1168
#define REP_Capability_sparks b64
#define Capability_sparks(__ptr__) REP_Capability_sparks[__ptr__+OFFSET_Capability_sparks]
#define OFFSET_Capability_total_allocated 1056
#define REP_Capability_total_allocated b64
#define Capability_total_allocated(__ptr__) REP_Capability_total_allocated[__ptr__+OFFSET_Capability_total_allocated]
#define OFFSET_Capability_weak_ptr_list_hd 1032
#define REP_Capability_weak_ptr_list_hd b64
#define Capability_weak_ptr_list_hd(__ptr__) REP_Capability_weak_ptr_list_hd[__ptr__+OFFSET_Capability_weak_ptr_list_hd]
#define OFFSET_Capability_weak_ptr_list_tl 1040
#define REP_Capability_weak_ptr_list_tl b64
#define Capability_weak_ptr_list_tl(__ptr__) REP_Capability_weak_ptr_list_tl[__ptr__+OFFSET_Capability_weak_ptr_list_tl]
#define OFFSET_bdescr_start 0
#define REP_bdescr_start b64
#define bdescr_start(__ptr__) REP_bdescr_start[__ptr__+OFFSET_bdescr_start]
#define OFFSET_bdescr_free 8
#define REP_bdescr_free b64
#define bdescr_free(__ptr__) REP_bdescr_free[__ptr__+OFFSET_bdescr_free]
#define OFFSET_bdescr_blocks 48
#define REP_bdescr_blocks b32
#define bdescr_blocks(__ptr__) REP_bdescr_blocks[__ptr__+OFFSET_bdescr_blocks]
#define OFFSET_bdescr_gen_no 40
#define REP_bdescr_gen_no b16
#define bdescr_gen_no(__ptr__) REP_bdescr_gen_no[__ptr__+OFFSET_bdescr_gen_no]
#define OFFSET_bdescr_link 16
#define REP_bdescr_link b64
#define bdescr_link(__ptr__) REP_bdescr_link[__ptr__+OFFSET_bdescr_link]
#define SIZEOF_generation 328
#define OFFSET_generation_n_new_large_words 56
#define REP_generation_n_new_large_words b64
#define generation_n_new_large_words(__ptr__) REP_generation_n_new_large_words[__ptr__+OFFSET_generation_n_new_large_words]
#define OFFSET_generation_weak_ptr_list 80
#define REP_generation_weak_ptr_list b64
#define generation_weak_ptr_list(__ptr__) REP_generation_weak_ptr_list[__ptr__+OFFSET_generation_weak_ptr_list]
#define SIZEOF_CostCentreStack 96
#define OFFSET_CostCentreStack_ccsID 0
#define REP_CostCentreStack_ccsID b64
#define CostCentreStack_ccsID(__ptr__) REP_CostCentreStack_ccsID[__ptr__+OFFSET_CostCentreStack_ccsID]
#define OFFSET_CostCentreStack_mem_alloc 72
#define REP_CostCentreStack_mem_alloc b64
#define CostCentreStack_mem_alloc(__ptr__) REP_CostCentreStack_mem_alloc[__ptr__+OFFSET_CostCentreStack_mem_alloc]
#define OFFSET_CostCentreStack_scc_count 48
#define REP_CostCentreStack_scc_count b64
#define CostCentreStack_scc_count(__ptr__) REP_CostCentreStack_scc_count[__ptr__+OFFSET_CostCentreStack_scc_count]
#define OFFSET_CostCentreStack_prevStack 16
#define REP_CostCentreStack_prevStack b64
#define CostCentreStack_prevStack(__ptr__) REP_CostCentreStack_prevStack[__ptr__+OFFSET_CostCentreStack_prevStack]
#define OFFSET_CostCentre_ccID 0
#define REP_CostCentre_ccID b64
#define CostCentre_ccID(__ptr__) REP_CostCentre_ccID[__ptr__+OFFSET_CostCentre_ccID]
#define OFFSET_CostCentre_link 56
#define REP_CostCentre_link b64
#define CostCentre_link(__ptr__) REP_CostCentre_link[__ptr__+OFFSET_CostCentre_link]
#define OFFSET_StgHeader_info 0
#define REP_StgHeader_info b64
#define StgHeader_info(__ptr__) REP_StgHeader_info[__ptr__+OFFSET_StgHeader_info]
#define OFFSET_StgHeader_ccs 8
#define REP_StgHeader_ccs b64
#define StgHeader_ccs(__ptr__) REP_StgHeader_ccs[__ptr__+OFFSET_StgHeader_ccs]
#define OFFSET_StgHeader_ldvw 16
#define REP_StgHeader_ldvw b64
#define StgHeader_ldvw(__ptr__) REP_StgHeader_ldvw[__ptr__+OFFSET_StgHeader_ldvw]
#define SIZEOF_StgSMPThunkHeader 8
#define OFFSET_StgClosure_payload 0
#define StgClosure_payload(__ptr__,__ix__) W_[__ptr__+SIZEOF_StgHeader+OFFSET_StgClosure_payload + WDS(__ix__)]
#define OFFSET_StgEntCounter_allocs 48
#define REP_StgEntCounter_allocs b64
#define StgEntCounter_allocs(__ptr__) REP_StgEntCounter_allocs[__ptr__+OFFSET_StgEntCounter_allocs]
#define OFFSET_StgEntCounter_allocd 16
#define REP_StgEntCounter_allocd b64
#define StgEntCounter_allocd(__ptr__) REP_StgEntCounter_allocd[__ptr__+OFFSET_StgEntCounter_allocd]
#define OFFSET_StgEntCounter_registeredp 0
#define REP_StgEntCounter_registeredp b64
#define StgEntCounter_registeredp(__ptr__) REP_StgEntCounter_registeredp[__ptr__+OFFSET_StgEntCounter_registeredp]
#define OFFSET_StgEntCounter_link 56
#define REP_StgEntCounter_link b64
#define StgEntCounter_link(__ptr__) REP_StgEntCounter_link[__ptr__+OFFSET_StgEntCounter_link]
#define OFFSET_StgEntCounter_entry_count 40
#define REP_StgEntCounter_entry_count b64
#define StgEntCounter_entry_count(__ptr__) REP_StgEntCounter_entry_count[__ptr__+OFFSET_StgEntCounter_entry_count]
#define SIZEOF_StgUpdateFrame_NoHdr 8
#define SIZEOF_StgUpdateFrame (SIZEOF_StgHeader+8)
#define SIZEOF_StgCatchFrame_NoHdr 16
#define SIZEOF_StgCatchFrame (SIZEOF_StgHeader+16)
#define SIZEOF_StgStopFrame_NoHdr 0
#define SIZEOF_StgStopFrame (SIZEOF_StgHeader+0)
#define SIZEOF_StgMutArrPtrs_NoHdr 16
#define SIZEOF_StgMutArrPtrs (SIZEOF_StgHeader+16)
#define OFFSET_StgMutArrPtrs_ptrs 0
#define REP_StgMutArrPtrs_ptrs b64
#define StgMutArrPtrs_ptrs(__ptr__) REP_StgMutArrPtrs_ptrs[__ptr__+SIZEOF_StgHeader+OFFSET_StgMutArrPtrs_ptrs]
#define OFFSET_StgMutArrPtrs_size 8
#define REP_StgMutArrPtrs_size b64
#define StgMutArrPtrs_size(__ptr__) REP_StgMutArrPtrs_size[__ptr__+SIZEOF_StgHeader+OFFSET_StgMutArrPtrs_size]
#define SIZEOF_StgSmallMutArrPtrs_NoHdr 8
#define SIZEOF_StgSmallMutArrPtrs (SIZEOF_StgHeader+8)
#define OFFSET_StgSmallMutArrPtrs_ptrs 0
#define REP_StgSmallMutArrPtrs_ptrs b64
#define StgSmallMutArrPtrs_ptrs(__ptr__) REP_StgSmallMutArrPtrs_ptrs[__ptr__+SIZEOF_StgHeader+OFFSET_StgSmallMutArrPtrs_ptrs]
#define SIZEOF_StgArrWords_NoHdr 8
#define SIZEOF_StgArrWords (SIZEOF_StgHeader+8)
#define OFFSET_StgArrWords_bytes 0
#define REP_StgArrWords_bytes b64
#define StgArrWords_bytes(__ptr__) REP_StgArrWords_bytes[__ptr__+SIZEOF_StgHeader+OFFSET_StgArrWords_bytes]
#define OFFSET_StgArrWords_payload 8
#define StgArrWords_payload(__ptr__,__ix__) W_[__ptr__+SIZEOF_StgHeader+OFFSET_StgArrWords_payload + WDS(__ix__)]
#define OFFSET_StgTSO__link 0
#define REP_StgTSO__link b64
#define StgTSO__link(__ptr__) REP_StgTSO__link[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO__link]
#define OFFSET_StgTSO_global_link 8
#define REP_StgTSO_global_link b64
#define StgTSO_global_link(__ptr__) REP_StgTSO_global_link[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_global_link]
#define OFFSET_StgTSO_what_next 24
#define REP_StgTSO_what_next b16
#define StgTSO_what_next(__ptr__) REP_StgTSO_what_next[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_what_next]
#define OFFSET_StgTSO_why_blocked 26
#define REP_StgTSO_why_blocked b16
#define StgTSO_why_blocked(__ptr__) REP_StgTSO_why_blocked[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_why_blocked]
#define OFFSET_StgTSO_block_info 32
#define REP_StgTSO_block_info b64
#define StgTSO_block_info(__ptr__) REP_StgTSO_block_info[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_block_info]
#define OFFSET_StgTSO_blocked_exceptions 80
#define REP_StgTSO_blocked_exceptions b64
#define StgTSO_blocked_exceptions(__ptr__) REP_StgTSO_blocked_exceptions[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_blocked_exceptions]
#define OFFSET_StgTSO_id 40
#define REP_StgTSO_id b32
#define StgTSO_id(__ptr__) REP_StgTSO_id[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_id]
#define OFFSET_StgTSO_cap 64
#define REP_StgTSO_cap b64
#define StgTSO_cap(__ptr__) REP_StgTSO_cap[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_cap]
#define OFFSET_StgTSO_saved_errno 44
#define REP_StgTSO_saved_errno b32
#define StgTSO_saved_errno(__ptr__) REP_StgTSO_saved_errno[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_saved_errno]
#define OFFSET_StgTSO_trec 72
#define REP_StgTSO_trec b64
#define StgTSO_trec(__ptr__) REP_StgTSO_trec[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_trec]
#define OFFSET_StgTSO_flags 28
#define REP_StgTSO_flags b32
#define StgTSO_flags(__ptr__) REP_StgTSO_flags[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_flags]
#define OFFSET_StgTSO_dirty 48
#define REP_StgTSO_dirty b32
#define StgTSO_dirty(__ptr__) REP_StgTSO_dirty[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_dirty]
#define OFFSET_StgTSO_bq 88
#define REP_StgTSO_bq b64
#define StgTSO_bq(__ptr__) REP_StgTSO_bq[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_bq]
#define OFFSET_StgTSO_alloc_limit 96
#define REP_StgTSO_alloc_limit b64
#define StgTSO_alloc_limit(__ptr__) REP_StgTSO_alloc_limit[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_alloc_limit]
#define OFFSET_StgTSO_cccs 112
#define REP_StgTSO_cccs b64
#define StgTSO_cccs(__ptr__) REP_StgTSO_cccs[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_cccs]
#define OFFSET_StgTSO_stackobj 16
#define REP_StgTSO_stackobj b64
#define StgTSO_stackobj(__ptr__) REP_StgTSO_stackobj[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_stackobj]
#define OFFSET_StgStack_sp 8
#define REP_StgStack_sp b64
#define StgStack_sp(__ptr__) REP_StgStack_sp[__ptr__+SIZEOF_StgHeader+OFFSET_StgStack_sp]
#define OFFSET_StgStack_stack 16
#define OFFSET_StgStack_stack_size 0
#define REP_StgStack_stack_size b32
#define StgStack_stack_size(__ptr__) REP_StgStack_stack_size[__ptr__+SIZEOF_StgHeader+OFFSET_StgStack_stack_size]
#define OFFSET_StgStack_dirty 4
#define REP_StgStack_dirty b32
#define StgStack_dirty(__ptr__) REP_StgStack_dirty[__ptr__+SIZEOF_StgHeader+OFFSET_StgStack_dirty]
#define SIZEOF_StgTSOProfInfo 8
#define OFFSET_StgUpdateFrame_updatee 0
#define REP_StgUpdateFrame_updatee b64
#define StgUpdateFrame_updatee(__ptr__) REP_StgUpdateFrame_updatee[__ptr__+SIZEOF_StgHeader+OFFSET_StgUpdateFrame_updatee]
#define OFFSET_StgCatchFrame_handler 8
#define REP_StgCatchFrame_handler b64
#define StgCatchFrame_handler(__ptr__) REP_StgCatchFrame_handler[__ptr__+SIZEOF_StgHeader+OFFSET_StgCatchFrame_handler]
#define OFFSET_StgCatchFrame_exceptions_blocked 0
#define REP_StgCatchFrame_exceptions_blocked b64
#define StgCatchFrame_exceptions_blocked(__ptr__) REP_StgCatchFrame_exceptions_blocked[__ptr__+SIZEOF_StgHeader+OFFSET_StgCatchFrame_exceptions_blocked]
#define SIZEOF_StgPAP_NoHdr 16
#define SIZEOF_StgPAP (SIZEOF_StgHeader+16)
#define OFFSET_StgPAP_n_args 4
#define REP_StgPAP_n_args b32
#define StgPAP_n_args(__ptr__) REP_StgPAP_n_args[__ptr__+SIZEOF_StgHeader+OFFSET_StgPAP_n_args]
#define OFFSET_StgPAP_fun 8
#define REP_StgPAP_fun gcptr
#define StgPAP_fun(__ptr__) REP_StgPAP_fun[__ptr__+SIZEOF_StgHeader+OFFSET_StgPAP_fun]
#define OFFSET_StgPAP_arity 0
#define REP_StgPAP_arity b32
#define StgPAP_arity(__ptr__) REP_StgPAP_arity[__ptr__+SIZEOF_StgHeader+OFFSET_StgPAP_arity]
#define OFFSET_StgPAP_payload 16
#define StgPAP_payload(__ptr__,__ix__) W_[__ptr__+SIZEOF_StgHeader+OFFSET_StgPAP_payload + WDS(__ix__)]
#define SIZEOF_StgAP_NoThunkHdr 16
#define SIZEOF_StgAP_NoHdr 24
#define SIZEOF_StgAP (SIZEOF_StgHeader+24)
#define OFFSET_StgAP_n_args 12
#define REP_StgAP_n_args b32
#define StgAP_n_args(__ptr__) REP_StgAP_n_args[__ptr__+SIZEOF_StgHeader+OFFSET_StgAP_n_args]
#define OFFSET_StgAP_fun 16
#define REP_StgAP_fun gcptr
#define StgAP_fun(__ptr__) REP_StgAP_fun[__ptr__+SIZEOF_StgHeader+OFFSET_StgAP_fun]
#define OFFSET_StgAP_payload 24
#define StgAP_payload(__ptr__,__ix__) W_[__ptr__+SIZEOF_StgHeader+OFFSET_StgAP_payload + WDS(__ix__)]
#define SIZEOF_StgAP_STACK_NoThunkHdr 16
#define SIZEOF_StgAP_STACK_NoHdr 24
#define SIZEOF_StgAP_STACK (SIZEOF_StgHeader+24)
#define OFFSET_StgAP_STACK_size 8
#define REP_StgAP_STACK_size b64
#define StgAP_STACK_size(__ptr__) REP_StgAP_STACK_size[__ptr__+SIZEOF_StgHeader+OFFSET_StgAP_STACK_size]
#define OFFSET_StgAP_STACK_fun 16
#define REP_StgAP_STACK_fun gcptr
#define StgAP_STACK_fun(__ptr__) REP_StgAP_STACK_fun[__ptr__+SIZEOF_StgHeader+OFFSET_StgAP_STACK_fun]
#define OFFSET_StgAP_STACK_payload 24
#define StgAP_STACK_payload(__ptr__,__ix__) W_[__ptr__+SIZEOF_StgHeader+OFFSET_StgAP_STACK_payload + WDS(__ix__)]
#define SIZEOF_StgSelector_NoThunkHdr 8
#define SIZEOF_StgSelector_NoHdr 16
#define SIZEOF_StgSelector (SIZEOF_StgHeader+16)
#define OFFSET_StgInd_indirectee 0
#define REP_StgInd_indirectee gcptr
#define StgInd_indirectee(__ptr__) REP_StgInd_indirectee[__ptr__+SIZEOF_StgHeader+OFFSET_StgInd_indirectee]
#define SIZEOF_StgMutVar_NoHdr 8
#define SIZEOF_StgMutVar (SIZEOF_StgHeader+8)
#define OFFSET_StgMutVar_var 0
#define REP_StgMutVar_var b64
#define StgMutVar_var(__ptr__) REP_StgMutVar_var[__ptr__+SIZEOF_StgHeader+OFFSET_StgMutVar_var]
#define SIZEOF_StgAtomicallyFrame_NoHdr 24
#define SIZEOF_StgAtomicallyFrame (SIZEOF_StgHeader+24)
#define OFFSET_StgAtomicallyFrame_code 0
#define REP_StgAtomicallyFrame_code b64
#define StgAtomicallyFrame_code(__ptr__) REP_StgAtomicallyFrame_code[__ptr__+SIZEOF_StgHeader+OFFSET_StgAtomicallyFrame_code]
#define OFFSET_StgAtomicallyFrame_next_invariant_to_check 8
#define REP_StgAtomicallyFrame_next_invariant_to_check b64
#define StgAtomicallyFrame_next_invariant_to_check(__ptr__) REP_StgAtomicallyFrame_next_invariant_to_check[__ptr__+SIZEOF_StgHeader+OFFSET_StgAtomicallyFrame_next_invariant_to_check]
#define OFFSET_StgAtomicallyFrame_result 16
#define REP_StgAtomicallyFrame_result b64
#define StgAtomicallyFrame_result(__ptr__) REP_StgAtomicallyFrame_result[__ptr__+SIZEOF_StgHeader+OFFSET_StgAtomicallyFrame_result]
#define OFFSET_StgInvariantCheckQueue_invariant 0
#define REP_StgInvariantCheckQueue_invariant b64
#define StgInvariantCheckQueue_invariant(__ptr__) REP_StgInvariantCheckQueue_invariant[__ptr__+SIZEOF_StgHeader+OFFSET_StgInvariantCheckQueue_invariant]
#define OFFSET_StgInvariantCheckQueue_my_execution 8
#define REP_StgInvariantCheckQueue_my_execution b64
#define StgInvariantCheckQueue_my_execution(__ptr__) REP_StgInvariantCheckQueue_my_execution[__ptr__+SIZEOF_StgHeader+OFFSET_StgInvariantCheckQueue_my_execution]
#define OFFSET_StgInvariantCheckQueue_next_queue_entry 16
#define REP_StgInvariantCheckQueue_next_queue_entry b64
#define StgInvariantCheckQueue_next_queue_entry(__ptr__) REP_StgInvariantCheckQueue_next_queue_entry[__ptr__+SIZEOF_StgHeader+OFFSET_StgInvariantCheckQueue_next_queue_entry]
#define OFFSET_StgAtomicInvariant_code 0
#define REP_StgAtomicInvariant_code b64
#define StgAtomicInvariant_code(__ptr__) REP_StgAtomicInvariant_code[__ptr__+SIZEOF_StgHeader+OFFSET_StgAtomicInvariant_code]
#define OFFSET_StgTRecHeader_enclosing_trec 0
#define REP_StgTRecHeader_enclosing_trec b64
#define StgTRecHeader_enclosing_trec(__ptr__) REP_StgTRecHeader_enclosing_trec[__ptr__+SIZEOF_StgHeader+OFFSET_StgTRecHeader_enclosing_trec]
#define SIZEOF_StgCatchSTMFrame_NoHdr 16
#define SIZEOF_StgCatchSTMFrame (SIZEOF_StgHeader+16)
#define OFFSET_StgCatchSTMFrame_handler 8
#define REP_StgCatchSTMFrame_handler b64
#define StgCatchSTMFrame_handler(__ptr__) REP_StgCatchSTMFrame_handler[__ptr__+SIZEOF_StgHeader+OFFSET_StgCatchSTMFrame_handler]
#define OFFSET_StgCatchSTMFrame_code 0
#define REP_StgCatchSTMFrame_code b64
#define StgCatchSTMFrame_code(__ptr__) REP_StgCatchSTMFrame_code[__ptr__+SIZEOF_StgHeader+OFFSET_StgCatchSTMFrame_code]
#define SIZEOF_StgCatchRetryFrame_NoHdr 24
#define SIZEOF_StgCatchRetryFrame (SIZEOF_StgHeader+24)
#define OFFSET_StgCatchRetryFrame_running_alt_code 0
#define REP_StgCatchRetryFrame_running_alt_code b64
#define StgCatchRetryFrame_running_alt_code(__ptr__) REP_StgCatchRetryFrame_running_alt_code[__ptr__+SIZEOF_StgHeader+OFFSET_StgCatchRetryFrame_running_alt_code]
#define OFFSET_StgCatchRetryFrame_first_code 8
#define REP_StgCatchRetryFrame_first_code b64
#define StgCatchRetryFrame_first_code(__ptr__) REP_StgCatchRetryFrame_first_code[__ptr__+SIZEOF_StgHeader+OFFSET_StgCatchRetryFrame_first_code]
#define OFFSET_StgCatchRetryFrame_alt_code 16
#define REP_StgCatchRetryFrame_alt_code b64
#define StgCatchRetryFrame_alt_code(__ptr__) REP_StgCatchRetryFrame_alt_code[__ptr__+SIZEOF_StgHeader+OFFSET_StgCatchRetryFrame_alt_code]
#define OFFSET_StgTVarWatchQueue_closure 0
#define REP_StgTVarWatchQueue_closure b64
#define StgTVarWatchQueue_closure(__ptr__) REP_StgTVarWatchQueue_closure[__ptr__+SIZEOF_StgHeader+OFFSET_StgTVarWatchQueue_closure]
#define OFFSET_StgTVarWatchQueue_next_queue_entry 8
#define REP_StgTVarWatchQueue_next_queue_entry b64
#define StgTVarWatchQueue_next_queue_entry(__ptr__) REP_StgTVarWatchQueue_next_queue_entry[__ptr__+SIZEOF_StgHeader+OFFSET_StgTVarWatchQueue_next_queue_entry]
#define OFFSET_StgTVarWatchQueue_prev_queue_entry 16
#define REP_StgTVarWatchQueue_prev_queue_entry b64
#define StgTVarWatchQueue_prev_queue_entry(__ptr__) REP_StgTVarWatchQueue_prev_queue_entry[__ptr__+SIZEOF_StgHeader+OFFSET_StgTVarWatchQueue_prev_queue_entry]
#define SIZEOF_StgTVar_NoHdr 24
#define SIZEOF_StgTVar (SIZEOF_StgHeader+24)
#define OFFSET_StgTVar_current_value 0
#define REP_StgTVar_current_value b64
#define StgTVar_current_value(__ptr__) REP_StgTVar_current_value[__ptr__+SIZEOF_StgHeader+OFFSET_StgTVar_current_value]
#define OFFSET_StgTVar_first_watch_queue_entry 8
#define REP_StgTVar_first_watch_queue_entry b64
#define StgTVar_first_watch_queue_entry(__ptr__) REP_StgTVar_first_watch_queue_entry[__ptr__+SIZEOF_StgHeader+OFFSET_StgTVar_first_watch_queue_entry]
#define OFFSET_StgTVar_num_updates 16
#define REP_StgTVar_num_updates b64
#define StgTVar_num_updates(__ptr__) REP_StgTVar_num_updates[__ptr__+SIZEOF_StgHeader+OFFSET_StgTVar_num_updates]
#define SIZEOF_StgWeak_NoHdr 40
#define SIZEOF_StgWeak (SIZEOF_StgHeader+40)
#define OFFSET_StgWeak_link 32
#define REP_StgWeak_link b64
#define StgWeak_link(__ptr__) REP_StgWeak_link[__ptr__+SIZEOF_StgHeader+OFFSET_StgWeak_link]
#define OFFSET_StgWeak_key 8
#define REP_StgWeak_key b64
#define StgWeak_key(__ptr__) REP_StgWeak_key[__ptr__+SIZEOF_StgHeader+OFFSET_StgWeak_key]
#define OFFSET_StgWeak_value 16
#define REP_StgWeak_value b64
#define StgWeak_value(__ptr__) REP_StgWeak_value[__ptr__+SIZEOF_StgHeader+OFFSET_StgWeak_value]
#define OFFSET_StgWeak_finalizer 24
#define REP_StgWeak_finalizer b64
#define StgWeak_finalizer(__ptr__) REP_StgWeak_finalizer[__ptr__+SIZEOF_StgHeader+OFFSET_StgWeak_finalizer]
#define OFFSET_StgWeak_cfinalizers 0
#define REP_StgWeak_cfinalizers b64
#define StgWeak_cfinalizers(__ptr__) REP_StgWeak_cfinalizers[__ptr__+SIZEOF_StgHeader+OFFSET_StgWeak_cfinalizers]
#define SIZEOF_StgCFinalizerList_NoHdr 40
#define SIZEOF_StgCFinalizerList (SIZEOF_StgHeader+40)
#define OFFSET_StgCFinalizerList_link 0
#define REP_StgCFinalizerList_link b64
#define StgCFinalizerList_link(__ptr__) REP_StgCFinalizerList_link[__ptr__+SIZEOF_StgHeader+OFFSET_StgCFinalizerList_link]
#define OFFSET_StgCFinalizerList_fptr 8
#define REP_StgCFinalizerList_fptr b64
#define StgCFinalizerList_fptr(__ptr__) REP_StgCFinalizerList_fptr[__ptr__+SIZEOF_StgHeader+OFFSET_StgCFinalizerList_fptr]
#define OFFSET_StgCFinalizerList_ptr 16
#define REP_StgCFinalizerList_ptr b64
#define StgCFinalizerList_ptr(__ptr__) REP_StgCFinalizerList_ptr[__ptr__+SIZEOF_StgHeader+OFFSET_StgCFinalizerList_ptr]
#define OFFSET_StgCFinalizerList_eptr 24
#define REP_StgCFinalizerList_eptr b64
#define StgCFinalizerList_eptr(__ptr__) REP_StgCFinalizerList_eptr[__ptr__+SIZEOF_StgHeader+OFFSET_StgCFinalizerList_eptr]
#define OFFSET_StgCFinalizerList_flag 32
#define REP_StgCFinalizerList_flag b64
#define StgCFinalizerList_flag(__ptr__) REP_StgCFinalizerList_flag[__ptr__+SIZEOF_StgHeader+OFFSET_StgCFinalizerList_flag]
#define SIZEOF_StgMVar_NoHdr 24
#define SIZEOF_StgMVar (SIZEOF_StgHeader+24)
#define OFFSET_StgMVar_head 0
#define REP_StgMVar_head b64
#define StgMVar_head(__ptr__) REP_StgMVar_head[__ptr__+SIZEOF_StgHeader+OFFSET_StgMVar_head]
#define OFFSET_StgMVar_tail 8
#define REP_StgMVar_tail b64
#define StgMVar_tail(__ptr__) REP_StgMVar_tail[__ptr__+SIZEOF_StgHeader+OFFSET_StgMVar_tail]
#define OFFSET_StgMVar_value 16
#define REP_StgMVar_value b64
#define StgMVar_value(__ptr__) REP_StgMVar_value[__ptr__+SIZEOF_StgHeader+OFFSET_StgMVar_value]
#define SIZEOF_StgMVarTSOQueue_NoHdr 16
#define SIZEOF_StgMVarTSOQueue (SIZEOF_StgHeader+16)
#define OFFSET_StgMVarTSOQueue_link 0
#define REP_StgMVarTSOQueue_link b64
#define StgMVarTSOQueue_link(__ptr__) REP_StgMVarTSOQueue_link[__ptr__+SIZEOF_StgHeader+OFFSET_StgMVarTSOQueue_link]
#define OFFSET_StgMVarTSOQueue_tso 8
#define REP_StgMVarTSOQueue_tso b64
#define StgMVarTSOQueue_tso(__ptr__) REP_StgMVarTSOQueue_tso[__ptr__+SIZEOF_StgHeader+OFFSET_StgMVarTSOQueue_tso]
#define SIZEOF_StgBCO_NoHdr 32
#define SIZEOF_StgBCO (SIZEOF_StgHeader+32)
#define OFFSET_StgBCO_instrs 0
#define REP_StgBCO_instrs b64
#define StgBCO_instrs(__ptr__) REP_StgBCO_instrs[__ptr__+SIZEOF_StgHeader+OFFSET_StgBCO_instrs]
#define OFFSET_StgBCO_literals 8
#define REP_StgBCO_literals b64
#define StgBCO_literals(__ptr__) REP_StgBCO_literals[__ptr__+SIZEOF_StgHeader+OFFSET_StgBCO_literals]
#define OFFSET_StgBCO_ptrs 16
#define REP_StgBCO_ptrs b64
#define StgBCO_ptrs(__ptr__) REP_StgBCO_ptrs[__ptr__+SIZEOF_StgHeader+OFFSET_StgBCO_ptrs]
#define OFFSET_StgBCO_arity 24
#define REP_StgBCO_arity b32
#define StgBCO_arity(__ptr__) REP_StgBCO_arity[__ptr__+SIZEOF_StgHeader+OFFSET_StgBCO_arity]
#define OFFSET_StgBCO_size 28
#define REP_StgBCO_size b32
#define StgBCO_size(__ptr__) REP_StgBCO_size[__ptr__+SIZEOF_StgHeader+OFFSET_StgBCO_size]
#define OFFSET_StgBCO_bitmap 32
#define StgBCO_bitmap(__ptr__,__ix__) W_[__ptr__+SIZEOF_StgHeader+OFFSET_StgBCO_bitmap + WDS(__ix__)]
#define SIZEOF_StgStableName_NoHdr 8
#define SIZEOF_StgStableName (SIZEOF_StgHeader+8)
#define OFFSET_StgStableName_sn 0
#define REP_StgStableName_sn b64
#define StgStableName_sn(__ptr__) REP_StgStableName_sn[__ptr__+SIZEOF_StgHeader+OFFSET_StgStableName_sn]
#define SIZEOF_StgBlockingQueue_NoHdr 32
#define SIZEOF_StgBlockingQueue (SIZEOF_StgHeader+32)
#define OFFSET_StgBlockingQueue_bh 8
#define REP_StgBlockingQueue_bh b64
#define StgBlockingQueue_bh(__ptr__) REP_StgBlockingQueue_bh[__ptr__+SIZEOF_StgHeader+OFFSET_StgBlockingQueue_bh]
#define OFFSET_StgBlockingQueue_owner 16
#define REP_StgBlockingQueue_owner b64
#define StgBlockingQueue_owner(__ptr__) REP_StgBlockingQueue_owner[__ptr__+SIZEOF_StgHeader+OFFSET_StgBlockingQueue_owner]
#define OFFSET_StgBlockingQueue_queue 24
#define REP_StgBlockingQueue_queue b64
#define StgBlockingQueue_queue(__ptr__) REP_StgBlockingQueue_queue[__ptr__+SIZEOF_StgHeader+OFFSET_StgBlockingQueue_queue]
#define OFFSET_StgBlockingQueue_link 0
#define REP_StgBlockingQueue_link b64
#define StgBlockingQueue_link(__ptr__) REP_StgBlockingQueue_link[__ptr__+SIZEOF_StgHeader+OFFSET_StgBlockingQueue_link]
#define SIZEOF_MessageBlackHole_NoHdr 24
#define SIZEOF_MessageBlackHole (SIZEOF_StgHeader+24)
#define OFFSET_MessageBlackHole_link 0
#define REP_MessageBlackHole_link b64
#define MessageBlackHole_link(__ptr__) REP_MessageBlackHole_link[__ptr__+SIZEOF_StgHeader+OFFSET_MessageBlackHole_link]
#define OFFSET_MessageBlackHole_tso 8
#define REP_MessageBlackHole_tso b64
#define MessageBlackHole_tso(__ptr__) REP_MessageBlackHole_tso[__ptr__+SIZEOF_StgHeader+OFFSET_MessageBlackHole_tso]
#define OFFSET_MessageBlackHole_bh 16
#define REP_MessageBlackHole_bh b64
#define MessageBlackHole_bh(__ptr__) REP_MessageBlackHole_bh[__ptr__+SIZEOF_StgHeader+OFFSET_MessageBlackHole_bh]
#define OFFSET_RtsFlags_ProfFlags_showCCSOnException 280
#define REP_RtsFlags_ProfFlags_showCCSOnException b32
#define RtsFlags_ProfFlags_showCCSOnException(__ptr__) REP_RtsFlags_ProfFlags_showCCSOnException[__ptr__+OFFSET_RtsFlags_ProfFlags_showCCSOnException]
#define OFFSET_RtsFlags_DebugFlags_apply 224
#define REP_RtsFlags_DebugFlags_apply b32
#define RtsFlags_DebugFlags_apply(__ptr__) REP_RtsFlags_DebugFlags_apply[__ptr__+OFFSET_RtsFlags_DebugFlags_apply]
#define OFFSET_RtsFlags_DebugFlags_sanity 208
#define REP_RtsFlags_DebugFlags_sanity b32
#define RtsFlags_DebugFlags_sanity(__ptr__) REP_RtsFlags_DebugFlags_sanity[__ptr__+OFFSET_RtsFlags_DebugFlags_sanity]
#define OFFSET_RtsFlags_DebugFlags_weak 192
#define REP_RtsFlags_DebugFlags_weak b32
#define RtsFlags_DebugFlags_weak(__ptr__) REP_RtsFlags_DebugFlags_weak[__ptr__+OFFSET_RtsFlags_DebugFlags_weak]
#define OFFSET_RtsFlags_GcFlags_initialStkSize 16
#define REP_RtsFlags_GcFlags_initialStkSize b32
#define RtsFlags_GcFlags_initialStkSize(__ptr__) REP_RtsFlags_GcFlags_initialStkSize[__ptr__+OFFSET_RtsFlags_GcFlags_initialStkSize]
#define OFFSET_RtsFlags_MiscFlags_tickInterval 160
#define REP_RtsFlags_MiscFlags_tickInterval b64
#define RtsFlags_MiscFlags_tickInterval(__ptr__) REP_RtsFlags_MiscFlags_tickInterval[__ptr__+OFFSET_RtsFlags_MiscFlags_tickInterval]
#define SIZEOF_StgFunInfoExtraFwd 32
#define OFFSET_StgFunInfoExtraFwd_slow_apply 24
#define REP_StgFunInfoExtraFwd_slow_apply b64
#define StgFunInfoExtraFwd_slow_apply(__ptr__) REP_StgFunInfoExtraFwd_slow_apply[__ptr__+OFFSET_StgFunInfoExtraFwd_slow_apply]
#define OFFSET_StgFunInfoExtraFwd_fun_type 0
#define REP_StgFunInfoExtraFwd_fun_type b32
#define StgFunInfoExtraFwd_fun_type(__ptr__) REP_StgFunInfoExtraFwd_fun_type[__ptr__+OFFSET_StgFunInfoExtraFwd_fun_type]
#define OFFSET_StgFunInfoExtraFwd_arity 4
#define REP_StgFunInfoExtraFwd_arity b32
#define StgFunInfoExtraFwd_arity(__ptr__) REP_StgFunInfoExtraFwd_arity[__ptr__+OFFSET_StgFunInfoExtraFwd_arity]
#define OFFSET_StgFunInfoExtraFwd_bitmap 16
#define REP_StgFunInfoExtraFwd_bitmap b64
#define StgFunInfoExtraFwd_bitmap(__ptr__) REP_StgFunInfoExtraFwd_bitmap[__ptr__+OFFSET_StgFunInfoExtraFwd_bitmap]
#define SIZEOF_StgFunInfoExtraRev 32
#define OFFSET_StgFunInfoExtraRev_slow_apply_offset 0
#define REP_StgFunInfoExtraRev_slow_apply_offset b32
#define StgFunInfoExtraRev_slow_apply_offset(__ptr__) REP_StgFunInfoExtraRev_slow_apply_offset[__ptr__+OFFSET_StgFunInfoExtraRev_slow_apply_offset]
#define OFFSET_StgFunInfoExtraRev_fun_type 24
#define REP_StgFunInfoExtraRev_fun_type b32
#define StgFunInfoExtraRev_fun_type(__ptr__) REP_StgFunInfoExtraRev_fun_type[__ptr__+OFFSET_StgFunInfoExtraRev_fun_type]
#define OFFSET_StgFunInfoExtraRev_arity 28
#define REP_StgFunInfoExtraRev_arity b32
#define StgFunInfoExtraRev_arity(__ptr__) REP_StgFunInfoExtraRev_arity[__ptr__+OFFSET_StgFunInfoExtraRev_arity]
#define OFFSET_StgFunInfoExtraRev_bitmap 8
#define REP_StgFunInfoExtraRev_bitmap b64
#define StgFunInfoExtraRev_bitmap(__ptr__) REP_StgFunInfoExtraRev_bitmap[__ptr__+OFFSET_StgFunInfoExtraRev_bitmap]
#define OFFSET_StgLargeBitmap_size 0
#define REP_StgLargeBitmap_size b64
#define StgLargeBitmap_size(__ptr__) REP_StgLargeBitmap_size[__ptr__+OFFSET_StgLargeBitmap_size]
#define OFFSET_StgLargeBitmap_bitmap 8
#define SIZEOF_snEntry 24
#define OFFSET_snEntry_sn_obj 16
#define REP_snEntry_sn_obj b64
#define snEntry_sn_obj(__ptr__) REP_snEntry_sn_obj[__ptr__+OFFSET_snEntry_sn_obj]
#define OFFSET_snEntry_addr 0
#define REP_snEntry_addr b64
#define snEntry_addr(__ptr__) REP_snEntry_addr[__ptr__+OFFSET_snEntry_addr]
#define SIZEOF_spEntry 8
#define OFFSET_spEntry_addr 0
#define REP_spEntry_addr b64
#define spEntry_addr(__ptr__) REP_spEntry_addr[__ptr__+OFFSET_spEntry_addr]
{-# START_FILE include/ghc-7.10.2/ffi.h #-}
/* -----------------------------------------------------------------*-C-*-
   libffi 3.1 - Copyright (c) 2011 Anthony Green
                    - Copyright (c) 1996-2003, 2007, 2008 Red Hat, Inc.

   Permission is hereby granted, free of charge, to any person
   obtaining a copy of this software and associated documentation
   files (the ``Software''), to deal in the Software without
   restriction, including without limitation the rights to use, copy,
   modify, merge, publish, distribute, sublicense, and/or sell copies
   of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be
   included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   DEALINGS IN THE SOFTWARE.

   ----------------------------------------------------------------------- */

/* -------------------------------------------------------------------
   The basic API is described in the README file.

   The raw API is designed to bypass some of the argument packing
   and unpacking on architectures for which it can be avoided.

   The closure API allows interpreted functions to be packaged up
   inside a C function pointer, so that they can be called as C functions,
   with no understanding on the client side that they are interpreted.
   It can also be used in other cases in which it is necessary to package
   up a user specified parameter and a function pointer as a single
   function pointer.

   The closure API must be implemented in order to get its functionality,
   e.g. for use by gij.  Routines are provided to emulate the raw API
   if the underlying platform doesn't allow faster implementation.

   More details on the raw and cloure API can be found in:

   http://gcc.gnu.org/ml/java/1999-q3/msg00138.html

   and

   http://gcc.gnu.org/ml/java/1999-q3/msg00174.html
   -------------------------------------------------------------------- */

#ifndef LIBFFI_H
#define LIBFFI_H

#ifdef __cplusplus
extern "C" {
#endif

/* Specify which architecture libffi is configured for. */
#ifndef X86_DARWIN
#define X86_DARWIN
#endif

/* ---- System configuration information --------------------------------- */

#include <ffitarget.h>

#ifndef LIBFFI_ASM

#ifdef _MSC_VER
#define __attribute__(X)
#endif

#include <stddef.h>
#include <limits.h>

/* LONG_LONG_MAX is not always defined (not if STRICT_ANSI, for example).
   But we can find it either under the correct ANSI name, or under GNU
   C's internal name.  */

#define FFI_64_BIT_MAX 9223372036854775807

#ifdef LONG_LONG_MAX
# define FFI_LONG_LONG_MAX LONG_LONG_MAX
#else
# ifdef LLONG_MAX
#  define FFI_LONG_LONG_MAX LLONG_MAX
#  ifdef _AIX52 /* or newer has C99 LLONG_MAX */
#   undef FFI_64_BIT_MAX
#   define FFI_64_BIT_MAX 9223372036854775807LL
#  endif /* _AIX52 or newer */
# else
#  ifdef __GNUC__
#   define FFI_LONG_LONG_MAX __LONG_LONG_MAX__
#  endif
#  ifdef _AIX /* AIX 5.1 and earlier have LONGLONG_MAX */
#   ifndef __PPC64__
#    if defined (__IBMC__) || defined (__IBMCPP__)
#     define FFI_LONG_LONG_MAX LONGLONG_MAX
#    endif
#   endif /* __PPC64__ */
#   undef  FFI_64_BIT_MAX
#   define FFI_64_BIT_MAX 9223372036854775807LL
#  endif
# endif
#endif

/* The closure code assumes that this works on pointers, i.e. a size_t	*/
/* can hold a pointer.							*/

typedef struct _ffi_type
{
  size_t size;
  unsigned short alignment;
  unsigned short type;
  struct _ffi_type **elements;
} ffi_type;

#ifndef LIBFFI_HIDE_BASIC_TYPES
#if SCHAR_MAX == 127
# define ffi_type_uchar                ffi_type_uint8
# define ffi_type_schar                ffi_type_sint8
#else
 #error "char size not supported"
#endif

#if SHRT_MAX == 32767
# define ffi_type_ushort       ffi_type_uint16
# define ffi_type_sshort       ffi_type_sint16
#elif SHRT_MAX == 2147483647
# define ffi_type_ushort       ffi_type_uint32
# define ffi_type_sshort       ffi_type_sint32
#else
 #error "short size not supported"
#endif

#if INT_MAX == 32767
# define ffi_type_uint         ffi_type_uint16
# define ffi_type_sint         ffi_type_sint16
#elif INT_MAX == 2147483647
# define ffi_type_uint         ffi_type_uint32
# define ffi_type_sint         ffi_type_sint32
#elif INT_MAX == 9223372036854775807
# define ffi_type_uint         ffi_type_uint64
# define ffi_type_sint         ffi_type_sint64
#else
 #error "int size not supported"
#endif

#if LONG_MAX == 2147483647
# if FFI_LONG_LONG_MAX != FFI_64_BIT_MAX
 #error "no 64-bit data type supported"
# endif
#elif LONG_MAX != FFI_64_BIT_MAX
 #error "long size not supported"
#endif

#if LONG_MAX == 2147483647
# define ffi_type_ulong        ffi_type_uint32
# define ffi_type_slong        ffi_type_sint32
#elif LONG_MAX == FFI_64_BIT_MAX
# define ffi_type_ulong        ffi_type_uint64
# define ffi_type_slong        ffi_type_sint64
#else
 #error "long size not supported"
#endif

/* Need minimal decorations for DLLs to works on Windows. */
/* GCC has autoimport and autoexport.  Rely on Libtool to */
/* help MSVC export from a DLL, but always declare data   */
/* to be imported for MSVC clients.  This costs an extra  */
/* indirection for MSVC clients using the static version  */
/* of the library, but don't worry about that.  Besides,  */
/* as a workaround, they can define FFI_BUILDING if they  */
/* *know* they are going to link with the static library. */
#if defined _MSC_VER && !defined FFI_BUILDING
#define FFI_EXTERN extern __declspec(dllimport)
#else
#define FFI_EXTERN extern
#endif

/* These are defined in types.c */
FFI_EXTERN ffi_type ffi_type_void;
FFI_EXTERN ffi_type ffi_type_uint8;
FFI_EXTERN ffi_type ffi_type_sint8;
FFI_EXTERN ffi_type ffi_type_uint16;
FFI_EXTERN ffi_type ffi_type_sint16;
FFI_EXTERN ffi_type ffi_type_uint32;
FFI_EXTERN ffi_type ffi_type_sint32;
FFI_EXTERN ffi_type ffi_type_uint64;
FFI_EXTERN ffi_type ffi_type_sint64;
FFI_EXTERN ffi_type ffi_type_float;
FFI_EXTERN ffi_type ffi_type_double;
FFI_EXTERN ffi_type ffi_type_pointer;

#if 1
FFI_EXTERN ffi_type ffi_type_longdouble;
#else
#define ffi_type_longdouble ffi_type_double
#endif
#endif /* LIBFFI_HIDE_BASIC_TYPES */

typedef enum {
  FFI_OK = 0,
  FFI_BAD_TYPEDEF,
  FFI_BAD_ABI
} ffi_status;

typedef unsigned FFI_TYPE;

typedef struct {
  ffi_abi abi;
  unsigned nargs;
  ffi_type **arg_types;
  ffi_type *rtype;
  unsigned bytes;
  unsigned flags;
#ifdef FFI_EXTRA_CIF_FIELDS
  FFI_EXTRA_CIF_FIELDS;
#endif
} ffi_cif;

#if HAVE_LONG_DOUBLE_VARIANT
/* Used to adjust size/alignment of ffi types.  */
void ffi_prep_types (ffi_abi abi);
# endif

/* Used internally, but overridden by some architectures */
ffi_status ffi_prep_cif_core(ffi_cif *cif,
			     ffi_abi abi,
			     unsigned int isvariadic,
			     unsigned int nfixedargs,
			     unsigned int ntotalargs,
			     ffi_type *rtype,
			     ffi_type **atypes);

/* ---- Definitions for the raw API -------------------------------------- */

#ifndef FFI_SIZEOF_ARG
# if LONG_MAX == 2147483647
#  define FFI_SIZEOF_ARG        4
# elif LONG_MAX == FFI_64_BIT_MAX
#  define FFI_SIZEOF_ARG        8
# endif
#endif

#ifndef FFI_SIZEOF_JAVA_RAW
#  define FFI_SIZEOF_JAVA_RAW FFI_SIZEOF_ARG
#endif

typedef union {
  ffi_sarg  sint;
  ffi_arg   uint;
  float	    flt;
  char      data[FFI_SIZEOF_ARG];
  void*     ptr;
} ffi_raw;

#if FFI_SIZEOF_JAVA_RAW == 4 && FFI_SIZEOF_ARG == 8
/* This is a special case for mips64/n32 ABI (and perhaps others) where
   sizeof(void *) is 4 and FFI_SIZEOF_ARG is 8.  */
typedef union {
  signed int	sint;
  unsigned int	uint;
  float		flt;
  char		data[FFI_SIZEOF_JAVA_RAW];
  void*		ptr;
} ffi_java_raw;
#else
typedef ffi_raw ffi_java_raw;
#endif


void ffi_raw_call (ffi_cif *cif,
		   void (*fn)(void),
		   void *rvalue,
		   ffi_raw *avalue);

void ffi_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw);
void ffi_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args);
size_t ffi_raw_size (ffi_cif *cif);

/* This is analogous to the raw API, except it uses Java parameter	*/
/* packing, even on 64-bit machines.  I.e. on 64-bit machines		*/
/* longs and doubles are followed by an empty 64-bit word.		*/

void ffi_java_raw_call (ffi_cif *cif,
			void (*fn)(void),
			void *rvalue,
			ffi_java_raw *avalue);

void ffi_java_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_java_raw *raw);
void ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_java_raw *raw, void **args);
size_t ffi_java_raw_size (ffi_cif *cif);

/* ---- Definitions for closures ----------------------------------------- */

#if FFI_CLOSURES

#ifdef _MSC_VER
__declspec(align(8))
#endif
typedef struct {
#if 0
  void *trampoline_table;
  void *trampoline_table_entry;
#else
  char tramp[FFI_TRAMPOLINE_SIZE];
#endif
  ffi_cif   *cif;
  void     (*fun)(ffi_cif*,void*,void**,void*);
  void      *user_data;
#ifdef __GNUC__
} ffi_closure __attribute__((aligned (8)));
#else
} ffi_closure;
# ifdef __sgi
#  pragma pack 0
# endif
#endif

void *ffi_closure_alloc (size_t size, void **code);
void ffi_closure_free (void *);

ffi_status
ffi_prep_closure (ffi_closure*,
		  ffi_cif *,
		  void (*fun)(ffi_cif*,void*,void**,void*),
		  void *user_data);

ffi_status
ffi_prep_closure_loc (ffi_closure*,
		      ffi_cif *,
		      void (*fun)(ffi_cif*,void*,void**,void*),
		      void *user_data,
		      void*codeloc);

#ifdef __sgi
# pragma pack 8
#endif
typedef struct {
#if 0
  void *trampoline_table;
  void *trampoline_table_entry;
#else
  char tramp[FFI_TRAMPOLINE_SIZE];
#endif
  ffi_cif   *cif;

#if !FFI_NATIVE_RAW_API

  /* if this is enabled, then a raw closure has the same layout 
     as a regular closure.  We use this to install an intermediate 
     handler to do the transaltion, void** -> ffi_raw*. */

  void     (*translate_args)(ffi_cif*,void*,void**,void*);
  void      *this_closure;

#endif

  void     (*fun)(ffi_cif*,void*,ffi_raw*,void*);
  void      *user_data;

} ffi_raw_closure;

typedef struct {
#if 0
  void *trampoline_table;
  void *trampoline_table_entry;
#else
  char tramp[FFI_TRAMPOLINE_SIZE];
#endif

  ffi_cif   *cif;

#if !FFI_NATIVE_RAW_API

  /* if this is enabled, then a raw closure has the same layout 
     as a regular closure.  We use this to install an intermediate 
     handler to do the transaltion, void** -> ffi_raw*. */

  void     (*translate_args)(ffi_cif*,void*,void**,void*);
  void      *this_closure;

#endif

  void     (*fun)(ffi_cif*,void*,ffi_java_raw*,void*);
  void      *user_data;

} ffi_java_raw_closure;

ffi_status
ffi_prep_raw_closure (ffi_raw_closure*,
		      ffi_cif *cif,
		      void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
		      void *user_data);

ffi_status
ffi_prep_raw_closure_loc (ffi_raw_closure*,
			  ffi_cif *cif,
			  void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
			  void *user_data,
			  void *codeloc);

ffi_status
ffi_prep_java_raw_closure (ffi_java_raw_closure*,
		           ffi_cif *cif,
		           void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),
		           void *user_data);

ffi_status
ffi_prep_java_raw_closure_loc (ffi_java_raw_closure*,
			       ffi_cif *cif,
			       void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),
			       void *user_data,
			       void *codeloc);

#endif /* FFI_CLOSURES */

/* ---- Public interface definition -------------------------------------- */

ffi_status ffi_prep_cif(ffi_cif *cif,
			ffi_abi abi,
			unsigned int nargs,
			ffi_type *rtype,
			ffi_type **atypes);

ffi_status ffi_prep_cif_var(ffi_cif *cif,
			    ffi_abi abi,
			    unsigned int nfixedargs,
			    unsigned int ntotalargs,
			    ffi_type *rtype,
			    ffi_type **atypes);

void ffi_call(ffi_cif *cif,
	      void (*fn)(void),
	      void *rvalue,
	      void **avalue);

/* Useful for eliminating compiler warnings */
#define FFI_FN(f) ((void (*)(void))f)

/* ---- Definitions shared with assembly code ---------------------------- */

#endif

/* If these change, update src/mips/ffitarget.h. */
#define FFI_TYPE_VOID       0    
#define FFI_TYPE_INT        1
#define FFI_TYPE_FLOAT      2    
#define FFI_TYPE_DOUBLE     3
#if 1
#define FFI_TYPE_LONGDOUBLE 4
#else
#define FFI_TYPE_LONGDOUBLE FFI_TYPE_DOUBLE
#endif
#define FFI_TYPE_UINT8      5   
#define FFI_TYPE_SINT8      6
#define FFI_TYPE_UINT16     7 
#define FFI_TYPE_SINT16     8
#define FFI_TYPE_UINT32     9
#define FFI_TYPE_SINT32     10
#define FFI_TYPE_UINT64     11
#define FFI_TYPE_SINT64     12
#define FFI_TYPE_STRUCT     13
#define FFI_TYPE_POINTER    14

/* This should always refer to the last type code (for sanity checks) */
#define FFI_TYPE_LAST       FFI_TYPE_POINTER

#ifdef __cplusplus
}
#endif

#endif
{-# START_FILE include/ghc-7.10.2/ffitarget.h #-}
/* -----------------------------------------------------------------*-C-*-
   ffitarget.h - Copyright (c) 2012  Anthony Green
                 Copyright (c) 1996-2003, 2010  Red Hat, Inc.
                 Copyright (C) 2008  Free Software Foundation, Inc.

   Target configuration macros for x86 and x86-64.

   Permission is hereby granted, free of charge, to any person obtaining
   a copy of this software and associated documentation files (the
   ``Software''), to deal in the Software without restriction, including
   without limitation the rights to use, copy, modify, merge, publish,
   distribute, sublicense, and/or sell copies of the Software, and to
   permit persons to whom the Software is furnished to do so, subject to
   the following conditions:

   The above copyright notice and this permission notice shall be included
   in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   DEALINGS IN THE SOFTWARE.

   ----------------------------------------------------------------------- */

#ifndef LIBFFI_TARGET_H
#define LIBFFI_TARGET_H

#ifndef LIBFFI_H
#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
#endif

/* ---- System specific configurations ----------------------------------- */

/* For code common to all platforms on x86 and x86_64. */
#define X86_ANY

#if defined (X86_64) && defined (__i386__)
#undef X86_64
#define X86
#endif

#ifdef X86_WIN64
#define FFI_SIZEOF_ARG 8
#define USE_BUILTIN_FFS 0 /* not yet implemented in mingw-64 */
#endif

/* ---- Generic type definitions ----------------------------------------- */

#ifndef LIBFFI_ASM
#ifdef X86_WIN64
#ifdef _MSC_VER
typedef unsigned __int64       ffi_arg;
typedef __int64                ffi_sarg;
#else
typedef unsigned long long     ffi_arg;
typedef long long              ffi_sarg;
#endif
#else
#if defined __x86_64__ && defined __ILP32__
#define FFI_SIZEOF_ARG 8
#define FFI_SIZEOF_JAVA_RAW  4
typedef unsigned long long     ffi_arg;
typedef long long              ffi_sarg;
#else
typedef unsigned long          ffi_arg;
typedef signed long            ffi_sarg;
#endif
#endif

typedef enum ffi_abi {
  FFI_FIRST_ABI = 0,

  /* ---- Intel x86 Win32 ---------- */
#ifdef X86_WIN32
  FFI_SYSV,
  FFI_STDCALL,
  FFI_THISCALL,
  FFI_FASTCALL,
  FFI_MS_CDECL,
  FFI_LAST_ABI,
#ifdef _MSC_VER
  FFI_DEFAULT_ABI = FFI_MS_CDECL
#else
  FFI_DEFAULT_ABI = FFI_SYSV
#endif

#elif defined(X86_WIN64)
  FFI_WIN64,
  FFI_LAST_ABI,
  FFI_DEFAULT_ABI = FFI_WIN64

#else
  /* ---- Intel x86 and AMD x86-64 - */
  FFI_SYSV,
  FFI_UNIX64,   /* Unix variants all use the same ABI for x86-64  */
  FFI_THISCALL,
  FFI_FASTCALL,
  FFI_STDCALL,
  FFI_LAST_ABI,
#if defined(__i386__) || defined(__i386)
  FFI_DEFAULT_ABI = FFI_SYSV
#else
  FFI_DEFAULT_ABI = FFI_UNIX64
#endif
#endif
} ffi_abi;
#endif

/* ---- Definitions for closures ----------------------------------------- */

#define FFI_CLOSURES 1
#define FFI_TYPE_SMALL_STRUCT_1B (FFI_TYPE_LAST + 1)
#define FFI_TYPE_SMALL_STRUCT_2B (FFI_TYPE_LAST + 2)
#define FFI_TYPE_SMALL_STRUCT_4B (FFI_TYPE_LAST + 3)
#define FFI_TYPE_MS_STRUCT       (FFI_TYPE_LAST + 4)

#if defined (X86_64) || (defined (__x86_64__) && defined (X86_DARWIN))
#define FFI_TRAMPOLINE_SIZE 24
#define FFI_NATIVE_RAW_API 0
#else
#ifdef X86_WIN32
#define FFI_TRAMPOLINE_SIZE 52
#else
#ifdef X86_WIN64
#define FFI_TRAMPOLINE_SIZE 29
#define FFI_NATIVE_RAW_API 0
#define FFI_NO_RAW_API 1
#else
#define FFI_TRAMPOLINE_SIZE 10
#endif
#endif
#ifndef X86_WIN64
#define FFI_NATIVE_RAW_API 1	/* x86 has native raw api support */
#endif
#endif

#endif

{-# START_FILE include/ghc-7.10.2/ghcautoconf.h #-}
#ifndef __GHCAUTOCONF_H__
#define __GHCAUTOCONF_H__
/* mk/config.h.  Generated from config.h.in by configure.  */
/* mk/config.h.in.  Generated from configure.ac by autoheader.  */

/* Define if building universal (internal helper macro) */
/* #undef AC_APPLE_UNIVERSAL_BUILD */

/* The alignment of a `char'. */
#define ALIGNMENT_CHAR 1

/* The alignment of a `double'. */
#define ALIGNMENT_DOUBLE 8

/* The alignment of a `float'. */
#define ALIGNMENT_FLOAT 4

/* The alignment of a `int'. */
#define ALIGNMENT_INT 4

/* The alignment of a `long'. */
#define ALIGNMENT_LONG 8

/* The alignment of a `long long'. */
#define ALIGNMENT_LONG_LONG 8

/* The alignment of a `short'. */
#define ALIGNMENT_SHORT 2

/* The alignment of a `unsigned char'. */
#define ALIGNMENT_UNSIGNED_CHAR 1

/* The alignment of a `unsigned int'. */
#define ALIGNMENT_UNSIGNED_INT 4

/* The alignment of a `unsigned long'. */
#define ALIGNMENT_UNSIGNED_LONG 8

/* The alignment of a `unsigned long long'. */
#define ALIGNMENT_UNSIGNED_LONG_LONG 8

/* The alignment of a `unsigned short'. */
#define ALIGNMENT_UNSIGNED_SHORT 2

/* The alignment of a `void *'. */
#define ALIGNMENT_VOID_P 8

/* Define to 1 if __thread is supported */
#define CC_SUPPORTS_TLS 0

/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
   systems. This function is required for `alloca.c' support on those systems.
   */
/* #undef CRAY_STACKSEG_END */

/* Define to 1 if using `alloca.c'. */
/* #undef C_ALLOCA */

/* Define to 1 if your processor stores words of floats with the most
   significant byte first */
/* #undef FLOAT_WORDS_BIGENDIAN */

/* Has visibility hidden */
#define HAS_VISIBILITY_HIDDEN 1

/* Define to 1 if you have `alloca', as a function or macro. */
#define HAVE_ALLOCA 1

/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
   */
#define HAVE_ALLOCA_H 1

/* Define to 1 if you have the <bfd.h> header file. */
/* #undef HAVE_BFD_H */

/* Define to 1 if you have the `clock_gettime' function. */
/* #undef HAVE_CLOCK_GETTIME */

/* Define to 1 if you have the `ctime_r' function. */
#define HAVE_CTIME_R 1

/* Define to 1 if you have the <ctype.h> header file. */
#define HAVE_CTYPE_H 1

/* Define to 1 if you have the declaration of `ctime_r', and to 0 if you
   don't. */
#define HAVE_DECL_CTIME_R 1

/* Define to 1 if you have the <dirent.h> header file. */
#define HAVE_DIRENT_H 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the `eventfd' function. */
/* #undef HAVE_EVENTFD */

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the <ffi.h> header file. */
/* #undef HAVE_FFI_H */

/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1

/* Define to 1 if you have the `getclock' function. */
/* #undef HAVE_GETCLOCK */

/* Define to 1 if you have the `GetModuleFileName' function. */
/* #undef HAVE_GETMODULEFILENAME */

/* Define to 1 if you have the `getrusage' function. */
#define HAVE_GETRUSAGE 1

/* Define to 1 if you have the `gettimeofday' function. */
#define HAVE_GETTIMEOFDAY 1

/* Define to 1 if you have the <grp.h> header file. */
#define HAVE_GRP_H 1

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the `bfd' library (-lbfd). */
/* #undef HAVE_LIBBFD */

/* Define to 1 if you have the `dl' library (-ldl). */
#define HAVE_LIBDL 1

/* Define to 1 if you have libffi. */
/* #undef HAVE_LIBFFI */

/* Define to 1 if you have the `iberty' library (-liberty). */
/* #undef HAVE_LIBIBERTY */

/* Define to 1 if you need to link with libm */
#define HAVE_LIBM 1

/* Define to 1 if you have the `pthread' library (-lpthread). */
#define HAVE_LIBPTHREAD 1

/* Define to 1 if you have the `rt' library (-lrt). */
/* #undef HAVE_LIBRT */

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if the system has the type `long long'. */
#define HAVE_LONG_LONG 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the mingwex library. */
/* #undef HAVE_MINGWEX */

/* Define to 1 if you have the <nlist.h> header file. */
#define HAVE_NLIST_H 1

/* Define to 1 if we have printf$LDBLStub (Apple Mac OS >= 10.4, PPC). */
#define HAVE_PRINTF_LDBLSTUB 0

/* Define to 1 if you have the <pthread.h> header file. */
#define HAVE_PTHREAD_H 1

/* Define to 1 if you have the glibc version of pthread_setname_np */
/* #undef HAVE_PTHREAD_SETNAME_NP */

/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1

/* Define to 1 if you have the <sched.h> header file. */
#define HAVE_SCHED_H 1

/* Define to 1 if you have the `sched_setaffinity' function. */
/* #undef HAVE_SCHED_SETAFFINITY */

/* Define to 1 if you have the `setitimer' function. */
#define HAVE_SETITIMER 1

/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1

/* Define to 1 if you have the `siginterrupt' function. */
#define HAVE_SIGINTERRUPT 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if Apple-style dead-stripping is supported. */
#define HAVE_SUBSECTIONS_VIA_SYMBOLS 1

/* Define to 1 if you have the `sysconf' function. */
#define HAVE_SYSCONF 1

/* Define to 1 if you have the <sys/cpuset.h> header file. */
/* #undef HAVE_SYS_CPUSET_H */

/* Define to 1 if you have the <sys/eventfd.h> header file. */
/* #undef HAVE_SYS_EVENTFD_H */

/* Define to 1 if you have the <sys/mman.h> header file. */
#define HAVE_SYS_MMAN_H 1

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/resource.h> header file. */
#define HAVE_SYS_RESOURCE_H 1

/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/timeb.h> header file. */
#define HAVE_SYS_TIMEB_H 1

/* Define to 1 if you have the <sys/timers.h> header file. */
/* #undef HAVE_SYS_TIMERS_H */

/* Define to 1 if you have the <sys/times.h> header file. */
#define HAVE_SYS_TIMES_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the <sys/wait.h> header file. */
#define HAVE_SYS_WAIT_H 1

/* Define to 1 if you have the <termios.h> header file. */
#define HAVE_TERMIOS_H 1

/* Define to 1 if you have the `timer_settime' function. */
/* #undef HAVE_TIMER_SETTIME */

/* Define to 1 if you have the `times' function. */
#define HAVE_TIMES 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1

/* Define to 1 if you have the `vfork' function. */
#define HAVE_VFORK 1

/* Define to 1 if you have the <vfork.h> header file. */
/* #undef HAVE_VFORK_H */

/* Define to 1 if you have the <windows.h> header file. */
/* #undef HAVE_WINDOWS_H */

/* Define to 1 if you have the `WinExec' function. */
/* #undef HAVE_WINEXEC */

/* Define to 1 if you have the <winsock.h> header file. */
/* #undef HAVE_WINSOCK_H */

/* Define to 1 if `fork' works. */
#define HAVE_WORKING_FORK 1

/* Define to 1 if `vfork' works. */
#define HAVE_WORKING_VFORK 1

/* Define to 1 if you have the `__mingw_vfprintf' function. */
/* #undef HAVE___MINGW_VFPRINTF */

/* Define to 1 if C symbols have a leading underscore added by the compiler.
   */
#define LEADING_UNDERSCORE 1

/* Define to the address where bug reports for this package should be sent. */
/* #undef PACKAGE_BUGREPORT */

/* Define to the full name of this package. */
/* #undef PACKAGE_NAME */

/* Define to the full name and version of this package. */
/* #undef PACKAGE_STRING */

/* Define to the one symbol short name of this package. */
/* #undef PACKAGE_TARNAME */

/* Define to the home page for this package. */
/* #undef PACKAGE_URL */

/* Define to the version of this package. */
/* #undef PACKAGE_VERSION */

/* The size of `char', as computed by sizeof. */
#define SIZEOF_CHAR 1

/* The size of `double', as computed by sizeof. */
#define SIZEOF_DOUBLE 8

/* The size of `float', as computed by sizeof. */
#define SIZEOF_FLOAT 4

/* The size of `int', as computed by sizeof. */
#define SIZEOF_INT 4

/* The size of `long', as computed by sizeof. */
#define SIZEOF_LONG 8

/* The size of `long long', as computed by sizeof. */
#define SIZEOF_LONG_LONG 8

/* The size of `short', as computed by sizeof. */
#define SIZEOF_SHORT 2

/* The size of `unsigned char', as computed by sizeof. */
#define SIZEOF_UNSIGNED_CHAR 1

/* The size of `unsigned int', as computed by sizeof. */
#define SIZEOF_UNSIGNED_INT 4

/* The size of `unsigned long', as computed by sizeof. */
#define SIZEOF_UNSIGNED_LONG 8

/* The size of `unsigned long long', as computed by sizeof. */
#define SIZEOF_UNSIGNED_LONG_LONG 8

/* The size of `unsigned short', as computed by sizeof. */
#define SIZEOF_UNSIGNED_SHORT 2

/* The size of `void *', as computed by sizeof. */
#define SIZEOF_VOID_P 8

/* If using the C implementation of alloca, define if you know the
   direction of stack growth for your system; otherwise it will be
   automatically deduced at runtime.
	STACK_DIRECTION > 0 => grows toward higher addresses
	STACK_DIRECTION < 0 => grows toward lower addresses
	STACK_DIRECTION = 0 => direction of growth unknown */
/* #undef STACK_DIRECTION */

/* Define to 1 if you have the ANSI C header files. */
#define STDC_HEADERS 1

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/* Define to 1 if we can use timer_create(CLOCK_PROCESS_CPUTIME_ID,...) */
/* #undef USE_TIMER_CREATE */

/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
   significant byte first (like Motorola and SPARC, unlike Intel). */
#if defined AC_APPLE_UNIVERSAL_BUILD
# if defined __BIG_ENDIAN__
#  define WORDS_BIGENDIAN 1
# endif
#else
# ifndef WORDS_BIGENDIAN
/* #  undef WORDS_BIGENDIAN */
# endif
#endif

/* Enable large inode numbers on Mac OS X 10.5.  */
#ifndef _DARWIN_USE_64_BIT_INODE
# define _DARWIN_USE_64_BIT_INODE 1
#endif

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* ARM pre v6 */
/* #undef arm_HOST_ARCH_PRE_ARMv6 */

/* ARM pre v7 */
/* #undef arm_HOST_ARCH_PRE_ARMv7 */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef pid_t */

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define as `fork' if `vfork' does not work. */
/* #undef vfork */

#define TABLES_NEXT_TO_CODE 1

#define llvm_CC_FLAVOR 1

#define clang_CC_FLAVOR 1
#endif /* __GHCAUTOCONF_H__ */
{-# START_FILE include/ghc-7.10.2/ghcconfig.h #-}
#ifndef __GHCCONFIG_H__
#define __GHCCONFIG_H__

#include "ghcautoconf.h"
#include "ghcplatform.h"

#endif
{-# START_FILE include/ghc-7.10.2/ghcplatform.h #-}
#ifndef __GHCPLATFORM_H__
#define __GHCPLATFORM_H__

#define BuildPlatform_TYPE  x86_64_apple_darwin
#define HostPlatform_TYPE   x86_64_apple_darwin

#define x86_64_apple_darwin_BUILD  1
#define x86_64_apple_darwin_HOST  1

#define x86_64_BUILD_ARCH  1
#define x86_64_HOST_ARCH  1
#define BUILD_ARCH  "x86_64"
#define HOST_ARCH  "x86_64"

#define darwin_BUILD_OS  1
#define darwin_HOST_OS  1
#define BUILD_OS  "darwin"
#define HOST_OS  "darwin"

#define apple_BUILD_VENDOR  1
#define apple_HOST_VENDOR  1
#define BUILD_VENDOR  "apple"
#define HOST_VENDOR  "apple"

/* These TARGET macros are for backwards compatibility... DO NOT USE! */
#define TargetPlatform_TYPE x86_64_apple_darwin
#define x86_64_apple_darwin_TARGET  1
#define x86_64_TARGET_ARCH  1
#define TARGET_ARCH  "x86_64"
#define darwin_TARGET_OS  1
#define TARGET_OS  "darwin"
#define apple_TARGET_VENDOR  1

#endif /* __GHCPLATFORM_H__ */
{-# START_FILE include/ghc-7.10.2/ghcversion.h #-}
#ifndef __GHCVERSION_H__
#define __GHCVERSION_H__

#ifndef __GLASGOW_HASKELL__
# define __GLASGOW_HASKELL__ 710
#endif

#define __GLASGOW_HASKELL_PATCHLEVEL1__ 2

#define MIN_VERSION_GLASGOW_HASKELL(ma,mi,pl1,pl2) (\
   ((ma)*100+(mi)) <  __GLASGOW_HASKELL__ || \
   ((ma)*100+(mi)) == __GLASGOW_HASKELL__    \
          && (pl1) <  __GLASGOW_HASKELL_PATCHLEVEL1__ || \
   ((ma)*100+(mi)) == __GLASGOW_HASKELL__    \
          && (pl1) == __GLASGOW_HASKELL_PATCHLEVEL1__ \
          && (pl2) <= __GLASGOW_HASKELL_PATCHLEVEL2__ )

#endif /* __GHCVERSION_H__ */
{-# START_FILE include/ghc-7.10.2/HsFFI.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2000
 *
 * A mapping for Haskell types to C types, including the corresponding bounds.
 * Intended to be used in conjuction with the FFI.
 *
 * WARNING: Keep this file and StgTypes.h in synch!
 *
 * ---------------------------------------------------------------------------*/

#ifndef HSFFI_H
#define HSFFI_H

#ifdef __cplusplus
extern "C" {
#endif

/* get types from GHC's runtime system */
#include "ghcconfig.h"
#include "stg/Types.h"

/* get limits for integral types */
#if defined HAVE_STDINT_H && !defined USE_INTTYPES_H_FOR_RTS_PROBES_D
/* ISO C 99 says:
 * "C++ implementations should define these macros only when
 * __STDC_LIMIT_MACROS is defined before <stdint.h> is included."
 */
#define __STDC_LIMIT_MACROS
#include <stdint.h>
#elif defined(HAVE_INTTYPES_H)
#include <inttypes.h>
#else
/* second best guess (e.g. on Solaris) */
#include <limits.h>
#endif

#ifdef INT8_MIN
#define __INT8_MIN              INT8_MIN
#define __INT16_MIN             INT16_MIN
#define __INT32_MIN             INT32_MIN
#define __INT64_MIN             INT64_MIN
#define __INT8_MAX              INT8_MAX
#define __INT16_MAX             INT16_MAX
#define __INT32_MAX             INT32_MAX
#define __INT64_MAX             INT64_MAX
#define __UINT8_MAX             UINT8_MAX
#define __UINT16_MAX            UINT16_MAX
#define __UINT32_MAX            UINT32_MAX
#define __UINT64_MAX            UINT64_MAX
#else
/* if we had no luck, let's do it for ourselves (assuming 64bit long longs) */
#define __INT8_MIN              (-128)
#define __INT16_MIN             (-32767-1)
#define __INT32_MIN             (-2147483647-1)
#define __INT64_MIN             (-9223372036854775807LL-1)
#define __INT8_MAX              (127)
#define __INT16_MAX             (32767)
#define __INT32_MAX             (2147483647)
#define __INT64_MAX             (9223372036854775807LL)
#define __UINT8_MAX             (255U)
#define __UINT16_MAX            (65535U)
#define __UINT32_MAX            (4294967295U)
#define __UINT64_MAX            (18446744073709551615ULL)
#endif

/* get limits for floating point types */
#include <float.h>

typedef StgChar                 HsChar;
typedef StgInt                  HsInt;
typedef StgInt8                 HsInt8;
typedef StgInt16                HsInt16;
typedef StgInt32                HsInt32;
typedef StgInt64                HsInt64;
typedef StgWord                 HsWord;
typedef StgWord8                HsWord8;
typedef StgWord16               HsWord16;
typedef StgWord32               HsWord32;
typedef StgWord64               HsWord64;
typedef StgFloat                HsFloat;
typedef StgDouble               HsDouble;
typedef StgInt                  HsBool;
typedef void*                   HsPtr;          /* this should better match StgAddr */
typedef void                    (*HsFunPtr)(void); /* this should better match StgAddr */
typedef void*                   HsStablePtr;

/* this should correspond to the type of StgChar in StgTypes.h */
#define HS_CHAR_MIN             0
#define HS_CHAR_MAX             0x10FFFF

/* is it true or not?  */
#define HS_BOOL_FALSE           0
#define HS_BOOL_TRUE            1

#define HS_BOOL_MIN             HS_BOOL_FALSE
#define HS_BOOL_MAX             HS_BOOL_TRUE

/* this mirrors the distinction of cases in StgTypes.h */
#if   SIZEOF_VOID_P == 8
#define HS_INT_MIN              __INT64_MIN
#define HS_INT_MAX              __INT64_MAX
#define HS_WORD_MAX             __UINT64_MAX
#elif SIZEOF_VOID_P == 4
#define HS_INT_MIN              __INT32_MIN
#define HS_INT_MAX              __INT32_MAX
#define HS_WORD_MAX             __UINT32_MAX
#else
#error GHC untested on this architecture: sizeof(void *) != 4 or 8
#endif

#define HS_INT8_MIN             __INT8_MIN
#define HS_INT8_MAX             __INT8_MAX
#define HS_INT16_MIN            __INT16_MIN
#define HS_INT16_MAX            __INT16_MAX
#define HS_INT32_MIN            __INT32_MIN
#define HS_INT32_MAX            __INT32_MAX
#define HS_INT64_MIN            __INT64_MIN
#define HS_INT64_MAX            __INT64_MAX
#define HS_WORD8_MAX            __UINT8_MAX
#define HS_WORD16_MAX           __UINT16_MAX
#define HS_WORD32_MAX           __UINT32_MAX
#define HS_WORD64_MAX           __UINT64_MAX

#define HS_FLOAT_RADIX          FLT_RADIX
#define HS_FLOAT_ROUNDS         FLT_ROUNDS
#define HS_FLOAT_EPSILON        FLT_EPSILON
#define HS_FLOAT_DIG            FLT_DIG
#define HS_FLOAT_MANT_DIG       FLT_MANT_DIG
#define HS_FLOAT_MIN            FLT_MIN
#define HS_FLOAT_MIN_EXP        FLT_MIN_EXP
#define HS_FLOAT_MIN_10_EXP     FLT_MIN_10_EXP
#define HS_FLOAT_MAX            FLT_MAX
#define HS_FLOAT_MAX_EXP        FLT_MAX_EXP
#define HS_FLOAT_MAX_10_EXP     FLT_MAX_10_EXP

#define HS_DOUBLE_RADIX         DBL_RADIX
#define HS_DOUBLE_ROUNDS        DBL_ROUNDS
#define HS_DOUBLE_EPSILON       DBL_EPSILON
#define HS_DOUBLE_DIG           DBL_DIG
#define HS_DOUBLE_MANT_DIG      DBL_MANT_DIG
#define HS_DOUBLE_MIN           DBL_MIN
#define HS_DOUBLE_MIN_EXP       DBL_MIN_EXP
#define HS_DOUBLE_MIN_10_EXP    DBL_MIN_10_EXP
#define HS_DOUBLE_MAX           DBL_MAX
#define HS_DOUBLE_MAX_EXP       DBL_MAX_EXP
#define HS_DOUBLE_MAX_10_EXP    DBL_MAX_10_EXP

extern void hs_init     (int *argc, char **argv[]);
extern void hs_exit     (void);
extern void hs_set_argv (int argc, char *argv[]);
extern void hs_add_root (void (*init_root)(void));
extern void hs_thread_done (void);

extern void hs_perform_gc (void);

extern void hs_lock_stable_tables (void);
extern void hs_unlock_stable_tables (void);
extern void hs_free_stable_ptr_unsafe (HsStablePtr sp);

extern void hs_free_stable_ptr (HsStablePtr sp);
extern void hs_free_fun_ptr    (HsFunPtr fp);

extern StgPtr hs_spt_lookup(StgWord64 key[2]);
extern int hs_spt_keys(StgPtr keys[], int szKeys);
extern int hs_spt_key_count (void);

/* -------------------------------------------------------------------------- */

#ifdef __cplusplus
}
#endif

#endif /* HSFFI_H */
{-# START_FILE include/ghc-7.10.2/MachDeps.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The University of Glasgow 2002
 * 
 * Definitions that characterise machine specific properties of basic
 * types (C & Haskell).
 *
 * NB: Keep in sync with HsFFI.h and StgTypes.h.
 * NB: THIS FILE IS INCLUDED IN HASKELL SOURCE!
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef MACHDEPS_H
#define MACHDEPS_H

/* Sizes of C types come from here... */
#include "ghcautoconf.h"

/* Sizes of Haskell types follow.  These sizes correspond to:
 *   - the number of bytes in the primitive type (eg. Int#)
 *   - the number of bytes in the external representation (eg. HsInt)
 *   - the scale offset used by writeFooOffAddr#
 *
 * In the heap, the type may take up more space: eg. SIZEOF_INT8 == 1,
 * but it takes up SIZEOF_HSWORD (4 or 8) bytes in the heap.
 */

/* First, check some assumptions.. */
#if SIZEOF_CHAR != 1
#error GHC untested on this architecture: sizeof(char) != 1
#endif

#if SIZEOF_SHORT != 2
#error GHC untested on this architecture: sizeof(short) != 2
#endif

#if SIZEOF_UNSIGNED_INT != 4
#error GHC untested on this architecture: sizeof(unsigned int) != 4
#endif

#define SIZEOF_HSCHAR           SIZEOF_WORD32
#define ALIGNMENT_HSCHAR        ALIGNMENT_WORD32

#define SIZEOF_HSINT            SIZEOF_VOID_P
#define ALIGNMENT_HSINT         ALIGNMENT_VOID_P

#define SIZEOF_HSWORD           SIZEOF_VOID_P
#define ALIGNMENT_HSWORD        ALIGNMENT_VOID_P

#define SIZEOF_HSDOUBLE         SIZEOF_DOUBLE
#define ALIGNMENT_HSDOUBLE      ALIGNMENT_DOUBLE

#define SIZEOF_HSFLOAT          SIZEOF_FLOAT
#define ALIGNMENT_HSFLOAT       ALIGNMENT_FLOAT

#define SIZEOF_HSPTR            SIZEOF_VOID_P
#define ALIGNMENT_HSPTR         ALIGNMENT_VOID_P

#define SIZEOF_HSFUNPTR         SIZEOF_VOID_P
#define ALIGNMENT_HSFUNPTR      ALIGNMENT_VOID_P

#define SIZEOF_HSSTABLEPTR      SIZEOF_VOID_P
#define ALIGNMENT_HSSTABLEPTR   ALIGNMENT_VOID_P

#define SIZEOF_INT8             SIZEOF_CHAR
#define ALIGNMENT_INT8          ALIGNMENT_CHAR

#define SIZEOF_WORD8            SIZEOF_UNSIGNED_CHAR
#define ALIGNMENT_WORD8         ALIGNMENT_UNSIGNED_CHAR

#define SIZEOF_INT16            SIZEOF_SHORT
#define ALIGNMENT_INT16         ALIGNMENT_SHORT

#define SIZEOF_WORD16           SIZEOF_UNSIGNED_SHORT
#define ALIGNMENT_WORD16        ALIGNMENT_UNSIGNED_SHORT

#define SIZEOF_INT32            SIZEOF_INT
#define ALIGNMENT_INT32         ALIGNMENT_INT

#define SIZEOF_WORD32           SIZEOF_UNSIGNED_INT
#define ALIGNMENT_WORD32        ALIGNMENT_UNSIGNED_INT

#if SIZEOF_LONG == 8
#define SIZEOF_INT64            SIZEOF_LONG
#define ALIGNMENT_INT64         ALIGNMENT_LONG
#define SIZEOF_WORD64           SIZEOF_UNSIGNED_LONG
#define ALIGNMENT_WORD64        ALIGNMENT_UNSIGNED_LONG
#elif HAVE_LONG_LONG && SIZEOF_LONG_LONG == 8
#define SIZEOF_INT64            SIZEOF_LONG_LONG
#define ALIGNMENT_INT64         ALIGNMENT_LONG_LONG
#define SIZEOF_WORD64           SIZEOF_UNSIGNED_LONG_LONG
#define ALIGNMENT_WORD64        ALIGNMENT_UNSIGNED_LONG_LONG
#else
#error Cannot find a 64bit type.
#endif

#ifndef WORD_SIZE_IN_BITS
#if SIZEOF_HSWORD == 4
#define WORD_SIZE_IN_BITS       32
#define WORD_SIZE_IN_BITS_FLOAT 32.0
#else 
#define WORD_SIZE_IN_BITS       64
#define WORD_SIZE_IN_BITS_FLOAT 64.0
#endif
#endif

#ifndef TAG_BITS
#if SIZEOF_HSWORD == 4
#define TAG_BITS                2
#else 
#define TAG_BITS                3
#endif
#endif

#define TAG_MASK ((1 << TAG_BITS) - 1)

#endif /* MACHDEPS_H */
{-# START_FILE include/ghc-7.10.2/rts/Adjustor.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * Adjustor API
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_ADJUSTOR_H
#define RTS_ADJUSTOR_H

/* Creating and destroying an adjustor thunk */
void* createAdjustor (int cconv, 
                      StgStablePtr hptr,
                      StgFunPtr wptr,
                      char *typeString);

void freeHaskellFunctionPtr (void* ptr);

#endif /* RTS_ADJUSTOR_H */
{-# START_FILE include/ghc-7.10.2/rts/BlockSignals.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * RTS signal handling 
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_BLOCKSIGNALS_H
#define RTS_BLOCKSIGNALS_H

/* Used by runProcess() in the process package
 */

/*
 * Function: blockUserSignals()
 *
 * Temporarily block the delivery of further console events. Needed to
 * avoid race conditions when GCing the queue of outstanding handlers or
 * when emptying the queue by running the handlers.
 * 
 */
void blockUserSignals(void);

/*
 * Function: unblockUserSignals()
 *
 * The inverse of blockUserSignals(); re-enable the deliver of console events.
 */
void unblockUserSignals(void);

#endif /* RTS_BLOCKSIGNALS_H */
{-# START_FILE include/ghc-7.10.2/rts/Bytecodes.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * Bytecode definitions.
 *
 * ---------------------------------------------------------------------------*/

/* --------------------------------------------------------------------------
 * Instructions
 *
 * Notes:
 * o CASEFAIL is generated by the compiler whenever it tests an "irrefutable"
 *   pattern which fails.  If we don't see too many of these, we could
 *   optimise out the redundant test.
 * ------------------------------------------------------------------------*/

/* NOTE:

   THIS FILE IS INCLUDED IN HASKELL SOURCES (ghc/compiler/ghci/ByteCodeGen.lhs).
   DO NOT PUT C-SPECIFIC STUFF IN HERE!

   I hope that's clear :-)
*/

#define bci_STKCHECK  			1
#define bci_PUSH_L    			2
#define bci_PUSH_LL   			3
#define bci_PUSH_LLL  			4
#define bci_PUSH_G    			5
#define bci_PUSH_ALTS  			6
#define bci_PUSH_ALTS_P			7
#define bci_PUSH_ALTS_N			8 
#define bci_PUSH_ALTS_F			9 
#define bci_PUSH_ALTS_D			10
#define bci_PUSH_ALTS_L			11
#define bci_PUSH_ALTS_V			12
#define bci_PUSH_UBX  			13
#define bci_PUSH_APPLY_N		14
#define bci_PUSH_APPLY_F		15
#define bci_PUSH_APPLY_D		16
#define bci_PUSH_APPLY_L		17
#define bci_PUSH_APPLY_V		18
#define bci_PUSH_APPLY_P		19
#define bci_PUSH_APPLY_PP		20
#define bci_PUSH_APPLY_PPP		21
#define bci_PUSH_APPLY_PPPP		22
#define bci_PUSH_APPLY_PPPPP		23
#define bci_PUSH_APPLY_PPPPPP		24
/* #define bci_PUSH_APPLY_PPPPPPP		25 */
#define bci_SLIDE     			26
#define bci_ALLOC_AP   			27
#define bci_ALLOC_AP_NOUPD		28
#define bci_ALLOC_PAP  			29
#define bci_MKAP      			30
#define bci_MKPAP      			31
#define bci_UNPACK    			32
#define bci_PACK      			33
#define bci_TESTLT_I   			34
#define bci_TESTEQ_I  			35
#define bci_TESTLT_F  			36
#define bci_TESTEQ_F  			37
#define bci_TESTLT_D  			38
#define bci_TESTEQ_D  			39
#define bci_TESTLT_P  			40
#define bci_TESTEQ_P  			41
#define bci_CASEFAIL  			42
#define bci_JMP       			43
#define bci_CCALL     			44
#define bci_SWIZZLE   			45
#define bci_ENTER     			46
#define bci_RETURN    			47
#define bci_RETURN_P 			48
#define bci_RETURN_N 			49
#define bci_RETURN_F 			50
#define bci_RETURN_D 			51
#define bci_RETURN_L 			52
#define bci_RETURN_V 			53
#define bci_BRK_FUN			54
#define bci_TESTLT_W   			55
#define bci_TESTEQ_W  			56
/* If you need to go past 255 then you will run into the flags */

/* If you need to go below 0x0100 then you will run into the instructions */
#define bci_FLAG_LARGE_ARGS     0x8000

/* If a BCO definitely requires less than this many words of stack,
   don't include an explicit STKCHECK insn in it.  The interpreter
   will check for this many words of stack before running each BCO,
   rendering an explicit check unnecessary in the majority of
   cases. */
#define INTERP_STACK_CHECK_THRESH  50

/*-------------------------------------------------------------------------*/
{-# START_FILE include/ghc-7.10.2/rts/Config.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * Rts settings.
 *
 * NOTE: assumes #include "ghcconfig.h"
 * 
 * NB: THIS FILE IS INCLUDED IN NON-C CODE AND DATA!  #defines only please.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_CONFIG_H
#define RTS_CONFIG_H

#if defined(TICKY_TICKY) && defined(THREADED_RTS)
#error TICKY_TICKY is incompatible with THREADED_RTS
#endif

/*
 * Whether the runtime system will use libbfd for debugging purposes.
 */
#if defined(DEBUG) && defined(HAVE_BFD_H) && defined(HAVE_LIBBFD) && !defined(_WIN32)
#define USING_LIBBFD 1
#endif

/* DEBUG implies TRACING and TICKY_TICKY
 */
#if defined(DEBUG)
#define TRACING
#define TICKY_TICKY
#endif

/* -----------------------------------------------------------------------------
   Signals - supported on non-PAR versions of the runtime.  See RtsSignals.h.
   -------------------------------------------------------------------------- */

#define RTS_USER_SIGNALS 1

/* Profile spin locks */

#define PROF_SPIN

#endif /* RTS_CONFIG_H */
{-# START_FILE include/ghc-7.10.2/rts/Constants.h #-}
/* ----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * Constants
 *
 * NOTE: this information is used by both the compiler and the RTS.
 * Some of it is tweakable, and some of it must be kept up to date
 * with various other parts of the system.
 *
 * Constants which are derived automatically from other definitions in
 * the system (eg. structure sizes) are generated into the file
 * DerivedConstants.h by a C program (mkDerivedConstantsHdr).
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_CONSTANTS_H
#define RTS_CONSTANTS_H

/* -----------------------------------------------------------------------------
   Minimum closure sizes

   This is the minimum number of words in the payload of a
   heap-allocated closure, so that the closure has enough room to be
   overwritten with a forwarding pointer during garbage collection.
   -------------------------------------------------------------------------- */

#define MIN_PAYLOAD_SIZE 1

/* -----------------------------------------------------------------------------
   Constants to do with specialised closure types.
   -------------------------------------------------------------------------- */

/* We have some pre-compiled selector thunks defined in rts/StgStdThunks.hc.
 * This constant defines the highest selectee index that we can replace with a
 * reference to the pre-compiled code.
 */

#define MAX_SPEC_SELECTEE_SIZE 15

/* Vector-apply thunks.  These thunks just push their free variables
 * on the stack and enter the first one.  They're a bit like PAPs, but
 * don't have a dynamic size.  We've pre-compiled a few to save
 * space.
 */

#define MAX_SPEC_AP_SIZE       7

/* Specialised FUN/THUNK/CONSTR closure types */

#define MAX_SPEC_THUNK_SIZE    2
#define MAX_SPEC_FUN_SIZE      2
#define MAX_SPEC_CONSTR_SIZE   2

/* Range of built-in table of static small int-like and char-like closures.
 *
 *   NB. This corresponds with the number of actual INTLIKE/CHARLIKE
 *   closures defined in rts/StgMiscClosures.cmm.
 */
#define MAX_INTLIKE             16
#define MIN_INTLIKE             (-16)

#define MAX_CHARLIKE            255
#define MIN_CHARLIKE            0

/* Each byte in the card table for an StgMutaArrPtrs covers
 * (1<<MUT_ARR_PTRS_CARD_BITS) elements in the array.  To find a good
 * value for this, I used the benchmarks nofib/gc/hash,
 * nofib/gc/graph, and nofib/gc/gc_bench.
 */
#define MUT_ARR_PTRS_CARD_BITS 7

/* -----------------------------------------------------------------------------
   STG Registers.

   Note that in MachRegs.h we define how many of these registers are
   *real* machine registers, and not just offsets in the Register Table.
   -------------------------------------------------------------------------- */

#define MAX_VANILLA_REG 10
#define MAX_FLOAT_REG   6
#define MAX_DOUBLE_REG  6
#define MAX_LONG_REG    1
#define MAX_XMM_REG     6

/* -----------------------------------------------------------------------------
   Semi-Tagging constants

   Old Comments about this stuff:

   Tags for indirection nodes and ``other'' (probably unevaluated) nodes;
   normal-form values of algebraic data types will have tags 0, 1, ...

   @INFO_IND_TAG@ is different from @INFO_OTHER_TAG@ just so we can count
   how often we bang into indirection nodes; that's all.  (WDP 95/11)

   ToDo: find out if we need any of this.
   -------------------------------------------------------------------------- */

#define INFO_OTHER_TAG          (-1)
#define INFO_IND_TAG            (-2)
#define INFO_FIRST_TAG          0

/* -----------------------------------------------------------------------------
   How much C stack to reserve for local temporaries when in the STG
   world.  Used in StgCRun.c.
   -------------------------------------------------------------------------- */

#define RESERVED_C_STACK_BYTES (2048 * SIZEOF_LONG)

/* -----------------------------------------------------------------------------
   How much Haskell stack space to reserve for the saving of registers
   etc. in the case of a stack/heap overflow.

   This must be large enough to accomodate the largest stack frame
   pushed in one of the heap check fragments in HeapStackCheck.hc
   (ie. currently the generic heap checks - 3 words for StgRetDyn,
   18 words for the saved registers, see StgMacros.h).
   -------------------------------------------------------------------------- */

#define RESERVED_STACK_WORDS 21

/* -----------------------------------------------------------------------------
   The limit on the size of the stack check performed when we enter an
   AP_STACK, in words.  See raiseAsync() and bug #1466.
   -------------------------------------------------------------------------- */

#define AP_STACK_SPLIM 1024

/* -----------------------------------------------------------------------------
   Storage manager constants
   -------------------------------------------------------------------------- */

/* The size of a block (2^BLOCK_SHIFT bytes) */
#define BLOCK_SHIFT  12

/* The size of a megablock (2^MBLOCK_SHIFT bytes) */
#define MBLOCK_SHIFT   20

/* -----------------------------------------------------------------------------
   Bitmap/size fields (used in info tables)
   -------------------------------------------------------------------------- */

/* In a 32-bit bitmap field, we use 5 bits for the size, and 27 bits
 * for the bitmap.  If the bitmap requires more than 27 bits, then we
 * store it in a separate array, and leave a pointer in the bitmap
 * field.  On a 64-bit machine, the sizes are extended accordingly.
 */
#if SIZEOF_VOID_P == 4
#define BITMAP_SIZE_MASK     0x1f
#define BITMAP_BITS_SHIFT    5
#elif SIZEOF_VOID_P == 8
#define BITMAP_SIZE_MASK     0x3f
#define BITMAP_BITS_SHIFT    6
#else
#error unknown SIZEOF_VOID_P
#endif

/* -----------------------------------------------------------------------------
   Lag/Drag/Void constants
   -------------------------------------------------------------------------- */

/*
  An LDV word is divided into 3 parts: state bits (LDV_STATE_MASK), creation
  time bits (LDV_CREATE_MASK), and last use time bits (LDV_LAST_MASK).
 */
#if SIZEOF_VOID_P == 8
#define LDV_SHIFT               30
#define LDV_STATE_MASK          0x1000000000000000
#define LDV_CREATE_MASK         0x0FFFFFFFC0000000
#define LDV_LAST_MASK           0x000000003FFFFFFF
#define LDV_STATE_CREATE        0x0000000000000000
#define LDV_STATE_USE           0x1000000000000000
#else
#define LDV_SHIFT               15
#define LDV_STATE_MASK          0x40000000
#define LDV_CREATE_MASK         0x3FFF8000
#define LDV_LAST_MASK           0x00007FFF
#define LDV_STATE_CREATE        0x00000000
#define LDV_STATE_USE           0x40000000
#endif /* SIZEOF_VOID_P */

/* -----------------------------------------------------------------------------
   TSO related constants
   -------------------------------------------------------------------------- */

/*
 * Constants for the what_next field of a TSO, which indicates how it
 * is to be run.
 */
#define ThreadRunGHC    1       /* return to address on top of stack */
#define ThreadInterpret 2       /* interpret this thread */
#define ThreadKilled    3       /* thread has died, don't run it */
#define ThreadComplete  4       /* thread has finished */

/*
 * Constants for the why_blocked field of a TSO
 * NB. keep these in sync with GHC/Conc.lhs: threadStatus
 */
#define NotBlocked          0
#define BlockedOnMVar       1
#define BlockedOnMVarRead   14 /* TODO: renumber me, see #9003 */
#define BlockedOnBlackHole  2
#define BlockedOnRead       3
#define BlockedOnWrite      4
#define BlockedOnDelay      5
#define BlockedOnSTM        6

/* Win32 only: */
#define BlockedOnDoProc     7

/* Only relevant for PAR: */
  /* blocked on a remote closure represented by a Global Address: */
#define BlockedOnGA         8
  /* same as above but without sending a Fetch message */
#define BlockedOnGA_NoSend  9
/* Only relevant for THREADED_RTS: */
#define BlockedOnCCall      10
#define BlockedOnCCall_Interruptible 11
   /* same as above but permit killing the worker thread */

/* Involved in a message sent to tso->msg_cap */
#define BlockedOnMsgThrowTo 12

/* The thread is not on any run queues, but can be woken up
   by tryWakeupThread() */
#define ThreadMigrating     13

/* WARNING WARNING top number is BlockedOnMVarRead 14, not 13!! */

/*
 * These constants are returned to the scheduler by a thread that has
 * stopped for one reason or another.  See typedef StgThreadReturnCode
 * in TSO.h.
 */
#define HeapOverflow   1                /* might also be StackOverflow */
#define StackOverflow  2
#define ThreadYielding 3
#define ThreadBlocked  4
#define ThreadFinished 5

/*
 * Flags for the tso->flags field.
 */

/*
 * TSO_LOCKED is set when a TSO is locked to a particular Capability.
 */
#define TSO_LOCKED  2

/*
 * TSO_BLOCKEX: the TSO is blocking exceptions
 *
 * TSO_INTERRUPTIBLE: the TSO can be interrupted if it blocks
 * interruptibly (eg. with BlockedOnMVar).
 *
 * TSO_STOPPED_ON_BREAKPOINT: the thread is currently stopped in a breakpoint
 */
#define TSO_BLOCKEX       4
#define TSO_INTERRUPTIBLE 8
#define TSO_STOPPED_ON_BREAKPOINT 16

/*
 * Used by the sanity checker to check whether TSOs are on the correct
 * mutable list.
 */
#define TSO_MARKED 64

/*
 * Used to communicate between stackSqueeze() and
 * threadStackOverflow() that a thread's stack was squeezed and the
 * stack may not need to be expanded.
 */
#define TSO_SQUEEZED 128

/*
 * Enables the AllocationLimitExceeded exception when the thread's
 * allocation limit goes negative.
 */
#define TSO_ALLOC_LIMIT 256

/*
 * The number of times we spin in a spin lock before yielding (see
 * #3758).  To tune this value, use the benchmark in #3758: run the
 * server with -N2 and the client both on a dual-core.  Also make sure
 * that the chosen value doesn't slow down any of the parallel
 * benchmarks in nofib/parallel.
 */
#define SPIN_COUNT 1000

/* -----------------------------------------------------------------------------
   Spare workers per Capability in the threaded RTS

   No more than MAX_SPARE_WORKERS will be kept in the thread pool
   associated with each Capability.
   -------------------------------------------------------------------------- */

#define MAX_SPARE_WORKERS 6

#endif /* RTS_CONSTANTS_H */
{-# START_FILE include/ghc-7.10.2/rts/EventLogFormat.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2008-2009
 *
 * Event log format
 * 
 * The log format is designed to be extensible: old tools should be
 * able to parse (but not necessarily understand all of) new versions
 * of the format, and new tools will be able to understand old log
 * files.
 * 
 * Each event has a specific format.  If you add new events, give them
 * new numbers: we never re-use old event numbers.
 *
 * - The format is endian-independent: all values are represented in 
 *    bigendian order.
 *
 * - The format is extensible:
 *
 *    - The header describes each event type and its length.  Tools
 *      that don't recognise a particular event type can skip those events.
 *
 *    - There is room for extra information in the event type
 *      specification, which can be ignored by older tools.
 *
 *    - Events can have extra information added, but existing fields
 *      cannot be changed.  Tools should ignore extra fields at the
 *      end of the event record.
 *
 *    - Old event type ids are never re-used; just take a new identifier.
 *
 *
 * The format
 * ----------
 *
 * log : EVENT_HEADER_BEGIN
 *       EventType*
 *       EVENT_HEADER_END
 *       EVENT_DATA_BEGIN
 *       Event*
 *       EVENT_DATA_END
 *
 * EventType :
 *       EVENT_ET_BEGIN
 *       Word16         -- unique identifier for this event
 *       Int16          -- >=0  size of the event in bytes (minus the header)
 *                      -- -1   variable size
 *       Word32         -- length of the next field in bytes
 *       Word8*         -- string describing the event
 *       Word32         -- length of the next field in bytes
 *       Word8*         -- extra info (for future extensions)
 *       EVENT_ET_END
 *
 * Event : 
 *       Word16         -- event_type
 *       Word64         -- time (nanosecs)
 *       [Word16]       -- length of the rest (for variable-sized events only)
 *       ... extra event-specific info ...
 *
 *
 * To add a new event
 * ------------------
 *
 *  - In this file:
 *    - give it a new number, add a new #define EVENT_XXX below
 *  - In EventLog.c
 *    - add it to the EventDesc array
 *    - emit the event type in initEventLogging()
 *    - emit the new event in postEvent_()
 *    - generate the event itself by calling postEvent() somewhere
 *  - In the Haskell code to parse the event log file:
 *    - add types and code to read the new event
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_EVENTLOGFORMAT_H
#define RTS_EVENTLOGFORMAT_H

/*
 * Markers for begin/end of the Header.
 */
#define EVENT_HEADER_BEGIN    0x68647262 /* 'h' 'd' 'r' 'b' */
#define EVENT_HEADER_END      0x68647265 /* 'h' 'd' 'r' 'e' */

#define EVENT_DATA_BEGIN      0x64617462 /* 'd' 'a' 't' 'b' */
#define EVENT_DATA_END        0xffff

/*
 * Markers for begin/end of the list of Event Types in the Header.
 * Header, Event Type, Begin = hetb
 * Header, Event Type, End = hete
 */
#define EVENT_HET_BEGIN       0x68657462 /* 'h' 'e' 't' 'b' */
#define EVENT_HET_END         0x68657465 /* 'h' 'e' 't' 'e' */

#define EVENT_ET_BEGIN        0x65746200 /* 'e' 't' 'b' 0 */
#define EVENT_ET_END          0x65746500 /* 'e' 't' 'e' 0 */

/*
 * Types of event
 */
#define EVENT_CREATE_THREAD        0 /* (thread)               */
#define EVENT_RUN_THREAD           1 /* (thread)               */
#define EVENT_STOP_THREAD          2 /* (thread, status, blockinfo) */
#define EVENT_THREAD_RUNNABLE      3 /* (thread)               */
#define EVENT_MIGRATE_THREAD       4 /* (thread, new_cap)      */
/* 5, 6, 7 deprecated */
#define EVENT_THREAD_WAKEUP        8 /* (thread, other_cap)    */
#define EVENT_GC_START             9 /* ()                     */
#define EVENT_GC_END              10 /* ()                     */
#define EVENT_REQUEST_SEQ_GC      11 /* ()                     */
#define EVENT_REQUEST_PAR_GC      12 /* ()                     */
/* 13, 14 deprecated */
#define EVENT_CREATE_SPARK_THREAD 15 /* (spark_thread)         */
#define EVENT_LOG_MSG             16 /* (message ...)          */
/* EVENT_STARTUP should be deprecated at some point */
#define EVENT_STARTUP             17 /* (num_capabilities)     */
#define EVENT_BLOCK_MARKER        18 /* (size, end_time, capability) */
#define EVENT_USER_MSG            19 /* (message ...)          */
#define EVENT_GC_IDLE             20 /* () */
#define EVENT_GC_WORK             21 /* () */
#define EVENT_GC_DONE             22 /* () */
/* 23, 24 used by eden */
#define EVENT_CAPSET_CREATE       25 /* (capset, capset_type)  */
#define EVENT_CAPSET_DELETE       26 /* (capset)               */
#define EVENT_CAPSET_ASSIGN_CAP   27 /* (capset, cap)          */
#define EVENT_CAPSET_REMOVE_CAP   28 /* (capset, cap)          */
/* the RTS identifier is in the form of "GHC-version rts_way"  */
#define EVENT_RTS_IDENTIFIER      29 /* (capset, name_version_string) */
/* the vectors in these events are null separated strings             */
#define EVENT_PROGRAM_ARGS        30 /* (capset, commandline_vector)  */
#define EVENT_PROGRAM_ENV         31 /* (capset, environment_vector)  */
#define EVENT_OSPROCESS_PID       32 /* (capset, pid)          */
#define EVENT_OSPROCESS_PPID      33 /* (capset, parent_pid)   */
#define EVENT_SPARK_COUNTERS      34 /* (crt,dud,ovf,cnv,gcd,fiz,rem) */
#define EVENT_SPARK_CREATE        35 /* ()                     */
#define EVENT_SPARK_DUD           36 /* ()                     */
#define EVENT_SPARK_OVERFLOW      37 /* ()                     */
#define EVENT_SPARK_RUN           38 /* ()                     */
#define EVENT_SPARK_STEAL         39 /* (victim_cap)           */
#define EVENT_SPARK_FIZZLE        40 /* ()                     */
#define EVENT_SPARK_GC            41 /* ()                     */
#define EVENT_INTERN_STRING       42 /* (string, id) {not used by ghc} */
#define EVENT_WALL_CLOCK_TIME     43 /* (capset, unix_epoch_seconds, nanoseconds) */
#define EVENT_THREAD_LABEL        44 /* (thread, name_string)  */
#define EVENT_CAP_CREATE          45 /* (cap)                  */
#define EVENT_CAP_DELETE          46 /* (cap)                  */
#define EVENT_CAP_DISABLE         47 /* (cap)                  */
#define EVENT_CAP_ENABLE          48 /* (cap)                  */
#define EVENT_HEAP_ALLOCATED      49 /* (heap_capset, alloc_bytes) */
#define EVENT_HEAP_SIZE           50 /* (heap_capset, size_bytes) */
#define EVENT_HEAP_LIVE           51 /* (heap_capset, live_bytes) */
#define EVENT_HEAP_INFO_GHC       52 /* (heap_capset, n_generations,
                                         max_heap_size, alloc_area_size,
                                         mblock_size, block_size) */
#define EVENT_GC_STATS_GHC        53 /* (heap_capset, generation,
                                         copied_bytes, slop_bytes, frag_bytes,
                                         par_n_threads,
                                         par_max_copied, par_tot_copied) */
#define EVENT_GC_GLOBAL_SYNC      54 /* ()                     */
#define EVENT_TASK_CREATE         55 /* (taskID, cap, tid)       */
#define EVENT_TASK_MIGRATE        56 /* (taskID, cap, new_cap)   */
#define EVENT_TASK_DELETE         57 /* (taskID)                 */
#define EVENT_USER_MARKER         58 /* (marker_name) */
#define EVENT_HACK_BUG_T9003      59 /* Hack: see trac #9003 */

/* Range 59 - 59 is available for new GHC and common events. */

/* Range 60 - 80 is used by eden for parallel tracing
 * see http://www.mathematik.uni-marburg.de/~eden/
 */

/* Range 100 - 139 is reserved for Mercury. */

/* Range 140 - 159 is reserved for Perf events. */

/*
 * The highest event code +1 that ghc itself emits. Note that some event
 * ranges higher than this are reserved but not currently emitted by ghc.
 * This must match the size of the EventDesc[] array in EventLog.c
 */
#define NUM_GHC_EVENT_TAGS        60

#if 0  /* DEPRECATED EVENTS: */
/* we don't actually need to record the thread, it's implicit */
#define EVENT_RUN_SPARK            5 /* (thread)               */
#define EVENT_STEAL_SPARK          6 /* (thread, victim_cap)   */
/* shutdown replaced by EVENT_CAP_DELETE */
#define EVENT_SHUTDOWN             7 /* ()                     */
/* ghc changed how it handles sparks so these are no longer applicable */
#define EVENT_CREATE_SPARK        13 /* (cap, thread) */
#define EVENT_SPARK_TO_THREAD     14 /* (cap, thread, spark_thread) */
/* these are used by eden but are replaced by new alternatives for ghc */
#define EVENT_VERSION             23 /* (version_string) */
#define EVENT_PROGRAM_INVOCATION  24 /* (commandline_string) */
#endif

/*
 * Status values for EVENT_STOP_THREAD
 *
 * 1-5 are the StgRun return values (from includes/Constants.h):
 *
 * #define HeapOverflow   1
 * #define StackOverflow  2
 * #define ThreadYielding 3
 * #define ThreadBlocked  4
 * #define ThreadFinished 5
 * #define ForeignCall                  6
 * #define BlockedOnMVar                7
 * #define BlockedOnBlackHole           8
 * #define BlockedOnRead                9
 * #define BlockedOnWrite               10
 * #define BlockedOnDelay               11
 * #define BlockedOnSTM                 12
 * #define BlockedOnDoProc              13
 * #define BlockedOnCCall               -- not used (see ForeignCall)
 * #define BlockedOnCCall_NoUnblockExc  -- not used (see ForeignCall)
 * #define BlockedOnMsgThrowTo          16
 */
#define THREAD_SUSPENDED_FOREIGN_CALL 6

/*
 * Capset type values for EVENT_CAPSET_CREATE
 */
#define CAPSET_TYPE_CUSTOM      1  /* reserved for end-user applications */
#define CAPSET_TYPE_OSPROCESS   2  /* caps belong to the same OS process */
#define CAPSET_TYPE_CLOCKDOMAIN 3  /* caps share a local clock/time      */

#ifndef EVENTLOG_CONSTANTS_ONLY

typedef StgWord16 EventTypeNum;
typedef StgWord64 EventTimestamp; /* in nanoseconds */
typedef StgWord32 EventThreadID;
typedef StgWord16 EventCapNo;
typedef StgWord16 EventPayloadSize; /* variable-size events */
typedef StgWord16 EventThreadStatus; /* status for EVENT_STOP_THREAD */
typedef StgWord32 EventCapsetID;
typedef StgWord16 EventCapsetType;   /* types for EVENT_CAPSET_CREATE */
typedef StgWord64 EventTaskId;         /* for EVENT_TASK_* */
typedef StgWord64 EventKernelThreadId; /* for EVENT_TASK_CREATE */

#endif

#endif /* RTS_EVENTLOGFORMAT_H */
{-# START_FILE include/ghc-7.10.2/rts/FileLock.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2007-2009
 *
 * File locking support as required by Haskell
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_FILELOCK_H
#define RTS_FILELOCK_H

#include "Stg.h"

int  lockFile(int fd, StgWord64 dev, StgWord64 ino, int for_writing);
int  unlockFile(int fd);

#endif /* RTS_FILELOCK_H */
{-# START_FILE include/ghc-7.10.2/rts/Flags.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * Datatypes that holds the command-line flag settings.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_FLAGS_H
#define RTS_FLAGS_H

#include <stdio.h>

/* For defaults, see the @initRtsFlagsDefaults@ routine. */

/* Note [Synchronization of flags and base APIs]
 *
 * We provide accessors to RTS flags in base. (GHC.RTS module)
 * The API should be updated whenever RTS flags are modified.
 */

/* See Note [Synchronization of flags and base APIs] */
typedef struct _GC_FLAGS {
    FILE   *statsFile;
    nat	    giveStats;
#define NO_GC_STATS	 0
#define COLLECT_GC_STATS 1
#define ONELINE_GC_STATS 2
#define SUMMARY_GC_STATS 3
#define VERBOSE_GC_STATS 4

    nat     maxStkSize;         /* in *words* */
    nat     initialStkSize;     /* in *words* */
    nat     stkChunkSize;       /* in *words* */
    nat     stkChunkBufferSize; /* in *words* */

    nat	    maxHeapSize;        /* in *blocks* */
    nat     minAllocAreaSize;   /* in *blocks* */
    nat     nurseryChunkSize;   /* in *blocks* */
    nat     minOldGenSize;      /* in *blocks* */
    nat     heapSizeSuggestion; /* in *blocks* */
    rtsBool heapSizeSuggestionAuto;
    double  oldGenFactor;
    double  pcFreeHeap;

    nat     generations;
    nat     steps;
    rtsBool squeezeUpdFrames;

    rtsBool compact;		/* True <=> "compact all the time" */
    double  compactThreshold;

    rtsBool sweep;		/* use "mostly mark-sweep" instead of copying
                                 * for the oldest generation */
    rtsBool ringBell;
    rtsBool frontpanel;

    Time    idleGCDelayTime;    /* units: TIME_RESOLUTION */
    rtsBool doIdleGC;

    StgWord heapBase;           /* address to ask the OS for memory */

    StgWord allocLimitGrace;    /* units: *blocks*
                                 * After an AllocationLimitExceeded
                                 * exception has been raised, how much
                                 * extra space is given to the thread
                                 * to handle the exception before we
                                 * raise it again.
                                 */
} GC_FLAGS;

/* See Note [Synchronization of flags and base APIs] */
typedef struct _DEBUG_FLAGS {
    /* flags to control debugging output & extra checking in various subsystems */
    rtsBool scheduler;      /* 's' */
    rtsBool interpreter;    /* 'i' */
    rtsBool weak;           /* 'w' */
    rtsBool gccafs;         /* 'G' */
    rtsBool gc;             /* 'g' */
    rtsBool block_alloc;    /* 'b' */
    rtsBool sanity;         /* 'S'   warning: might be expensive! */
    rtsBool stable;         /* 't' */
    rtsBool prof;           /* 'p' */
    rtsBool linker;         /* 'l'   the object linker */
    rtsBool apply;          /* 'a' */
    rtsBool stm;            /* 'm' */
    rtsBool squeeze;        /* 'z'  stack squeezing & lazy blackholing */
    rtsBool hpc; 	    /* 'c' coverage */
    rtsBool sparks; 	    /* 'r' */
} DEBUG_FLAGS;

/* See Note [Synchronization of flags and base APIs] */
typedef struct _COST_CENTRE_FLAGS {
    nat	    doCostCentres;
# define COST_CENTRES_NONE      0
# define COST_CENTRES_SUMMARY	1
# define COST_CENTRES_VERBOSE	2 /* incl. serial time profile */
# define COST_CENTRES_ALL	3
# define COST_CENTRES_XML       4

    int	    profilerTicks;   /* derived */
    int	    msecsPerTick;    /* derived */
} COST_CENTRE_FLAGS;

/* See Note [Synchronization of flags and base APIs] */
typedef struct _PROFILING_FLAGS {
    nat	doHeapProfile;
# define NO_HEAP_PROFILING	0	/* N.B. Used as indexes into arrays */
# define HEAP_BY_CCS		1
# define HEAP_BY_MOD		2
# define HEAP_BY_DESCR		4
# define HEAP_BY_TYPE		5
# define HEAP_BY_RETAINER       6
# define HEAP_BY_LDV            7

# define HEAP_BY_CLOSURE_TYPE   8

    Time                heapProfileInterval; /* time between samples */
    nat                 heapProfileIntervalTicks; /* ticks between samples (derived) */
    rtsBool             includeTSOs;


    rtsBool		showCCSOnException;

    nat                 maxRetainerSetSize;

    nat                 ccsLength;

    char*               modSelector;
    char*               descrSelector;
    char*               typeSelector;
    char*               ccSelector;
    char*               ccsSelector;
    char*               retainerSelector;
    char*               bioSelector;

} PROFILING_FLAGS;

#define TRACE_NONE      0
#define TRACE_EVENTLOG  1
#define TRACE_STDERR    2

/* See Note [Synchronization of flags and base APIs] */
typedef struct _TRACE_FLAGS {
    int tracing;
    rtsBool timestamp;      /* show timestamp in stderr output */
    rtsBool scheduler;      /* trace scheduler events */
    rtsBool gc;             /* trace GC events */
    rtsBool sparks_sampled; /* trace spark events by a sampled method */
    rtsBool sparks_full;    /* trace spark events 100% accurately */
    rtsBool user;           /* trace user events (emitted from Haskell code) */
} TRACE_FLAGS;

/* See Note [Synchronization of flags and base APIs] */
typedef struct _CONCURRENT_FLAGS {
    Time ctxtSwitchTime;         /* units: TIME_RESOLUTION */
    int ctxtSwitchTicks;         /* derived */
} CONCURRENT_FLAGS;

/*
 * The tickInterval is the time interval between "ticks", ie.
 * timer signals (see Timer.{c,h}).  It is the frequency at
 * which we sample CCCS for profiling.
 *
 * It is changed by the +RTS -V<secs> flag.
 */
#define DEFAULT_TICK_INTERVAL USToTime(10000)

/* See Note [Synchronization of flags and base APIs] */
typedef struct _MISC_FLAGS {
    Time    tickInterval;        /* units: TIME_RESOLUTION */
    rtsBool install_signal_handlers;
    rtsBool machineReadable;
    StgWord linkerMemBase;       /* address to ask the OS for memory
                                  * for the linker, NULL ==> off */
} MISC_FLAGS;

#ifdef THREADED_RTS
/* See Note [Synchronization of flags and base APIs] */
typedef struct _PAR_FLAGS {
  nat            nNodes;         /* number of threads to run simultaneously */
  rtsBool        migrate;        /* migrate threads between capabilities */
  nat            maxLocalSparks;
  rtsBool        parGcEnabled;   /* enable parallel GC */
  nat            parGcGen;       /* do parallel GC in this generation
                                  * and higher only */
  rtsBool        parGcLoadBalancingEnabled; 
                                 /* enable load-balancing in the
                                  * parallel GC */
  nat            parGcLoadBalancingGen;
                                 /* do load-balancing in this
                                  * generation and higher only */

  nat            parGcNoSyncWithIdle;
                                 /* if a Capability has been idle for
                                  * this many GCs, do not try to wake
                                  * it up when doing a
                                  * non-load-balancing parallel GC.
                                  * (zero disables) */

  rtsBool        setAffinity;    /* force thread affinity with CPUs */
} PAR_FLAGS;
#endif /* THREADED_RTS */

/* See Note [Synchronization of flags and base APIs] */
typedef struct _TICKY_FLAGS {
    rtsBool showTickyStats;
    FILE   *tickyFile;
} TICKY_FLAGS;

#ifdef USE_PAPI
#define MAX_PAPI_USER_EVENTS 8

/* See Note [Synchronization of flags and base APIs] */
typedef struct _PAPI_FLAGS {
    nat     eventType;          /* The type of events to count */
    nat     numUserEvents;
    char *  userEvents[MAX_PAPI_USER_EVENTS];
    /* Allow user to enter either PAPI preset or native events */
    nat     userEventsKind[MAX_PAPI_USER_EVENTS];
} PAPI_FLAGS;

#define PAPI_FLAG_CACHE_L1 1
#define PAPI_FLAG_CACHE_L2 2
#define PAPI_FLAG_BRANCH 3
#define PAPI_FLAG_STALLS 4
#define PAPI_FLAG_CB_EVENTS 5
#define PAPI_USER_EVENTS 6
#define PAPI_PRESET_EVENT_KIND 0
#define PAPI_NATIVE_EVENT_KIND 1

#endif

/* Put them together: */

/* See Note [Synchronization of flags and base APIs] */
typedef struct _RTS_FLAGS {
    /* The first portion of RTS_FLAGS is invariant. */
    GC_FLAGS	      GcFlags;
    CONCURRENT_FLAGS  ConcFlags;
    MISC_FLAGS        MiscFlags;
    DEBUG_FLAGS	      DebugFlags;
    COST_CENTRE_FLAGS CcFlags;
    PROFILING_FLAGS   ProfFlags;
    TRACE_FLAGS       TraceFlags;
    TICKY_FLAGS	      TickyFlags;

#if defined(THREADED_RTS)
    PAR_FLAGS	      ParFlags;
#endif
#ifdef USE_PAPI
    PAPI_FLAGS        PapiFlags;
#endif
} RTS_FLAGS;

#ifdef COMPILING_RTS_MAIN
extern DLLIMPORT RTS_FLAGS RtsFlags;
#elif IN_STG_CODE
/* Hack because the C code generator can't generate '&label'. */
extern RTS_FLAGS RtsFlags[];
#else
extern RTS_FLAGS RtsFlags;
#endif

/*
 * The printf formats are here, so we are less likely to make
 * overly-long filenames (with disastrous results).  No more than 128
 * chars, please!  
 */

#define STATS_FILENAME_MAXLEN	128

#define GR_FILENAME_FMT		"%0.124s.gr"
#define GR_FILENAME_FMT_GUM	"%0.120s.%03d.%s"
#define HP_FILENAME_FMT		"%0.124s.hp"
#define LIFE_FILENAME_FMT	"%0.122s.life"
#define PROF_FILENAME_FMT	"%0.122s.prof"
#define PROF_FILENAME_FMT_GUM	"%0.118s.%03d.prof"
#define QP_FILENAME_FMT		"%0.124s.qp"
#define STAT_FILENAME_FMT	"%0.122s.stat"
#define TICKY_FILENAME_FMT	"%0.121s.ticky"
#define TIME_FILENAME_FMT	"%0.122s.time"
#define TIME_FILENAME_FMT_GUM	"%0.118s.%03d.time"

/* an "int" so as to match normal "argc" */
/* Now defined in Stg.h (lib/std/cbits need these too.)
extern int     prog_argc;
extern char  **prog_argv;
*/
extern int      rts_argc;  /* ditto */
extern char   **rts_argv;

#endif	/* RTS_FLAGS_H */
{-# START_FILE include/ghc-7.10.2/rts/GetTime.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1995-2009
 *
 * Interface to the RTS time
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_GETTIME_H
#define RTS_GETTIME_H

StgWord64 getMonotonicNSec (void);

#endif /* RTS_GETTIME_H */
{-# START_FILE include/ghc-7.10.2/rts/Globals.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2006-2009
 *
 * The RTS stores some "global" values on behalf of libraries, so that
 * some libraries can ensure that certain top-level things are shared
 * even when multiple versions of the library are loaded.  e.g. see
 * Data.Typeable and GHC.Conc.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_GLOBALS_H
#define RTS_GLOBALS_H

StgStablePtr getOrSetGHCConcSignalSignalHandlerStore(StgStablePtr value);
StgStablePtr getOrSetGHCConcWindowsPendingDelaysStore(StgStablePtr ptr);
StgStablePtr getOrSetGHCConcWindowsIOManagerThreadStore(StgStablePtr ptr);
StgStablePtr getOrSetGHCConcWindowsProddingStore(StgStablePtr ptr);
StgStablePtr getOrSetSystemEventThreadEventManagerStore(StgStablePtr ptr);
StgStablePtr getOrSetSystemEventThreadIOManagerThreadStore(StgStablePtr ptr);
StgStablePtr getOrSetSystemTimerThreadEventManagerStore(StgStablePtr ptr);
StgStablePtr getOrSetSystemTimerThreadIOManagerThreadStore(StgStablePtr ptr);
StgStablePtr getOrSetLibHSghcFastStringTable(StgStablePtr ptr);

#endif /* RTS_GLOBALS_H */
{-# START_FILE include/ghc-7.10.2/rts/Hooks.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * User-overridable RTS hooks.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_HOOKS_H
#define RTS_HOOKS_H

extern char *ghc_rts_opts;

extern void OnExitHook (void);
extern int  NoRunnableThreadsHook (void);
extern void StackOverflowHook (W_ stack_size);
extern void OutOfHeapHook (W_ request_size, W_ heap_size);
extern void MallocFailHook (W_ request_size /* in bytes */, char *msg);
extern void defaultsHook (void);

#endif /* RTS_HOOKS_H */
{-# START_FILE include/ghc-7.10.2/rts/Hpc.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2008-2009
 *
 * Haskell Program Coverage
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_HPC_H
#define RTS_HPC_H

// Simple linked list of modules
typedef struct _HpcModuleInfo {
  char *modName;                // name of module
  StgWord32 tickCount;          // number of ticks
  StgWord32 hashNo;             // Hash number for this module's mix info
  StgWord64 *tixArr;            // tix Array; local for this module
  rtsBool from_file;            // data was read from the .tix file
  struct _HpcModuleInfo *next;
} HpcModuleInfo;

void hs_hpc_module (char *modName,
                    StgWord32 modCount,
                    StgWord32 modHashNo,
                    StgWord64 *tixArr);

HpcModuleInfo * hs_hpc_rootModule (void);

void startupHpc(void);
void exitHpc(void);

#endif /* RTS_HPC_H */
{-# START_FILE include/ghc-7.10.2/rts/IOManager.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * IO Manager functionality in the RTS
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_IOMANAGER_H
#define RTS_IOMANAGER_H

#if defined(mingw32_HOST_OS)

int  rts_InstallConsoleEvent ( int action, StgStablePtr *handler );
void rts_ConsoleHandlerDone  ( int ev );
extern StgInt console_handler;

void *   getIOManagerEvent  (void);
HsWord32 readIOManagerEvent (void);
void     sendIOManagerEvent (HsWord32 event);

#else

void     setIOManagerControlFd   (nat cap_no, int fd);
void     setTimerManagerControlFd(int fd);
void     setIOManagerWakeupFd   (int fd);

#endif

//
// Communicating with the IO manager thread (see GHC.Conc).
// Posix implementation in posix/Signals.c
// Win32 implementation in win32/ThrIOManager.c
//
void ioManagerWakeup (void);
#if defined(THREADED_RTS)
void ioManagerDie (void);
void ioManagerStart (void);
#endif

#endif /* RTS_IOMANAGER_H */
{-# START_FILE include/ghc-7.10.2/rts/Linker.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2009
 *
 * RTS Object Linker
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_LINKER_H
#define RTS_LINKER_H

#if defined(mingw32_HOST_OS)
typedef wchar_t pathchar;
#define PATH_FMT "ls"
#else
typedef char    pathchar;
#define PATH_FMT "s"
#endif

/* Initialize the object linker. Equivalent to initLinker_(1). */
void initLinker (void);

/* Initialize the object linker.
 * The retain_cafs argument is:
 *
 *   non-zero => Retain CAFs unconditionally in linked Haskell code.
 *               Note that this prevents any code from being unloaded.
 *               It should not be necessary unless you are GHCi or
 *               hs-plugins, which needs to be able call any function
 *               in the compiled code.
 *
 *   zero     => Do not retain CAFs.  Everything reachable from foreign
 *               exports will be retained, due to the StablePtrs
 *               created by the module initialisation code.  unloadObj
 *               frees these StablePtrs, which will allow the CAFs to
 *               be GC'd and the code to be removed.
 */
void initLinker_ (int retain_cafs);

/* insert a symbol in the hash table */
HsInt insertSymbol(pathchar* obj_name, char* key, void* data);

/* lookup a symbol in the hash table */
void *lookupSymbol( char *lbl );

/* delete an object from the pool */
HsInt unloadObj( pathchar *path );

/* purge an object's symbols from the symbol table, but don't unload it */
HsInt purgeObj( pathchar *path );

/* add an obj (populate the global symbol table, but don't resolve yet) */
HsInt loadObj( pathchar *path );

/* add an arch (populate the global symbol table, but don't resolve yet) */
HsInt loadArchive( pathchar *path );

/* resolve all the currently unlinked objects in memory */
HsInt resolveObjs( void );

/* load a dynamic library */
const char *addDLL( pathchar* dll_name );

/* called by the initialization code for a module, not a user API */
StgStablePtr foreignExportStablePtr (StgPtr p);

#endif /* RTS_LINKER_H */
{-# START_FILE include/ghc-7.10.2/rts/Main.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2009
 *
 * Entry point for standalone Haskell programs.
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTSMAIN_H
#define RTSMAIN_H

/* -----------------------------------------------------------------------------
 * The entry point for Haskell programs that use a Haskell main function
 * -------------------------------------------------------------------------- */

int hs_main (int argc, char *argv[],     // program args
             StgClosure *main_closure,   // closure for Main.main
             RtsConfig rts_config)       // RTS configuration
   GNUC3_ATTRIBUTE(__noreturn__);

#endif /* RTSMAIN_H */
{-# START_FILE include/ghc-7.10.2/rts/Messages.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * Message API for use inside the RTS.  All messages generated by the
 * RTS should go through one of the functions declared here, and we
 * also provide hooks so that messages from the RTS can be redirected
 * as appropriate.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_MESSAGES_H
#define RTS_MESSAGES_H

#include <stdarg.h>

#if defined(mingw32_HOST_OS)
/* On Win64, if we say "printf" then gcc thinks we are going to use
   MS format specifiers like %I64d rather than %llu */
#define PRINTF gnu_printf
#else
/* However, on OS X, "gnu_printf" isn't recognised */
#define PRINTF printf
#endif

/* -----------------------------------------------------------------------------
 * Message generation
 * -------------------------------------------------------------------------- */

/*
 * A fatal internal error: this is for errors that probably indicate
 * bugs in the RTS or compiler.  We normally output bug reporting
 * instructions along with the error message.
 *
 * barf() invokes (*fatalInternalErrorFn)().  This function is not
 * expected to return.
 */
void barf(const char *s, ...)
   GNUC3_ATTRIBUTE(__noreturn__);

void vbarf(const char *s, va_list ap)
   GNUC3_ATTRIBUTE(__noreturn__);

// declared in Rts.h:
// extern void _assertFail(const char *filename, unsigned int linenum)
//    GNUC3_ATTRIBUTE(__noreturn__);

/*
 * An error condition which is caused by and/or can be corrected by
 * the user.
 *
 * errorBelch() invokes (*errorMsgFn)().
 */
void errorBelch(const char *s, ...)
   GNUC3_ATTRIBUTE(format (PRINTF, 1, 2));

void verrorBelch(const char *s, va_list ap);

/*
 * An error condition which is caused by and/or can be corrected by
 * the user, and which has an associated error condition reported
 * by the system (in errno on Unix, and GetLastError() on Windows).
 * The system error message is appended to the message generated
 * from the supplied format string.
 *
 * sysErrorBelch() invokes (*sysErrorMsgFn)().
 */
void sysErrorBelch(const char *s, ...)
   GNUC3_ATTRIBUTE(format (PRINTF, 1, 2));

void vsysErrorBelch(const char *s, va_list ap);

/*
 * A debugging message.  Debugging messages are generated either as a
 * virtue of having DEBUG turned on, or by being explicitly selected
 * via RTS options (eg. +RTS -Ds).
 *
 * debugBelch() invokes (*debugMsgFn)().
 */
void debugBelch(const char *s, ...)
   GNUC3_ATTRIBUTE(format (PRINTF, 1, 2));

void vdebugBelch(const char *s, va_list ap);


/* Hooks for redirecting message generation: */

typedef void RtsMsgFunction(const char *, va_list);

extern RtsMsgFunction *fatalInternalErrorFn;
extern RtsMsgFunction *debugMsgFn;
extern RtsMsgFunction *errorMsgFn;

/* Default stdio implementation of the message hooks: */

extern RtsMsgFunction rtsFatalInternalErrorFn;
extern RtsMsgFunction rtsDebugMsgFn;
extern RtsMsgFunction rtsErrorMsgFn;
extern RtsMsgFunction rtsSysErrorMsgFn;

#endif /* RTS_MESSAGES_H */
{-# START_FILE include/ghc-7.10.2/rts/OSThreads.h #-}
/* ---------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2001-2009
 *
 * Accessing OS threads functionality in a (mostly) OS-independent
 * manner.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * --------------------------------------------------------------------------*/

#ifndef RTS_OSTHREADS_H
#define RTS_OSTHREADS_H

#if defined(THREADED_RTS) /* to near the end */

#if defined(HAVE_PTHREAD_H) && !defined(mingw32_HOST_OS)

#if CMINUSMINUS

#define ACQUIRE_LOCK(mutex) foreign "C" pthread_mutex_lock(mutex)
#define RELEASE_LOCK(mutex) foreign "C" pthread_mutex_unlock(mutex)
#define ASSERT_LOCK_HELD(mutex) /* nothing */

#else

#include <pthread.h>
#include <errno.h>

typedef pthread_cond_t  Condition;
typedef pthread_mutex_t Mutex;
typedef pthread_t       OSThreadId;
typedef pthread_key_t   ThreadLocalKey;

#define OSThreadProcAttr /* nothing */

#define INIT_COND_VAR       PTHREAD_COND_INITIALIZER

#ifdef LOCK_DEBUG
#define LOCK_DEBUG_BELCH(what, mutex) \
  debugBelch("%s(0x%p) %s %d\n", what, mutex, __FILE__, __LINE__)
#else
#define LOCK_DEBUG_BELCH(what, mutex) /* nothing */
#endif

/* Always check the result of lock and unlock. */
#define ACQUIRE_LOCK(mutex) \
  LOCK_DEBUG_BELCH("ACQUIRE_LOCK", mutex); \
  if (pthread_mutex_lock(mutex) == EDEADLK) { \
    barf("multiple ACQUIRE_LOCK: %s %d", __FILE__,__LINE__); \
  }

// Returns zero if the lock was acquired.
EXTERN_INLINE int TRY_ACQUIRE_LOCK(pthread_mutex_t *mutex);
EXTERN_INLINE int TRY_ACQUIRE_LOCK(pthread_mutex_t *mutex)
{
    LOCK_DEBUG_BELCH("TRY_ACQUIRE_LOCK", mutex);
    return pthread_mutex_trylock(mutex);
}

#define RELEASE_LOCK(mutex) \
  LOCK_DEBUG_BELCH("RELEASE_LOCK", mutex); \
  if (pthread_mutex_unlock(mutex) != 0) { \
    barf("RELEASE_LOCK: I do not own this lock: %s %d", __FILE__,__LINE__); \
  }

// Note: this assertion calls pthread_mutex_lock() on a mutex that
// is already held by the calling thread.  The mutex should therefore
// have been created with PTHREAD_MUTEX_ERRORCHECK, otherwise this
// assertion will hang.  We always initialise mutexes with
// PTHREAD_MUTEX_ERRORCHECK when DEBUG is on (see rts/posix/OSThreads.h).
#define ASSERT_LOCK_HELD(mutex) ASSERT(pthread_mutex_lock(mutex) == EDEADLK)

#endif // CMINUSMINUS

# elif defined(HAVE_WINDOWS_H)

#if CMINUSMINUS

/* We jump through a hoop here to get a CCall EnterCriticalSection
   and LeaveCriticalSection, as that's what C-- wants. */

#define ACQUIRE_LOCK(mutex) foreign "stdcall" EnterCriticalSection(mutex)
#define RELEASE_LOCK(mutex) foreign "stdcall" LeaveCriticalSection(mutex)
#define ASSERT_LOCK_HELD(mutex) /* nothing */

#else

#include <windows.h>

typedef HANDLE Condition;
typedef DWORD OSThreadId;
// don't be tempted to use HANDLE as the OSThreadId: there can be
// many HANDLES to a given thread, so comparison would not work.
typedef DWORD ThreadLocalKey;

#define OSThreadProcAttr __stdcall

#define INIT_COND_VAR  0

// We have a choice for implementing Mutexes on Windows.  Standard
// Mutexes are kernel objects that require kernel calls to
// acquire/release, whereas CriticalSections are spin-locks that block
// in the kernel after spinning for a configurable number of times.
// CriticalSections are *much* faster, so we use those.  The Mutex
// implementation is left here for posterity.
#define USE_CRITICAL_SECTIONS 1

#if USE_CRITICAL_SECTIONS

typedef CRITICAL_SECTION Mutex;

#ifdef LOCK_DEBUG

#define ACQUIRE_LOCK(mutex) \
  debugBelch("ACQUIRE_LOCK(0x%p) %s %d\n", mutex,__FILE__,__LINE__); \
  EnterCriticalSection(mutex)
#define RELEASE_LOCK(mutex) \
  debugBelch("RELEASE_LOCK(0x%p) %s %d\n", mutex,__FILE__,__LINE__); \
  LeaveCriticalSection(mutex)
#define ASSERT_LOCK_HELD(mutex) /* nothing */

#else

#define ACQUIRE_LOCK(mutex)      EnterCriticalSection(mutex)
#define TRY_ACQUIRE_LOCK(mutex)  (TryEnterCriticalSection(mutex) == 0)
#define RELEASE_LOCK(mutex)      LeaveCriticalSection(mutex)

// I don't know how to do this.  TryEnterCriticalSection() doesn't do
// the right thing.
#define ASSERT_LOCK_HELD(mutex) /* nothing */

#endif

#else

typedef HANDLE Mutex;

// casting to (Mutex *) here required due to use in .cmm files where
// the argument has (void *) type.
#define ACQUIRE_LOCK(mutex)                                     \
    if (WaitForSingleObject(*((Mutex *)mutex),INFINITE) == WAIT_FAILED) { \
        barf("WaitForSingleObject: %d", GetLastError());        \
    }

#define RELEASE_LOCK(mutex)                             \
    if (ReleaseMutex(*((Mutex *)mutex)) == 0) {         \
        barf("ReleaseMutex: %d", GetLastError());       \
    }

#define ASSERT_LOCK_HELD(mutex) /* nothing */
#endif

#endif // CMINUSMINUS

# else
#  error "Threads not supported"
# endif


#ifndef CMINUSMINUS
//
// General thread operations
//
extern OSThreadId osThreadId      ( void );
extern void shutdownThread        ( void )   GNUC3_ATTRIBUTE(__noreturn__);
extern void yieldThread           ( void );

typedef void OSThreadProcAttr OSThreadProc(void *);

extern int  createOSThread        ( OSThreadId* tid, char *name,
                                    OSThreadProc *startProc, void *param);
extern rtsBool osThreadIsAlive    ( OSThreadId id );
extern void interruptOSThread (OSThreadId id);

//
// Condition Variables
//
extern void initCondition         ( Condition* pCond );
extern void closeCondition        ( Condition* pCond );
extern rtsBool broadcastCondition ( Condition* pCond );
extern rtsBool signalCondition    ( Condition* pCond );
extern rtsBool waitCondition      ( Condition* pCond, Mutex* pMut );

//
// Mutexes
//
extern void initMutex             ( Mutex* pMut );
extern void closeMutex            ( Mutex* pMut );

//
// Thread-local storage
//
void  newThreadLocalKey (ThreadLocalKey *key);
void *getThreadLocalVar (ThreadLocalKey *key);
void  setThreadLocalVar (ThreadLocalKey *key, void *value);
void  freeThreadLocalKey (ThreadLocalKey *key);

// Processors and affinity
void setThreadAffinity     (nat n, nat m);
#endif // !CMINUSMINUS

#else

#define ACQUIRE_LOCK(l)
#define RELEASE_LOCK(l)
#define ASSERT_LOCK_HELD(l)

#endif /* defined(THREADED_RTS) */

#ifndef CMINUSMINUS
//
// Support for forkOS (defined regardless of THREADED_RTS, but does
// nothing when !THREADED_RTS).
//
int forkOS_createThread ( HsStablePtr entry );

//
// Returns the number of processor cores in the machine
//
nat getNumberOfProcessors (void);

//
// Support for getting at the kernel thread Id for tracing/profiling.
//
// This stuff is optional and only used for tracing/profiling purposes, to
// match up thread ids recorded by other tools. For example, on Linux and OSX
// the pthread_t type is not the same as the kernel thread id, and system
// profiling tools like Linux perf, and OSX's DTrace use the kernel thread Id.
// So if we want to match up RTS tasks with kernel threads recorded by these
// tools then we need to know the kernel thread Id, and this must be a separate
// type from the OSThreadId.
//
// If the feature cannot be supported on an OS, it is OK to always return 0.
// In particular it would almost certaily be meaningless on systems not using
// a 1:1 threading model.

// We use a common serialisable representation on all OSs
// This is ok for Windows, OSX and Linux.
typedef StgWord64 KernelThreadId;

// Get the current kernel thread id
KernelThreadId kernelThreadId (void);

#endif /* CMINUSMINUS */

#endif /* RTS_OSTHREADS_H */
{-# START_FILE include/ghc-7.10.2/rts/Parallel.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * Parallelism-related functionality
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_PARALLEL_H
#define RTS_PARALLEL_H

StgInt newSpark (StgRegTable *reg, StgClosure *p);

#endif /* RTS_PARALLEL_H */
{-# START_FILE include/ghc-7.10.2/rts/PrimFloat.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * Primitive floating-point operations
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_PRIMFLOAT_H
#define RTS_PRIMFLOAT_H

StgDouble __int_encodeDouble (I_ j, I_ e);
StgFloat  __int_encodeFloat (I_ j, I_ e);
StgDouble __word_encodeDouble (W_ j, I_ e);
StgFloat  __word_encodeFloat (W_ j, I_ e);

#endif /* RTS_PRIMFLOAT_H */
{-# START_FILE include/ghc-7.10.2/rts/prof/CCS.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2009-2012
 *
 * Macros for profiling operations in STG code
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_PROF_CCS_H
#define RTS_PROF_CCS_H

/* -----------------------------------------------------------------------------
 * Data Structures
 * ---------------------------------------------------------------------------*/
/*
 * Note [struct alignment]
 * NB. be careful to avoid unwanted padding between fields, by
 * putting the 8-byte fields on an 8-byte boundary.  Padding can
 * vary between C compilers, and we don't take into account any
 * possible padding when generating CCS and CC decls in the code
 * generator (compiler/codeGen/StgCmmProf.hs).
 */

typedef struct CostCentre_ {
    StgInt ccID;              // Unique Id, allocated by the RTS

    char * label;
    char * module;
    char * srcloc;

    // used for accumulating costs at the end of the run...
    StgWord64 mem_alloc;      // align 8 (Note [struct alignment])
    StgWord   time_ticks;

    StgInt is_caf;            // non-zero for a CAF cost centre

    struct CostCentre_ *link;
} CostCentre;

typedef struct CostCentreStack_ {
    StgInt ccsID;               // unique ID, allocated by the RTS

    CostCentre *cc;             // Cost centre at the top of the stack

    struct CostCentreStack_ *prevStack;   // parent
    struct IndexTable_      *indexTable;  // children
    struct CostCentreStack_ *root;        // root of stack
    StgWord    depth;           // number of items in the stack

    StgWord64  scc_count;       // Count of times this CCS is entered
                                // align 8 (Note [struct alignment])

    StgWord    selected;        // is this CCS shown in the heap
                                // profile? (zero if excluded via -hc
                                // -hm etc.)

    StgWord    time_ticks;      // number of time ticks accumulated by
                                // this CCS

    StgWord64  mem_alloc;       // mem allocated by this CCS
                                // align 8 (Note [struct alignment])

    StgWord64  inherited_alloc; // sum of mem_alloc over all children
                                // (calculated at the end)
                                // align 8 (Note [struct alignment])

    StgWord    inherited_ticks; // sum of time_ticks over all children
                                // (calculated at the end)
} CostCentreStack;


/* -----------------------------------------------------------------------------
 * Start and stop the profiling timer.  These can be called from
 * Haskell to restrict the profile to portion(s) of the execution.
 * See the module GHC.Profiling.
 * ---------------------------------------------------------------------------*/

void stopProfTimer      ( void );
void startProfTimer     ( void );

/* -----------------------------------------------------------------------------
 * The rest is PROFILING only...
 * ---------------------------------------------------------------------------*/

#if defined(PROFILING)

/* -----------------------------------------------------------------------------
 * Constants
 * ---------------------------------------------------------------------------*/

#define EMPTY_STACK NULL
#define EMPTY_TABLE NULL

/* Constants used to set is_caf flag on CostCentres */
#define CC_IS_CAF      'c'            /* 'c'  => *is* a CAF cc           */
#define CC_NOT_CAF     0

/* -----------------------------------------------------------------------------
 * Data Structures
 * ---------------------------------------------------------------------------*/

// IndexTable is the list of children of a CCS. (Alternatively it is a
// cache of the results of pushing onto a CCS, so that the second and
// subsequent times we push a certain CC on a CCS we get the same
// result).

typedef struct IndexTable_ {
    CostCentre *cc;
    CostCentreStack *ccs;
    struct IndexTable_ *next;
    nat back_edge;
} IndexTable;


/* -----------------------------------------------------------------------------
   Pre-defined cost centres and cost centre stacks
   -------------------------------------------------------------------------- */

#if IN_STG_CODE

extern StgWord CC_MAIN[];
extern StgWord CCS_MAIN[];      // Top CCS

extern StgWord CC_SYSTEM[];
extern StgWord CCS_SYSTEM[];    // RTS costs

extern StgWord CC_GC[];
extern StgWord CCS_GC[];         // Garbage collector costs

extern StgWord CC_OVERHEAD[];
extern StgWord CCS_OVERHEAD[];   // Profiling overhead

extern StgWord CC_DONT_CARE[];
extern StgWord CCS_DONT_CARE[];  // CCS attached to static constructors

#else

extern CostCentre      CC_MAIN[];
extern CostCentreStack CCS_MAIN[];      // Top CCS

extern CostCentre      CC_SYSTEM[];
extern CostCentreStack CCS_SYSTEM[];    // RTS costs

extern CostCentre      CC_GC[];
extern CostCentreStack CCS_GC[];         // Garbage collector costs

extern CostCentre      CC_OVERHEAD[];
extern CostCentreStack CCS_OVERHEAD[];   // Profiling overhead

extern CostCentre      CC_DONT_CARE[];
extern CostCentreStack CCS_DONT_CARE[];  // shouldn't ever get set

extern CostCentre      CC_PINNED[];
extern CostCentreStack CCS_PINNED[];     // pinned memory

extern CostCentre      CC_IDLE[];
extern CostCentreStack CCS_IDLE[];       // capability is idle

#endif /* IN_STG_CODE */

extern unsigned int RTS_VAR(CC_ID);     // global ids
extern unsigned int RTS_VAR(CCS_ID);

extern unsigned int RTS_VAR(era);

/* -----------------------------------------------------------------------------
 * Functions
 * ---------------------------------------------------------------------------*/

CostCentreStack * pushCostCentre (CostCentreStack *, CostCentre *);
void              enterFunCCS    (StgRegTable *reg, CostCentreStack *);

/* -----------------------------------------------------------------------------
   Registering CCs and CCSs

   Registering a CC or CCS consists of
     - assigning it a unique ID
     - linking it onto the list of registered CCs/CCSs

   Cost centres are registered at startup by a C constructor function
   generated by the compiler in the _stub.c file for each module.  The
   macros below are invoked by that C code to register CCs and CCSs.
 -------------------------------------------------------------------------- */

extern CostCentre * RTS_VAR(CC_LIST);               // registered CC list
extern CostCentreStack * RTS_VAR(CCS_LIST);         // registered CCS list

#define REGISTER_CC(cc)                                 \
        do {                                            \
        if ((cc)->link == (CostCentre *)0) {            \
            (cc)->link = CC_LIST;                       \
            CC_LIST = (cc);                             \
            (cc)->ccID = CC_ID++;                       \
        }} while(0)

#define REGISTER_CCS(ccs)                               \
        do {                                            \
        if ((ccs)->prevStack == (CostCentreStack *)0) { \
          (ccs)->prevStack = CCS_LIST;                  \
          CCS_LIST = (ccs);                             \
          (ccs)->ccsID = CCS_ID++;                      \
        }} while(0)

/* -----------------------------------------------------------------------------
 * Declaring Cost Centres & Cost Centre Stacks.
 * -------------------------------------------------------------------------- */

# define CC_DECLARE(cc_ident,name,mod,loc,caf,is_local)  \
     is_local CostCentre cc_ident[1]                     \
       = {{ .ccID       = 0,                             \
            .label      = name,                          \
            .module     = mod,                           \
            .srcloc     = loc,                           \
            .time_ticks = 0,                             \
            .mem_alloc  = 0,                             \
            .link       = 0,                             \
            .is_caf     = caf                            \
         }};

# define CCS_DECLARE(ccs_ident,cc_ident,is_local)        \
     is_local CostCentreStack ccs_ident[1]               \
       = {{ .ccsID               = 0,                    \
            .cc                  = cc_ident,             \
            .prevStack           = NULL,                 \
            .indexTable          = NULL,                 \
            .root                = NULL,                 \
            .depth               = 0,                    \
            .selected            = 0,                    \
            .scc_count           = 0,                    \
            .time_ticks          = 0,                    \
            .mem_alloc           = 0,                    \
            .inherited_ticks     = 0,                    \
            .inherited_alloc     = 0                     \
       }};

/* -----------------------------------------------------------------------------
 * Time / Allocation Macros
 * ---------------------------------------------------------------------------*/

/* eliminate profiling overhead from allocation costs */
#define CCS_ALLOC(ccs, size) (ccs)->mem_alloc += ((size)-sizeofW(StgProfHeader))

#else /* !PROFILING */

#define CCS_ALLOC(ccs, amount) doNothing()

#endif /* PROFILING */

#endif /* RTS_PROF_CCS_H */
{-# START_FILE include/ghc-7.10.2/rts/prof/LDV.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The University of Glasgow, 2009
 *
 * Lag/Drag/Void profiling.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_PROF_LDV_H
#define RTS_PROF_LDV_H

#ifdef PROFILING

/* retrieves the LDV word from closure c */
#define LDVW(c)                 (((StgClosure *)(c))->header.prof.hp.ldvw)

/*
 * Stores the creation time for closure c.
 * This macro is called at the very moment of closure creation.
 *
 * NOTE: this initializes LDVW(c) to zero, which ensures that there
 * is no conflict between retainer profiling and LDV profiling,
 * because retainer profiling also expects LDVW(c) to be initialised
 * to zero.
 */

#ifdef CMINUSMINUS

#else

#define LDV_RECORD_CREATE(c)   \
  LDVW((c)) = ((StgWord)RTS_DEREF(era) << LDV_SHIFT) | LDV_STATE_CREATE

#endif

#else  /* !PROFILING */

#define LDV_RECORD_CREATE(c)   /* nothing */

#endif /* PROFILING */

#endif /* STGLDVPROF_H */
{-# START_FILE include/ghc-7.10.2/rts/Signals.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * RTS signal handling 
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_SIGNALS_H
#define RTS_SIGNALS_H

/* NB. #included in Haskell code, no prototypes in here. */

/* arguments to stg_sig_install() */
#define STG_SIG_DFL   (-1)
#define STG_SIG_IGN   (-2)
#define STG_SIG_ERR   (-3)
#define STG_SIG_HAN   (-4)
#define STG_SIG_RST   (-5)

#endif /* RTS_SIGNALS_H */
{-# START_FILE include/ghc-7.10.2/rts/SpinLock.h #-}
/* ----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2006-2009
 *
 * Spin locks
 *
 * These are simple spin-only locks as opposed to Mutexes which
 * probably spin for a while before blocking in the kernel.  We use
 * these when we are sure that all our threads are actively running on
 * a CPU, eg. in the GC.
 *
 * TODO: measure whether we really need these, or whether Mutexes
 * would do (and be a bit safer if a CPU becomes loaded).
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_SPINLOCK_H
#define RTS_SPINLOCK_H
 
#if defined(THREADED_RTS)

#if defined(PROF_SPIN)
typedef struct SpinLock_
{
    StgWord   lock;
    StgWord64 spin; // DEBUG version counts how much it spins
} SpinLock;
#else
typedef StgWord SpinLock;
#endif

#if defined(PROF_SPIN)

// PROF_SPIN enables counting the number of times we spin on a lock

// acquire spin lock
INLINE_HEADER void ACQUIRE_SPIN_LOCK(SpinLock * p)
{
    StgWord32 r = 0;
    nat i;
    do {
        for (i = 0; i < SPIN_COUNT; i++) {
            r = cas((StgVolatilePtr)&(p->lock), 1, 0);
            if (r != 0) return;
            p->spin++;
            busy_wait_nop();
        }
        yieldThread();
    } while (1);
}

// release spin lock
INLINE_HEADER void RELEASE_SPIN_LOCK(SpinLock * p)
{
    write_barrier();
    p->lock = 1;
}

// initialise spin lock
INLINE_HEADER void initSpinLock(SpinLock * p)
{
    write_barrier();
    p->lock = 1;
    p->spin = 0;
}

#else

// acquire spin lock
INLINE_HEADER void ACQUIRE_SPIN_LOCK(SpinLock * p)
{
    StgWord32 r = 0;
    nat i;
    do {
        for (i = 0; i < SPIN_COUNT; i++) {
            r = cas((StgVolatilePtr)p, 1, 0);
            if (r != 0) return;
            busy_wait_nop();
        }
        yieldThread();
    } while (1);
}

// release spin lock
INLINE_HEADER void RELEASE_SPIN_LOCK(SpinLock * p)
{
    write_barrier();
    (*p) = 1;
}

// init spin lock
INLINE_HEADER void initSpinLock(SpinLock * p)
{
    write_barrier();
    (*p) = 1;
}

#endif /* PROF_SPIN */

#else /* !THREADED_RTS */

// Using macros here means we don't have to ensure the argument is in scope
#define ACQUIRE_SPIN_LOCK(p) /* nothing */
#define RELEASE_SPIN_LOCK(p) /* nothing */

INLINE_HEADER void initSpinLock(void * p STG_UNUSED)
{ /* nothing */ }

#endif /* THREADED_RTS */

#endif /* RTS_SPINLOCK_H */

{-# START_FILE include/ghc-7.10.2/rts/Stable.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * Stable Pointers
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_STABLE_H
#define RTS_STABLE_H

EXTERN_INLINE StgPtr deRefStablePtr (StgStablePtr stable_ptr);
StgStablePtr getStablePtr  (StgPtr p);

/* -----------------------------------------------------------------------------
   PRIVATE from here.
   -------------------------------------------------------------------------- */

typedef struct {
    StgPtr  addr;                       /* Haskell object, free list, or NULL */
    StgPtr  old;                        /* old Haskell object, used during GC */
    StgClosure *sn_obj;         /* the StableName object (or NULL) */
} snEntry;

typedef struct {
    StgPtr addr;
} spEntry;

extern DLL_IMPORT_RTS snEntry *stable_name_table;
extern DLL_IMPORT_RTS spEntry *stable_ptr_table;

EXTERN_INLINE
StgPtr deRefStablePtr(StgStablePtr sp)
{
    return stable_ptr_table[(StgWord)sp].addr;
}

#endif /* RTS_STABLE_H */
{-# START_FILE include/ghc-7.10.2/rts/StaticPtrTable.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2008-2009
 *
 * Initialization of the Static Pointer Table
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_STATICPTRTABLE_H
#define RTS_STATICPTRTABLE_H

/** Inserts an entry in the Static Pointer Table.
 *
 * The key is a fingerprint computed from the static pointer and the spe_closure
 * is a pointer to the closure defining the table entry.
 *
 * A stable pointer to the closure is made to prevent it from being garbage
 * collected while the entry exists on the table.
 *
 * This function is called from the code generated by
 * compiler/deSugar/StaticPtrTable.sptInitCode
 *
 * */
void hs_spt_insert (StgWord64 key[2],void* spe_closure);

/** Removes an entry from the Static Pointer Table.
 *
 * This function is called from the code generated by
 * compiler/deSugar/StaticPtrTable.sptInitCode
 *
 * */
void hs_spt_remove (StgWord64 key[2]);

#endif /* RTS_STATICPTRTABLE_H */
{-# START_FILE include/ghc-7.10.2/rts/storage/Block.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-1999
 *
 * Block structure for the storage manager
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_STORAGE_BLOCK_H
#define RTS_STORAGE_BLOCK_H

#include "ghcconfig.h"

/* The actual block and megablock-size constants are defined in
 * includes/Constants.h, all constants here are derived from these.
 */

/* Block related constants (BLOCK_SHIFT is defined in Constants.h) */

#if SIZEOF_LONG == SIZEOF_VOID_P
#define UNIT 1UL
#elif SIZEOF_LONG_LONG == SIZEOF_VOID_P
#define UNIT 1ULL
#else
#error "Size of pointer is suspicious."
#endif

#ifdef CMINUSMINUS
#define BLOCK_SIZE   (1<<BLOCK_SHIFT)
#else
#define BLOCK_SIZE   (UNIT<<BLOCK_SHIFT)
// Note [integer overflow]
#endif

#define BLOCK_SIZE_W (BLOCK_SIZE/sizeof(W_))
#define BLOCK_MASK   (BLOCK_SIZE-1)

#define BLOCK_ROUND_UP(p)   (((W_)(p)+BLOCK_SIZE-1) & ~BLOCK_MASK)
#define BLOCK_ROUND_DOWN(p) ((void *) ((W_)(p) & ~BLOCK_MASK))

/* Megablock related constants (MBLOCK_SHIFT is defined in Constants.h) */

#ifdef CMINUSMINUS
#define MBLOCK_SIZE    (1<<MBLOCK_SHIFT)
#else
#define MBLOCK_SIZE    (UNIT<<MBLOCK_SHIFT)
// Note [integer overflow]
#endif

#define MBLOCK_SIZE_W  (MBLOCK_SIZE/sizeof(W_))
#define MBLOCK_MASK    (MBLOCK_SIZE-1)

#define MBLOCK_ROUND_UP(p)   ((void *)(((W_)(p)+MBLOCK_SIZE-1) & ~MBLOCK_MASK))
#define MBLOCK_ROUND_DOWN(p) ((void *)((W_)(p) & ~MBLOCK_MASK ))

/* The largest size an object can be before we give it a block of its
 * own and treat it as an immovable object during GC, expressed as a
 * fraction of BLOCK_SIZE.
 */
#define LARGE_OBJECT_THRESHOLD ((nat)(BLOCK_SIZE * 8 / 10))

/*
 * Note [integer overflow]
 *
 * The UL suffix in BLOCK_SIZE and MBLOCK_SIZE promotes the expression
 * to an unsigned long, which means that expressions involving these
 * will be promoted to unsigned long, which makes integer overflow
 * less likely.  Historically, integer overflow in expressions like
 *    (n * BLOCK_SIZE)
 * where n is int or unsigned int, have caused obscure segfaults in
 * programs that use large amounts of memory (e.g. #7762, #5086).
 */

/* -----------------------------------------------------------------------------
 * Block descriptor.  This structure *must* be the right length, so we
 * can do pointer arithmetic on pointers to it.
 */

/* The block descriptor is 64 bytes on a 64-bit machine, and 32-bytes
 * on a 32-bit machine.
 */

// Note: fields marked with [READ ONLY] must not be modified by the
// client of the block allocator API.  All other fields can be
// freely modified.

#ifndef CMINUSMINUS
typedef struct bdescr_ {

    StgPtr start;              // [READ ONLY] start addr of memory

    StgPtr free;               // first free byte of memory.
                               // NB. during use this value should lie
                               // between start and start + blocks *
                               // BLOCK_SIZE.  Values outside this
                               // range are reserved for use by the
                               // block allocator.  In particular, the
                               // value (StgPtr)(-1) is used to
                               // indicate that a block is unallocated.

    struct bdescr_ *link;      // used for chaining blocks together

    union {
        struct bdescr_ *back;  // used (occasionally) for doubly-linked lists
        StgWord *bitmap;       // bitmap for marking GC
        StgPtr  scan;          // scan pointer for copying GC
    } u;

    struct generation_ *gen;   // generation

    StgWord16 gen_no;          // gen->no, cached
    StgWord16 dest_no;         // number of destination generation
    StgWord16 _pad1;

    StgWord16 flags;           // block flags, see below

    StgWord32 blocks;          // [READ ONLY] no. of blocks in a group
                               // (if group head, 0 otherwise)

#if SIZEOF_VOID_P == 8
    StgWord32 _padding[3];
#else
    StgWord32 _padding[0];
#endif
} bdescr;
#endif

#if SIZEOF_VOID_P == 8
#define BDESCR_SIZE  0x40
#define BDESCR_MASK  0x3f
#define BDESCR_SHIFT 6
#else
#define BDESCR_SIZE  0x20
#define BDESCR_MASK  0x1f
#define BDESCR_SHIFT 5
#endif

/* Block contains objects evacuated during this GC */
#define BF_EVACUATED 1
/* Block is a large object */
#define BF_LARGE     2
/* Block is pinned */
#define BF_PINNED    4
/* Block is to be marked, not copied */
#define BF_MARKED    8
/* Block is free, and on the free list  (TODO: is this used?) */
#define BF_FREE      16
/* Block is executable */
#define BF_EXEC      32
/* Block contains only a small amount of live data */
#define BF_FRAGMENTED 64
/* we know about this block (for finding leaks) */
#define BF_KNOWN     128
/* Block was swept in the last generation */
#define BF_SWEPT     256

/* Finding the block descriptor for a given block -------------------------- */

#ifdef CMINUSMINUS

#define Bdescr(p) \
    ((((p) &  MBLOCK_MASK & ~BLOCK_MASK) >> (BLOCK_SHIFT-BDESCR_SHIFT)) \
     | ((p) & ~MBLOCK_MASK))

#else

EXTERN_INLINE bdescr *Bdescr(StgPtr p);
EXTERN_INLINE bdescr *Bdescr(StgPtr p)
{
  return (bdescr *)
    ((((W_)p &  MBLOCK_MASK & ~BLOCK_MASK) >> (BLOCK_SHIFT-BDESCR_SHIFT))
     | ((W_)p & ~MBLOCK_MASK)
     );
}

#endif

/* Useful Macros ------------------------------------------------------------ */

/* Offset of first real data block in a megablock */

#define FIRST_BLOCK_OFF \
   ((W_)BLOCK_ROUND_UP(BDESCR_SIZE * (MBLOCK_SIZE / BLOCK_SIZE)))

/* First data block in a given megablock */

#define FIRST_BLOCK(m) ((void *)(FIRST_BLOCK_OFF + (W_)(m)))

/* Last data block in a given megablock */

#define LAST_BLOCK(m)  ((void *)(MBLOCK_SIZE-BLOCK_SIZE + (W_)(m)))

/* First real block descriptor in a megablock */

#define FIRST_BDESCR(m) \
   ((bdescr *)((FIRST_BLOCK_OFF>>(BLOCK_SHIFT-BDESCR_SHIFT)) + (W_)(m)))

/* Last real block descriptor in a megablock */

#define LAST_BDESCR(m) \
  ((bdescr *)(((MBLOCK_SIZE-BLOCK_SIZE)>>(BLOCK_SHIFT-BDESCR_SHIFT)) + (W_)(m)))

/* Number of usable blocks in a megablock */

#ifndef CMINUSMINUS // already defined in DerivedConstants.h
#define BLOCKS_PER_MBLOCK ((MBLOCK_SIZE - FIRST_BLOCK_OFF) / BLOCK_SIZE)
#endif

/* How many blocks in this megablock group */

#define MBLOCK_GROUP_BLOCKS(n) \
   (BLOCKS_PER_MBLOCK + (n-1) * (MBLOCK_SIZE / BLOCK_SIZE))

/* Compute the required size of a megablock group */

#define BLOCKS_TO_MBLOCKS(n) \
   (1 + (W_)MBLOCK_ROUND_UP((n-BLOCKS_PER_MBLOCK) * BLOCK_SIZE) / MBLOCK_SIZE)


#ifndef CMINUSMINUS
/* to the end... */

/* Double-linked block lists: --------------------------------------------- */

INLINE_HEADER void
dbl_link_onto(bdescr *bd, bdescr **list)
{
  bd->link = *list;
  bd->u.back = NULL;
  if (*list) {
    (*list)->u.back = bd; /* double-link the list */
  }
  *list = bd;
}

INLINE_HEADER void
dbl_link_remove(bdescr *bd, bdescr **list)
{
    if (bd->u.back) {
        bd->u.back->link = bd->link;
    } else {
        *list = bd->link;
    }
    if (bd->link) {
        bd->link->u.back = bd->u.back;
    }
}

INLINE_HEADER void
dbl_link_insert_after(bdescr *bd, bdescr *after)
{
    bd->link = after->link;
    bd->u.back = after;
    if (after->link) {
        after->link->u.back = bd;
    }
    after->link = bd;
}

INLINE_HEADER void
dbl_link_replace(bdescr *new_, bdescr *old, bdescr **list)
{
    new_->link = old->link;
    new_->u.back = old->u.back;
    if (old->link) {
        old->link->u.back = new_;
    }
    if (old->u.back) {
        old->u.back->link = new_;
    } else {
        *list = new_;
    }
}

/* Initialisation ---------------------------------------------------------- */

extern void initBlockAllocator(void);

/* Allocation -------------------------------------------------------------- */

bdescr *allocGroup(W_ n);
bdescr *allocBlock(void);

// versions that take the storage manager lock for you:
bdescr *allocGroup_lock(W_ n);
bdescr *allocBlock_lock(void);

/* De-Allocation ----------------------------------------------------------- */

void freeGroup(bdescr *p);
void freeChain(bdescr *p);

// versions that take the storage manager lock for you:
void freeGroup_lock(bdescr *p);
void freeChain_lock(bdescr *p);

bdescr * splitBlockGroup (bdescr *bd, nat blocks);

/* Round a value to megablocks --------------------------------------------- */

// We want to allocate an object around a given size, round it up or
// down to the nearest size that will fit in an mblock group.
INLINE_HEADER StgWord
round_to_mblocks(StgWord words)
{
    if (words > BLOCKS_PER_MBLOCK * BLOCK_SIZE_W) {
        // first, ignore the gap at the beginning of the first mblock by
        // adding it to the total words.  Then we can pretend we're
        // dealing in a uniform unit of megablocks.
        words += FIRST_BLOCK_OFF/sizeof(W_);

        if ((words % MBLOCK_SIZE_W) < (MBLOCK_SIZE_W / 2)) {
            words = (words / MBLOCK_SIZE_W) * MBLOCK_SIZE_W;
        } else {
            words = ((words / MBLOCK_SIZE_W) + 1) * MBLOCK_SIZE_W;
        }

        words -= FIRST_BLOCK_OFF/sizeof(W_);
    }
    return words;
}

INLINE_HEADER StgWord
round_up_to_mblocks(StgWord words)
{
    words += FIRST_BLOCK_OFF/sizeof(W_);
    words = ((words / MBLOCK_SIZE_W) + 1) * MBLOCK_SIZE_W;
    words -= FIRST_BLOCK_OFF/sizeof(W_);
    return words;
}

#endif /* !CMINUSMINUS */
#endif /* RTS_STORAGE_BLOCK_H */
{-# START_FILE include/ghc-7.10.2/rts/storage/ClosureMacros.h #-}
/* ----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2012
 *
 * Macros for building and manipulating closures
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_STORAGE_CLOSUREMACROS_H
#define RTS_STORAGE_CLOSUREMACROS_H

/* -----------------------------------------------------------------------------
   Info tables are slammed up against the entry code, and the label
   for the info table is at the *end* of the table itself.  This
   inline function adjusts an info pointer to point to the beginning
   of the table, so we can use standard C structure indexing on it.

   Note: this works for SRT info tables as long as you don't want to
   access the SRT, since they are laid out the same with the SRT
   pointer as the first word in the table.

   NOTES ABOUT MANGLED C VS. MINI-INTERPRETER:

   A couple of definitions:

       "info pointer"    The first word of the closure.  Might point
                         to either the end or the beginning of the
                         info table, depending on whether we're using
                         the mini interpreter or not.  GET_INFO(c)
                         retrieves the info pointer of a closure.

       "info table"      The info table structure associated with a
                         closure.  This is always a pointer to the
                         beginning of the structure, so we can
                         use standard C structure indexing to pull out
                         the fields.  get_itbl(c) returns a pointer to
                         the info table for closure c.

   An address of the form xxxx_info points to the end of the info
   table or the beginning of the info table depending on whether we're
   mangling or not respectively.  So,

         c->header.info = xxx_info

   makes absolute sense, whether mangling or not.

   -------------------------------------------------------------------------- */

INLINE_HEADER void SET_INFO(StgClosure *c, const StgInfoTable *info) {
    c->header.info = info;
}
INLINE_HEADER const StgInfoTable *GET_INFO(StgClosure *c) {
    return c->header.info;
}

#define GET_ENTRY(c)  (ENTRY_CODE(GET_INFO(c)))

#ifdef TABLES_NEXT_TO_CODE
EXTERN_INLINE StgInfoTable *INFO_PTR_TO_STRUCT(const StgInfoTable *info);
EXTERN_INLINE StgInfoTable *INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgInfoTable *)info - 1;}
EXTERN_INLINE StgRetInfoTable *RET_INFO_PTR_TO_STRUCT(const StgInfoTable *info);
EXTERN_INLINE StgRetInfoTable *RET_INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgRetInfoTable *)info - 1;}
INLINE_HEADER StgFunInfoTable *FUN_INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgFunInfoTable *)info - 1;}
INLINE_HEADER StgThunkInfoTable *THUNK_INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgThunkInfoTable *)info - 1;}
INLINE_HEADER StgConInfoTable *CON_INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgConInfoTable *)info - 1;}
INLINE_HEADER StgFunInfoTable *itbl_to_fun_itbl(const StgInfoTable *i) {return (StgFunInfoTable *)(i + 1) - 1;}
INLINE_HEADER StgRetInfoTable *itbl_to_ret_itbl(const StgInfoTable *i) {return (StgRetInfoTable *)(i + 1) - 1;}
INLINE_HEADER StgThunkInfoTable *itbl_to_thunk_itbl(const StgInfoTable *i) {return (StgThunkInfoTable *)(i + 1) - 1;}
INLINE_HEADER StgConInfoTable *itbl_to_con_itbl(const StgInfoTable *i) {return (StgConInfoTable *)(i + 1) - 1;}
#else
EXTERN_INLINE StgInfoTable *INFO_PTR_TO_STRUCT(const StgInfoTable *info);
EXTERN_INLINE StgInfoTable *INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgInfoTable *)info;}
EXTERN_INLINE StgRetInfoTable *RET_INFO_PTR_TO_STRUCT(const StgInfoTable *info);
EXTERN_INLINE StgRetInfoTable *RET_INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgRetInfoTable *)info;}
INLINE_HEADER StgFunInfoTable *FUN_INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgFunInfoTable *)info;}
INLINE_HEADER StgThunkInfoTable *THUNK_INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgThunkInfoTable *)info;}
INLINE_HEADER StgConInfoTable *CON_INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgConInfoTable *)info;}
INLINE_HEADER StgFunInfoTable *itbl_to_fun_itbl(const StgInfoTable *i) {return (StgFunInfoTable *)i;}
INLINE_HEADER StgRetInfoTable *itbl_to_ret_itbl(const StgInfoTable *i) {return (StgRetInfoTable *)i;}
INLINE_HEADER StgThunkInfoTable *itbl_to_thunk_itbl(const StgInfoTable *i) {return (StgThunkInfoTable *)i;}
INLINE_HEADER StgConInfoTable *itbl_to_con_itbl(const StgInfoTable *i) {return (StgConInfoTable *)i;}
#endif

EXTERN_INLINE StgInfoTable *get_itbl(const StgClosure *c);
EXTERN_INLINE StgInfoTable *get_itbl(const StgClosure *c) {return INFO_PTR_TO_STRUCT(c->header.info);}

EXTERN_INLINE StgRetInfoTable *get_ret_itbl(const StgClosure *c);
EXTERN_INLINE StgRetInfoTable *get_ret_itbl(const StgClosure *c) {return RET_INFO_PTR_TO_STRUCT(c->header.info);}

INLINE_HEADER StgFunInfoTable *get_fun_itbl(const StgClosure *c) {return FUN_INFO_PTR_TO_STRUCT(c->header.info);}

INLINE_HEADER StgThunkInfoTable *get_thunk_itbl(const StgClosure *c) {return THUNK_INFO_PTR_TO_STRUCT(c->header.info);}

INLINE_HEADER StgConInfoTable *get_con_itbl(const StgClosure *c) {return CON_INFO_PTR_TO_STRUCT((c)->header.info);}

INLINE_HEADER StgHalfWord GET_TAG(const StgClosure *con) {
    return get_itbl(con)->srt_bitmap;
}

/* -----------------------------------------------------------------------------
   Macros for building closures
   -------------------------------------------------------------------------- */

#ifdef PROFILING
#ifdef DEBUG_RETAINER
/*
  For the sake of debugging, we take the safest way for the moment. Actually, this
  is useful to check the sanity of heap before beginning retainer profiling.
  flip is defined in RetainerProfile.c, and declared as extern in RetainerProfile.h.
  Note: change those functions building Haskell objects from C datatypes, i.e.,
  all rts_mk???() functions in RtsAPI.c, as well.
 */
#define SET_PROF_HDR(c,ccs_)            \
        ((c)->header.prof.ccs = ccs_, (c)->header.prof.hp.rs = (retainerSet *)((StgWord)NULL | flip))
#else
/*
  For retainer profiling only: we do not have to set (c)->header.prof.hp.rs to
  NULL | flip (flip is defined in RetainerProfile.c) because even when flip
  is 1, rs is invalid and will be initialized to NULL | flip later when
  the closure *c is visited.
 */
/*
#define SET_PROF_HDR(c,ccs_)            \
        ((c)->header.prof.ccs = ccs_, (c)->header.prof.hp.rs = NULL)
 */
/*
  The following macro works for both retainer profiling and LDV profiling:
  for retainer profiling, ldvTime remains 0, so rs fields are initialized to 0.
  See the invariants on ldvTime.
 */
#define SET_PROF_HDR(c,ccs_)            \
        ((c)->header.prof.ccs = ccs_,   \
        LDV_RECORD_CREATE((c)))
#endif /* DEBUG_RETAINER */
#else
#define SET_PROF_HDR(c,ccs)
#endif

#define SET_HDR(c,_info,ccs)                            \
   {                                                    \
        (c)->header.info = _info;                       \
        SET_PROF_HDR((StgClosure *)(c),ccs);            \
   }

#define SET_ARR_HDR(c,info,costCentreStack,n_bytes)     \
   SET_HDR(c,info,costCentreStack);                     \
   (c)->bytes = n_bytes;

// Use when changing a closure from one kind to another
#define OVERWRITE_INFO(c, new_info)                             \
    OVERWRITING_CLOSURE((StgClosure *)(c));                     \
    SET_INFO((StgClosure *)(c), (new_info));                    \
    LDV_RECORD_CREATE(c);

/* -----------------------------------------------------------------------------
   How to get hold of the static link field for a static closure.
   -------------------------------------------------------------------------- */

/* These are hard-coded. */
#define FUN_STATIC_LINK(p)   (&(p)->payload[0])
#define THUNK_STATIC_LINK(p) (&(p)->payload[1])
#define IND_STATIC_LINK(p)   (&(p)->payload[1])

INLINE_HEADER StgClosure **
STATIC_LINK(const StgInfoTable *info, StgClosure *p)
{
    switch (info->type) {
    case THUNK_STATIC:
        return THUNK_STATIC_LINK(p);
    case FUN_STATIC:
        return FUN_STATIC_LINK(p);
    case IND_STATIC:
        return IND_STATIC_LINK(p);
    default:
        return &(p)->payload[info->layout.payload.ptrs +
                             info->layout.payload.nptrs];
    }
}

INLINE_HEADER StgClosure *STATIC_LINK2(const StgInfoTable *info,
                                       StgClosure *p) {
    return (*(StgClosure**)(&((p)->payload[info->layout.payload.ptrs +
                            info->layout.payload.nptrs + 1])));
}

/* -----------------------------------------------------------------------------
   INTLIKE and CHARLIKE closures.
   -------------------------------------------------------------------------- */

INLINE_HEADER P_ CHARLIKE_CLOSURE(int n) {
    return (P_)&stg_CHARLIKE_closure[(n)-MIN_CHARLIKE];
}
INLINE_HEADER P_ INTLIKE_CLOSURE(int n) {
    return (P_)&stg_INTLIKE_closure[(n)-MIN_INTLIKE];
}

/* ----------------------------------------------------------------------------
   Macros for untagging and retagging closure pointers
   For more information look at the comments in Cmm.h
   ------------------------------------------------------------------------- */

static inline StgWord
GET_CLOSURE_TAG(StgClosure * p)
{
    return (StgWord)p & TAG_MASK;
}

static inline StgClosure *
UNTAG_CLOSURE(StgClosure * p)
{
    return (StgClosure*)((StgWord)p & ~TAG_MASK);
}

static inline StgClosure *
TAG_CLOSURE(StgWord tag,StgClosure * p)
{
    return (StgClosure*)((StgWord)p | tag);
}

/* -----------------------------------------------------------------------------
   Forwarding pointers
   -------------------------------------------------------------------------- */

#define IS_FORWARDING_PTR(p) ((((StgWord)p) & 1) != 0)
#define MK_FORWARDING_PTR(p) (((StgWord)p) | 1)
#define UN_FORWARDING_PTR(p) (((StgWord)p) - 1)

/* -----------------------------------------------------------------------------
   DEBUGGING predicates for pointers

   LOOKS_LIKE_INFO_PTR(p)    returns False if p is definitely not an info ptr
   LOOKS_LIKE_CLOSURE_PTR(p) returns False if p is definitely not a closure ptr

   These macros are complete but not sound.  That is, they might
   return false positives.  Do not rely on them to distinguish info
   pointers from closure pointers, for example.

   We don't use address-space predicates these days, for portability
   reasons, and the fact that code/data can be scattered about the
   address space in a dynamically-linked environment.  Our best option
   is to look at the alleged info table and see whether it seems to
   make sense...
   -------------------------------------------------------------------------- */

INLINE_HEADER rtsBool LOOKS_LIKE_INFO_PTR_NOT_NULL (StgWord p)
{
    StgInfoTable *info = INFO_PTR_TO_STRUCT((StgInfoTable *)p);
    return (info->type != INVALID_OBJECT && info->type < N_CLOSURE_TYPES) ? rtsTrue : rtsFalse;
}

INLINE_HEADER rtsBool LOOKS_LIKE_INFO_PTR (StgWord p)
{
    return (p && (IS_FORWARDING_PTR(p) || LOOKS_LIKE_INFO_PTR_NOT_NULL(p))) ? rtsTrue : rtsFalse;
}

INLINE_HEADER rtsBool LOOKS_LIKE_CLOSURE_PTR (void *p)
{
    return LOOKS_LIKE_INFO_PTR((StgWord)(UNTAG_CLOSURE((StgClosure *)(p)))->header.info);
}

/* -----------------------------------------------------------------------------
   Macros for calculating the size of a closure
   -------------------------------------------------------------------------- */

EXTERN_INLINE StgOffset PAP_sizeW   ( nat n_args );
EXTERN_INLINE StgOffset PAP_sizeW   ( nat n_args )
{ return sizeofW(StgPAP) + n_args; }

EXTERN_INLINE StgOffset AP_sizeW   ( nat n_args );
EXTERN_INLINE StgOffset AP_sizeW   ( nat n_args )
{ return sizeofW(StgAP) + n_args; }

EXTERN_INLINE StgOffset AP_STACK_sizeW ( nat size );
EXTERN_INLINE StgOffset AP_STACK_sizeW ( nat size )
{ return sizeofW(StgAP_STACK) + size; }

EXTERN_INLINE StgOffset CONSTR_sizeW( nat p, nat np );
EXTERN_INLINE StgOffset CONSTR_sizeW( nat p, nat np )
{ return sizeofW(StgHeader) + p + np; }

EXTERN_INLINE StgOffset THUNK_SELECTOR_sizeW ( void );
EXTERN_INLINE StgOffset THUNK_SELECTOR_sizeW ( void )
{ return sizeofW(StgSelector); }

EXTERN_INLINE StgOffset BLACKHOLE_sizeW ( void );
EXTERN_INLINE StgOffset BLACKHOLE_sizeW ( void )
{ return sizeofW(StgInd); } // a BLACKHOLE is a kind of indirection

/* --------------------------------------------------------------------------
   Sizes of closures
   ------------------------------------------------------------------------*/

EXTERN_INLINE StgOffset sizeW_fromITBL( const StgInfoTable* itbl );
EXTERN_INLINE StgOffset sizeW_fromITBL( const StgInfoTable* itbl )
{ return sizeofW(StgClosure)
       + sizeofW(StgPtr)  * itbl->layout.payload.ptrs
       + sizeofW(StgWord) * itbl->layout.payload.nptrs; }

EXTERN_INLINE StgOffset thunk_sizeW_fromITBL( const StgInfoTable* itbl );
EXTERN_INLINE StgOffset thunk_sizeW_fromITBL( const StgInfoTable* itbl )
{ return sizeofW(StgThunk)
       + sizeofW(StgPtr)  * itbl->layout.payload.ptrs
       + sizeofW(StgWord) * itbl->layout.payload.nptrs; }

EXTERN_INLINE StgOffset ap_stack_sizeW( StgAP_STACK* x );
EXTERN_INLINE StgOffset ap_stack_sizeW( StgAP_STACK* x )
{ return AP_STACK_sizeW(x->size); }

EXTERN_INLINE StgOffset ap_sizeW( StgAP* x );
EXTERN_INLINE StgOffset ap_sizeW( StgAP* x )
{ return AP_sizeW(x->n_args); }

EXTERN_INLINE StgOffset pap_sizeW( StgPAP* x );
EXTERN_INLINE StgOffset pap_sizeW( StgPAP* x )
{ return PAP_sizeW(x->n_args); }

EXTERN_INLINE StgWord arr_words_words( StgArrWords* x);
EXTERN_INLINE StgWord arr_words_words( StgArrWords* x)
{ return ROUNDUP_BYTES_TO_WDS(x->bytes); }

EXTERN_INLINE StgOffset arr_words_sizeW( StgArrWords* x );
EXTERN_INLINE StgOffset arr_words_sizeW( StgArrWords* x )
{ return sizeofW(StgArrWords) + arr_words_words(x); }

EXTERN_INLINE StgOffset mut_arr_ptrs_sizeW( StgMutArrPtrs* x );
EXTERN_INLINE StgOffset mut_arr_ptrs_sizeW( StgMutArrPtrs* x )
{ return sizeofW(StgMutArrPtrs) + x->size; }

EXTERN_INLINE StgOffset small_mut_arr_ptrs_sizeW( StgSmallMutArrPtrs* x );
EXTERN_INLINE StgOffset small_mut_arr_ptrs_sizeW( StgSmallMutArrPtrs* x )
{ return sizeofW(StgSmallMutArrPtrs) + x->ptrs; }

EXTERN_INLINE StgWord stack_sizeW ( StgStack *stack );
EXTERN_INLINE StgWord stack_sizeW ( StgStack *stack )
{ return sizeofW(StgStack) + stack->stack_size; }

EXTERN_INLINE StgWord bco_sizeW ( StgBCO *bco );
EXTERN_INLINE StgWord bco_sizeW ( StgBCO *bco )
{ return bco->size; }

/*
 * TODO: Consider to switch return type from 'nat' to 'StgWord' #8742
 *
 * (Also for 'closure_sizeW' below)
 */
EXTERN_INLINE nat closure_sizeW_ (StgClosure *p, StgInfoTable *info);
EXTERN_INLINE nat
closure_sizeW_ (StgClosure *p, StgInfoTable *info)
{
    switch (info->type) {
    case THUNK_0_1:
    case THUNK_1_0:
        return sizeofW(StgThunk) + 1;
    case FUN_0_1:
    case CONSTR_0_1:
    case FUN_1_0:
    case CONSTR_1_0:
        return sizeofW(StgHeader) + 1;
    case THUNK_0_2:
    case THUNK_1_1:
    case THUNK_2_0:
        return sizeofW(StgThunk) + 2;
    case FUN_0_2:
    case CONSTR_0_2:
    case FUN_1_1:
    case CONSTR_1_1:
    case FUN_2_0:
    case CONSTR_2_0:
        return sizeofW(StgHeader) + 2;
    case THUNK:
        return thunk_sizeW_fromITBL(info);
    case THUNK_SELECTOR:
        return THUNK_SELECTOR_sizeW();
    case AP_STACK:
        return ap_stack_sizeW((StgAP_STACK *)p);
    case AP:
        return ap_sizeW((StgAP *)p);
    case PAP:
        return pap_sizeW((StgPAP *)p);
    case IND:
    case IND_PERM:
        return sizeofW(StgInd);
    case ARR_WORDS:
        return arr_words_sizeW((StgArrWords *)p);
    case MUT_ARR_PTRS_CLEAN:
    case MUT_ARR_PTRS_DIRTY:
    case MUT_ARR_PTRS_FROZEN:
    case MUT_ARR_PTRS_FROZEN0:
        return mut_arr_ptrs_sizeW((StgMutArrPtrs*)p);
    case SMALL_MUT_ARR_PTRS_CLEAN:
    case SMALL_MUT_ARR_PTRS_DIRTY:
    case SMALL_MUT_ARR_PTRS_FROZEN:
    case SMALL_MUT_ARR_PTRS_FROZEN0:
        return small_mut_arr_ptrs_sizeW((StgSmallMutArrPtrs*)p);
    case TSO:
        return sizeofW(StgTSO);
    case STACK:
        return stack_sizeW((StgStack*)p);
    case BCO:
        return bco_sizeW((StgBCO *)p);
    case TREC_CHUNK:
        return sizeofW(StgTRecChunk);
    default:
        return sizeW_fromITBL(info);
    }
}

// The definitive way to find the size, in words, of a heap-allocated closure
EXTERN_INLINE nat closure_sizeW (StgClosure *p);
EXTERN_INLINE nat closure_sizeW (StgClosure *p)
{
    return closure_sizeW_(p, get_itbl(p));
}

/* -----------------------------------------------------------------------------
   Sizes of stack frames
   -------------------------------------------------------------------------- */

EXTERN_INLINE StgWord stack_frame_sizeW( StgClosure *frame );
EXTERN_INLINE StgWord stack_frame_sizeW( StgClosure *frame )
{
    StgRetInfoTable *info;

    info = get_ret_itbl(frame);
    switch (info->i.type) {

    case RET_FUN:
        return sizeofW(StgRetFun) + ((StgRetFun *)frame)->size;

    case RET_BIG:
        return 1 + GET_LARGE_BITMAP(&info->i)->size;

    case RET_BCO:
        return 2 + BCO_BITMAP_SIZE((StgBCO *)((P_)frame)[1]);

    default:
        return 1 + BITMAP_SIZE(info->i.layout.bitmap);
    }
}

/* -----------------------------------------------------------------------------
   StgMutArrPtrs macros

   An StgMutArrPtrs has a card table to indicate which elements are
   dirty for the generational GC.  The card table is an array of
   bytes, where each byte covers (1 << MUT_ARR_PTRS_CARD_BITS)
   elements.  The card table is directly after the array data itself.
   -------------------------------------------------------------------------- */

// The number of card bytes needed
INLINE_HEADER W_ mutArrPtrsCards (W_ elems)
{
    return (W_)((elems + (1 << MUT_ARR_PTRS_CARD_BITS) - 1)
                           >> MUT_ARR_PTRS_CARD_BITS);
}

// The number of words in the card table
INLINE_HEADER W_ mutArrPtrsCardTableSize (W_ elems)
{
    return ROUNDUP_BYTES_TO_WDS(mutArrPtrsCards(elems));
}

// The address of the card for a particular card number
INLINE_HEADER StgWord8 *mutArrPtrsCard (StgMutArrPtrs *a, W_ n)
{
    return ((StgWord8 *)&(a->payload[a->ptrs]) + n);
}

/* -----------------------------------------------------------------------------
   Replacing a closure with a different one.  We must call
   OVERWRITING_CLOSURE(p) on the old closure that is about to be
   overwritten.

   Note [zeroing slop]

   In some scenarios we write zero words into "slop"; memory that is
   left unoccupied after we overwrite a closure in the heap with a
   smaller closure.

   Zeroing slop is required for:

    - full-heap sanity checks (DEBUG, and +RTS -DS)
    - LDV profiling (PROFILING, and +RTS -hb)

   Zeroing slop must be disabled for:

    - THREADED_RTS with +RTS -N2 and greater, because we cannot
      overwrite slop when another thread might be reading it.

   Hence, slop is zeroed when either:

    - PROFILING && era <= 0 (LDV is on)
    - !THREADED_RTS && DEBUG

   And additionally:

    - LDV profiling and +RTS -N2 are incompatible
    - full-heap sanity checks are disabled for THREADED_RTS

   -------------------------------------------------------------------------- */

#define ZERO_SLOP_FOR_LDV_PROF     (defined(PROFILING))
#define ZERO_SLOP_FOR_SANITY_CHECK (defined(DEBUG) && !defined(THREADED_RTS))

#if ZERO_SLOP_FOR_LDV_PROF || ZERO_SLOP_FOR_SANITY_CHECK
#define OVERWRITING_CLOSURE(c) overwritingClosure(c)
#define OVERWRITING_CLOSURE_OFS(c,n) \
    overwritingClosureOfs(c,n)
#else
#define OVERWRITING_CLOSURE(c) /* nothing */
#define OVERWRITING_CLOSURE_OFS(c,n) /* nothing */
#endif

#ifdef PROFILING
void LDV_recordDead (StgClosure *c, nat size);
#endif

EXTERN_INLINE void overwritingClosure (StgClosure *p);
EXTERN_INLINE void overwritingClosure (StgClosure *p)
{
    nat size, i;

#if ZERO_SLOP_FOR_LDV_PROF && !ZERO_SLOP_FOR_SANITY_CHECK
    // see Note [zeroing slop], also #8402
    if (era <= 0) return;
#endif

    size = closure_sizeW(p);

    // For LDV profiling, we need to record the closure as dead
#if defined(PROFILING)
    LDV_recordDead(p, size);
#endif

    for (i = 0; i < size - sizeofW(StgThunkHeader); i++) {
        ((StgThunk *)(p))->payload[i] = 0;
    }
}

// Version of 'overwritingClosure' which overwrites only a suffix of a
// closure.  The offset is expressed in words relative to 'p' and shall
// be less than or equal to closure_sizeW(p), and usually at least as
// large as the respective thunk header.
//
// Note: As this calls LDV_recordDead() you have to call LDV_RECORD()
//       on the final state of the closure at the call-site
EXTERN_INLINE void overwritingClosureOfs (StgClosure *p, nat offset);
EXTERN_INLINE void overwritingClosureOfs (StgClosure *p, nat offset)
{
    nat size, i;

#if ZERO_SLOP_FOR_LDV_PROF && !ZERO_SLOP_FOR_SANITY_CHECK
    // see Note [zeroing slop], also #8402
    if (era <= 0) return;
#endif

    size = closure_sizeW(p);

    ASSERT(offset <= size);

    // For LDV profiling, we need to record the closure as dead
#if defined(PROFILING)
    LDV_recordDead(p, size);
#endif

    for (i = offset; i < size; i++)
        ((StgWord *)p)[i] = 0;
}

#endif /* RTS_STORAGE_CLOSUREMACROS_H */
{-# START_FILE include/ghc-7.10.2/rts/storage/Closures.h #-}
/* ----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2004
 *
 * Closures
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_STORAGE_CLOSURES_H
#define RTS_STORAGE_CLOSURES_H

/*
 * The Layout of a closure header depends on which kind of system we're
 * compiling for: profiling, parallel, ticky, etc.
 */

/* -----------------------------------------------------------------------------
   The profiling header
   -------------------------------------------------------------------------- */

typedef struct {
  CostCentreStack *ccs;
  union {
    struct _RetainerSet *rs;  /* Retainer Set */
    StgWord ldvw;             /* Lag/Drag/Void Word */
  } hp;
} StgProfHeader;

/* -----------------------------------------------------------------------------
   The SMP header

   A thunk has a padding word to take the updated value.  This is so
   that the update doesn't overwrite the payload, so we can avoid
   needing to lock the thunk during entry and update.

   Note: this doesn't apply to THUNK_STATICs, which have no payload.

   Note: we leave this padding word in all ways, rather than just SMP,
   so that we don't have to recompile all our libraries for SMP.
   -------------------------------------------------------------------------- */

typedef struct {
    StgWord pad;
} StgSMPThunkHeader;

/* -----------------------------------------------------------------------------
   The full fixed-size closure header

   The size of the fixed header is the sum of the optional parts plus a single
   word for the entry code pointer.
   -------------------------------------------------------------------------- */

typedef struct {
    const StgInfoTable* info;
#ifdef PROFILING
    StgProfHeader         prof;
#endif
} StgHeader;

typedef struct {
    const StgInfoTable* info;
#ifdef PROFILING
    StgProfHeader         prof;
#endif
    StgSMPThunkHeader     smp;
} StgThunkHeader;

#define THUNK_EXTRA_HEADER_W (sizeofW(StgThunkHeader)-sizeofW(StgHeader))

/* -----------------------------------------------------------------------------
   Closure Types

   For any given closure type (defined in InfoTables.h), there is a
   corresponding structure defined below.  The name of the structure
   is obtained by concatenating the closure type with '_closure'
   -------------------------------------------------------------------------- */

/* All closures follow the generic format */

typedef struct StgClosure_ {
    StgHeader   header;
    struct StgClosure_ *payload[FLEXIBLE_ARRAY];
} *StgClosurePtr; // StgClosure defined in rts/Types.h

typedef struct {
    StgThunkHeader  header;
    struct StgClosure_ *payload[FLEXIBLE_ARRAY];
} StgThunk;

typedef struct {
    StgThunkHeader   header;
    StgClosure *selectee;
} StgSelector;

typedef struct {
    StgHeader   header;
    StgHalfWord arity;          /* zero if it is an AP */
    StgHalfWord n_args;
    StgClosure *fun;            /* really points to a fun */
    StgClosure *payload[FLEXIBLE_ARRAY];
} StgPAP;

typedef struct {
    StgThunkHeader   header;
    StgHalfWord arity;          /* zero if it is an AP */
    StgHalfWord n_args;
    StgClosure *fun;            /* really points to a fun */
    StgClosure *payload[FLEXIBLE_ARRAY];
} StgAP;

typedef struct {
    StgThunkHeader   header;
    StgWord     size;                    /* number of words in payload */
    StgClosure *fun;
    StgClosure *payload[FLEXIBLE_ARRAY]; /* contains a chunk of *stack* */
} StgAP_STACK;

typedef struct {
    StgHeader   header;
    StgClosure *indirectee;
} StgInd;

typedef struct {
    StgHeader     header;
    StgClosure   *indirectee;
    StgClosure   *static_link;
    const StgInfoTable *saved_info;
} StgIndStatic;

typedef struct StgBlockingQueue_ {
    StgHeader   header;
    struct StgBlockingQueue_ *link; // here so it looks like an IND
    StgClosure *bh;  // the BLACKHOLE
    StgTSO     *owner;
    struct MessageBlackHole_ *queue;
} StgBlockingQueue;

/* This struct should be called StgArrBytes rather than StgArrWords.
 *
 * One might be very tempted to store the number of words in the bytes field,
 * but the garbage collector will erase your data then.
 *
 * It's name is for historical reasons, see #3800
 */
typedef struct {
    StgHeader  header;
    StgWord    bytes;
    StgWord    payload[FLEXIBLE_ARRAY];
} StgArrWords; // TODO: s/StgArrWords/StgArrBytes (#8552)

typedef struct {
    StgHeader   header;
    StgWord     ptrs;
    StgWord     size; // ptrs plus card table
    StgClosure *payload[FLEXIBLE_ARRAY];
    // see also: StgMutArrPtrs macros in ClosureMacros.h
} StgMutArrPtrs;

typedef struct {
    StgHeader   header;
    StgWord     ptrs;
    StgClosure *payload[FLEXIBLE_ARRAY];
} StgSmallMutArrPtrs;

typedef struct {
    StgHeader   header;
    StgClosure *var;
} StgMutVar;

typedef struct _StgUpdateFrame {
    StgHeader  header;
    StgClosure *updatee;
} StgUpdateFrame;

typedef struct {
    StgHeader  header;
    StgWord    exceptions_blocked;
    StgClosure *handler;
} StgCatchFrame;

typedef struct {
    const StgInfoTable* info;
    struct StgStack_ *next_chunk;
} StgUnderflowFrame;

typedef struct {
    StgHeader  header;
} StgStopFrame;

typedef struct {
  StgHeader header;
  StgWord data;
} StgIntCharlikeClosure;

/* statically allocated */
typedef struct {
  StgHeader  header;
} StgRetry;

typedef struct _StgStableName {
  StgHeader      header;
  StgWord        sn;
} StgStableName;

typedef struct _StgWeak {       /* Weak v */
  StgHeader header;
  StgClosure *cfinalizers;
  StgClosure *key;
  StgClosure *value;            /* v */
  StgClosure *finalizer;
  struct _StgWeak *link;
} StgWeak;

typedef struct _StgCFinalizerList {
  StgHeader header;
  StgClosure *link;
  void (*fptr)(void);
  void *ptr;
  void *eptr;
  StgWord flag; /* has environment (0 or 1) */
} StgCFinalizerList;

/* Byte code objects.  These are fixed size objects with pointers to
 * four arrays, designed so that a BCO can be easily "re-linked" to
 * other BCOs, to facilitate GHC's intelligent recompilation.  The
 * array of instructions is static and not re-generated when the BCO
 * is re-linked, but the other 3 arrays will be regenerated.
 *
 * A BCO represents either a function or a stack frame.  In each case,
 * it needs a bitmap to describe to the garbage collector the
 * pointerhood of its arguments/free variables respectively, and in
 * the case of a function it also needs an arity.  These are stored
 * directly in the BCO, rather than in the instrs array, for two
 * reasons:
 * (a) speed: we need to get at the bitmap info quickly when
 *     the GC is examining APs and PAPs that point to this BCO
 * (b) a subtle interaction with the compacting GC.  In compacting
 *     GC, the info that describes the size/layout of a closure
 *     cannot be in an object more than one level of indirection
 *     away from the current object, because of the order in
 *     which pointers are updated to point to their new locations.
 */

typedef struct {
    StgHeader      header;
    StgArrWords   *instrs;      /* a pointer to an ArrWords */
    StgArrWords   *literals;    /* a pointer to an ArrWords */
    StgMutArrPtrs *ptrs;        /* a pointer to a  MutArrPtrs */
    StgHalfWord   arity;        /* arity of this BCO */
    StgHalfWord   size;         /* size of this BCO (in words) */
    StgWord       bitmap[FLEXIBLE_ARRAY];  /* an StgLargeBitmap */
} StgBCO;

#define BCO_BITMAP(bco)      ((StgLargeBitmap *)((StgBCO *)(bco))->bitmap)
#define BCO_BITMAP_SIZE(bco) (BCO_BITMAP(bco)->size)
#define BCO_BITMAP_BITS(bco) (BCO_BITMAP(bco)->bitmap)
#define BCO_BITMAP_SIZEW(bco) ((BCO_BITMAP_SIZE(bco) + BITS_IN(StgWord) - 1) \
                                / BITS_IN(StgWord))

/* A function return stack frame: used when saving the state for a
 * garbage collection at a function entry point.  The function
 * arguments are on the stack, and we also save the function (its
 * info table describes the pointerhood of the arguments).
 *
 * The stack frame size is also cached in the frame for convenience.
 */
typedef struct {
    const StgInfoTable* info;
    StgWord        size;
    StgClosure *   fun;
    StgClosure *   payload[FLEXIBLE_ARRAY];
} StgRetFun;

/* Concurrent communication objects */

typedef struct StgMVarTSOQueue_ {
    StgHeader                header;
    struct StgMVarTSOQueue_ *link;
    struct StgTSO_          *tso;
} StgMVarTSOQueue;

typedef struct {
    StgHeader                header;
    struct StgMVarTSOQueue_ *head;
    struct StgMVarTSOQueue_ *tail;
    StgClosure*              value;
} StgMVar;


/* STM data structures
 *
 *  StgTVar defines the only type that can be updated through the STM
 *  interface.
 *
 *  Note that various optimisations may be possible in order to use less
 *  space for these data structures at the cost of more complexity in the
 *  implementation:
 *
 *   - In StgTVar, current_value and first_watch_queue_entry could be held in
 *     the same field: if any thread is waiting then its expected_value for
 *     the tvar is the current value.
 *
 *   - In StgTRecHeader, it might be worthwhile having separate chunks
 *     of read-only and read-write locations.  This would save a
 *     new_value field in the read-only locations.
 *
 *   - In StgAtomicallyFrame, we could combine the waiting bit into
 *     the header (maybe a different info tbl for a waiting transaction).
 *     This means we can specialise the code for the atomically frame
 *     (it immediately switches on frame->waiting anyway).
 */

typedef struct StgTRecHeader_ StgTRecHeader;

typedef struct StgTVarWatchQueue_ {
  StgHeader                  header;
  StgClosure                *closure; // StgTSO or StgAtomicInvariant
  struct StgTVarWatchQueue_ *next_queue_entry;
  struct StgTVarWatchQueue_ *prev_queue_entry;
} StgTVarWatchQueue;

typedef struct {
  StgHeader                  header;
  StgClosure                *volatile current_value;
  StgTVarWatchQueue         *volatile first_watch_queue_entry;
  StgInt                     volatile num_updates;
} StgTVar;

typedef struct {
  StgHeader      header;
  StgClosure    *code;
  StgTRecHeader *last_execution;
  StgWord        lock;
} StgAtomicInvariant;

/* new_value == expected_value for read-only accesses */
/* new_value is a StgTVarWatchQueue entry when trec in state TREC_WAITING */
typedef struct {
  StgTVar                   *tvar;
  StgClosure                *expected_value;
  StgClosure                *new_value;
#if defined(THREADED_RTS)
  StgInt                     num_updates;
#endif
} TRecEntry;

#define TREC_CHUNK_NUM_ENTRIES 16

typedef struct StgTRecChunk_ {
  StgHeader                  header;
  struct StgTRecChunk_      *prev_chunk;
  StgWord                    next_entry_idx;
  TRecEntry                  entries[TREC_CHUNK_NUM_ENTRIES];
} StgTRecChunk;

typedef enum {
  TREC_ACTIVE,        /* Transaction in progress, outcome undecided */
  TREC_CONDEMNED,     /* Transaction in progress, inconsistent / out of date reads */
  TREC_COMMITTED,     /* Transaction has committed, now updating tvars */
  TREC_ABORTED,       /* Transaction has aborted, now reverting tvars */
  TREC_WAITING,       /* Transaction currently waiting */
} TRecState;

typedef struct StgInvariantCheckQueue_ {
  StgHeader                       header;
  StgAtomicInvariant             *invariant;
  StgTRecHeader                  *my_execution;
  struct StgInvariantCheckQueue_ *next_queue_entry;
} StgInvariantCheckQueue;

struct StgTRecHeader_ {
  StgHeader                  header;
  struct StgTRecHeader_     *enclosing_trec;
  StgTRecChunk              *current_chunk;
  StgInvariantCheckQueue    *invariants_to_check;
  TRecState                  state;
};

typedef struct {
  StgHeader   header;
  StgClosure *code;
  StgTVarWatchQueue *next_invariant_to_check;
  StgClosure *result;
} StgAtomicallyFrame;

typedef struct {
  StgHeader   header;
  StgClosure *code;
  StgClosure *handler;
} StgCatchSTMFrame;

typedef struct {
  StgHeader      header;
  StgWord        running_alt_code;
  StgClosure    *first_code;
  StgClosure    *alt_code;
} StgCatchRetryFrame;

/* ----------------------------------------------------------------------------
   Messages
   ------------------------------------------------------------------------- */

typedef struct Message_ {
    StgHeader        header;
    struct Message_ *link;
} Message;

typedef struct MessageWakeup_ {
    StgHeader header;
    Message  *link;
    StgTSO   *tso;
} MessageWakeup;

typedef struct MessageThrowTo_ {
    StgHeader   header;
    struct MessageThrowTo_ *link;
    StgTSO     *source;
    StgTSO     *target;
    StgClosure *exception;
} MessageThrowTo;

typedef struct MessageBlackHole_ {
    StgHeader   header;
    struct MessageBlackHole_ *link;
    StgTSO     *tso;
    StgClosure *bh;
} MessageBlackHole;

#endif /* RTS_STORAGE_CLOSURES_H */
{-# START_FILE include/ghc-7.10.2/rts/storage/ClosureTypes.h #-}
/* ----------------------------------------------------------------------------
 * 
 * (c) The GHC Team, 1998-2005
 *
 * Closure Type Constants: out here because the native code generator
 * needs to get at them.
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_STORAGE_CLOSURETYPES_H
#define RTS_STORAGE_CLOSURETYPES_H

/* 
 * WARNING WARNING WARNING
 *
 * If you add or delete any closure types, don't forget to update
 * the closure flags table in rts/ClosureFlags.c.
 */

/* Object tag 0 raises an internal error */
#define INVALID_OBJECT          0
#define CONSTR                  1
#define CONSTR_1_0              2
#define CONSTR_0_1              3
#define CONSTR_2_0              4
#define CONSTR_1_1              5
#define CONSTR_0_2              6
#define CONSTR_STATIC           7
#define CONSTR_NOCAF_STATIC     8
#define FUN                     9
#define FUN_1_0                 10
#define FUN_0_1                 11
#define FUN_2_0                 12
#define FUN_1_1                 13
#define FUN_0_2                 14
#define FUN_STATIC              15
#define THUNK                   16
#define THUNK_1_0               17
#define THUNK_0_1               18
#define THUNK_2_0               19
#define THUNK_1_1               20
#define THUNK_0_2               21
#define THUNK_STATIC            22
#define THUNK_SELECTOR          23
#define BCO                     24
#define AP                      25
#define PAP                     26
#define AP_STACK                27
#define IND                     28
#define IND_PERM                29
#define IND_STATIC              30
#define RET_BCO                 31
#define RET_SMALL               32
#define RET_BIG                 33
#define RET_FUN                 34
#define UPDATE_FRAME            35
#define CATCH_FRAME             36
#define UNDERFLOW_FRAME         37
#define STOP_FRAME              38
#define BLOCKING_QUEUE          39
#define BLACKHOLE               40
#define MVAR_CLEAN              41
#define MVAR_DIRTY              42
#define TVAR                    43
#define ARR_WORDS               44
#define MUT_ARR_PTRS_CLEAN      45
#define MUT_ARR_PTRS_DIRTY      46
#define MUT_ARR_PTRS_FROZEN0    47
#define MUT_ARR_PTRS_FROZEN     48
#define MUT_VAR_CLEAN           49
#define MUT_VAR_DIRTY           50
#define WEAK                    51
#define PRIM                    52
#define MUT_PRIM                53
#define TSO                     54
#define STACK                   55
#define TREC_CHUNK              56
#define ATOMICALLY_FRAME        57
#define CATCH_RETRY_FRAME       58
#define CATCH_STM_FRAME         59
#define WHITEHOLE               60
#define SMALL_MUT_ARR_PTRS_CLEAN      61
#define SMALL_MUT_ARR_PTRS_DIRTY      62
#define SMALL_MUT_ARR_PTRS_FROZEN0    63
#define SMALL_MUT_ARR_PTRS_FROZEN     64
#define N_CLOSURE_TYPES         65

#endif /* RTS_STORAGE_CLOSURETYPES_H */
{-# START_FILE include/ghc-7.10.2/rts/storage/FunTypes.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2002
 *
 * Things for functions.
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_STORAGE_FUNTYPES_H
#define RTS_STORAGE_FUNTYPES_H

/* generic - function comes with a small bitmap */
#define ARG_GEN      0   

/* generic - function comes with a large bitmap */
#define ARG_GEN_BIG  1

/* BCO - function is really a BCO */
#define ARG_BCO      2

/*
 * Specialised function types: bitmaps and calling sequences
 * for these functions are pre-generated: see ghc/utils/genapply and
 * generated code in ghc/rts/AutoApply.cmm.
 *
 *  NOTE: other places to change if you change this table:
 *       - utils/genapply/GenApply.hs: stackApplyTypes
 *       - compiler/codeGen/CgCallConv.lhs: stdPattern
 */
#define ARG_NONE     3 
#define ARG_N        4  
#define ARG_P        5 
#define ARG_F        6 
#define ARG_D        7 
#define ARG_L        8 
#define ARG_V16      9 
#define ARG_V32      10
#define ARG_V64      11
#define ARG_NN       12 
#define ARG_NP       13
#define ARG_PN       14
#define ARG_PP       15
#define ARG_NNN      16
#define ARG_NNP      17
#define ARG_NPN      18
#define ARG_NPP      19
#define ARG_PNN      20
#define ARG_PNP      21
#define ARG_PPN      22
#define ARG_PPP      23
#define ARG_PPPP     24
#define ARG_PPPPP    25
#define ARG_PPPPPP   26
#define ARG_PPPPPPP  27
#define ARG_PPPPPPPP 28

#endif /* RTS_STORAGE_FUNTYPES_H */
{-# START_FILE include/ghc-7.10.2/rts/storage/GC.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2004
 *
 * External Storage Manger Interface
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_STORAGE_GC_H
#define RTS_STORAGE_GC_H

#include <stddef.h>
#include "rts/OSThreads.h"

/* -----------------------------------------------------------------------------
 * Generational GC
 *
 * We support an arbitrary number of generations, with an arbitrary number
 * of steps per generation.  Notes (in no particular order):
 *
 *       - all generations except the oldest should have the same
 *         number of steps.  Multiple steps gives objects a decent
 *         chance to age before being promoted, and helps ensure that
 *         we don't end up with too many thunks being updated in older
 *         generations.
 *
 *       - the oldest generation has one step.  There's no point in aging
 *         objects in the oldest generation.
 *
 *       - generation 0, step 0 (G0S0) is the allocation area.  It is given
 *         a fixed set of blocks during initialisation, and these blocks
 *         normally stay in G0S0.  In parallel execution, each
 *         Capability has its own nursery.
 *
 *       - during garbage collection, each step which is an evacuation
 *         destination (i.e. all steps except G0S0) is allocated a to-space.
 *         evacuated objects are allocated into the step's to-space until
 *         GC is finished, when the original step's contents may be freed
 *         and replaced by the to-space.
 *
 *       - the mutable-list is per-generation (not per-step).  G0 doesn't
 *         have one (since every garbage collection collects at least G0).
 *
 *       - block descriptors contain pointers to both the step and the
 *         generation that the block belongs to, for convenience.
 *
 *       - static objects are stored in per-generation lists.  See GC.c for
 *         details of how we collect CAFs in the generational scheme.
 *
 *       - large objects are per-step, and are promoted in the same way
 *         as small objects, except that we may allocate large objects into
 *         generation 1 initially.
 *
 * ------------------------------------------------------------------------- */

// A count of blocks needs to store anything up to the size of memory
// divided by the block size.  The safest thing is therefore to use a
// type that can store the full range of memory addresses,
// ie. StgWord.  Note that we have had some tricky int overflows in a
// couple of cases caused by using ints rather than longs (e.g. #5086)

typedef StgWord memcount;

typedef struct nursery_ {
    bdescr *       blocks;
    memcount       n_blocks;
} nursery;

// Nursery invariants:
//
//  - cap->r.rNursery points to the nursery for this capability
//
//  - cap->r.rCurrentNursery points to the block in the nursery that we are
//    currently allocating into.  While in Haskell the current heap pointer is
//    in Hp, outside Haskell it is stored in cap->r.rCurrentNursery->free.
//
//  - the blocks *after* cap->rCurrentNursery in the chain are empty
//    (although their bd->free pointers have not been updated to
//    reflect that)
//
//  - the blocks *before* cap->rCurrentNursery have been used.  Except
//    for rCurrentAlloc.
//
//  - cap->r.rCurrentAlloc is either NULL, or it points to a block in
//    the nursery *before* cap->r.rCurrentNursery.
//
// See also Note [allocation accounting] to understand how total
// memory allocation is tracked.

typedef struct generation_ {
    nat            no;                  // generation number

    bdescr *       blocks;              // blocks in this gen
    memcount       n_blocks;            // number of blocks
    memcount       n_words;             // number of used words

    bdescr *       large_objects;       // large objects (doubly linked)
    memcount       n_large_blocks;      // no. of blocks used by large objs
    memcount       n_large_words;       // no. of words used by large objs
    memcount       n_new_large_words;   // words of new large objects
                                        // (for doYouWantToGC())

    memcount       max_blocks;          // max blocks

    StgTSO *       threads;             // threads in this gen
                                        // linked via global_link
    StgWeak *      weak_ptr_list;       // weak pointers in this gen

    struct generation_ *to;             // destination gen for live objects

    // stats information
    nat collections;
    nat par_collections;
    nat failed_promotions;

    // ------------------------------------
    // Fields below are used during GC only

#if defined(THREADED_RTS)
    char pad[128];                      // make sure the following is
                                        // on a separate cache line.
    SpinLock     sync;                  // lock for large_objects
                                        //    and scavenged_large_objects
#endif

    int          mark;                  // mark (not copy)? (old gen only)
    int          compact;               // compact (not sweep)? (old gen only)

    // During GC, if we are collecting this gen, blocks and n_blocks
    // are copied into the following two fields.  After GC, these blocks
    // are freed.
    bdescr *     old_blocks;            // bdescr of first from-space block
    memcount     n_old_blocks;         // number of blocks in from-space
    memcount     live_estimate;         // for sweeping: estimate of live data

    bdescr *     scavenged_large_objects;  // live large objs after GC (d-link)
    memcount     n_scavenged_large_blocks; // size (not count) of above

    bdescr *     bitmap;                // bitmap for compacting collection

    StgTSO *     old_threads;
    StgWeak *    old_weak_ptr_list;
} generation;

extern generation * generations;
extern generation * g0;
extern generation * oldest_gen;

/* -----------------------------------------------------------------------------
   Generic allocation

   StgPtr allocate(Capability *cap, W_ n)
                                Allocates memory from the nursery in
                                the current Capability.

   StgPtr allocatePinned(Capability *cap, W_ n)
                                Allocates a chunk of contiguous store
                                n words long, which is at a fixed
                                address (won't be moved by GC).
                                Returns a pointer to the first word.
                                Always succeeds.

                                NOTE: the GC can't in general handle
                                pinned objects, so allocatePinned()
                                can only be used for ByteArrays at the
                                moment.

                                Don't forget to TICK_ALLOC_XXX(...)
                                after calling allocate or
                                allocatePinned, for the
                                benefit of the ticky-ticky profiler.

   -------------------------------------------------------------------------- */

StgPtr  allocate        ( Capability *cap, W_ n );
StgPtr  allocatePinned  ( Capability *cap, W_ n );

/* memory allocator for executable memory */
typedef void* AdjustorWritable;
typedef void* AdjustorExecutable;

AdjustorWritable allocateExec(W_ len, AdjustorExecutable *exec_addr);
void flushExec(W_ len, AdjustorExecutable exec_addr);
#if defined(ios_HOST_OS)
AdjustorWritable execToWritable(AdjustorExecutable exec);
#endif
void             freeExec (AdjustorExecutable p);

// Used by GC checks in external .cmm code:
extern W_ large_alloc_lim;

/* -----------------------------------------------------------------------------
   Performing Garbage Collection
   -------------------------------------------------------------------------- */

void performGC(void);
void performMajorGC(void);

/* -----------------------------------------------------------------------------
   The CAF table - used to let us revert CAFs in GHCi
   -------------------------------------------------------------------------- */

StgInd *newCAF    (StgRegTable *reg, StgIndStatic *caf);
StgInd *newDynCAF (StgRegTable *reg, StgIndStatic *caf);
void revertCAFs (void);

// Request that all CAFs are retained indefinitely.
void setKeepCAFs (void);

/* -----------------------------------------------------------------------------
   Stats
   -------------------------------------------------------------------------- */

typedef struct _GCStats {
  StgWord64 bytes_allocated;
  StgWord64 num_gcs;
  StgWord64 num_byte_usage_samples;
  StgWord64 max_bytes_used;
  StgWord64 cumulative_bytes_used;
  StgWord64 bytes_copied;
  StgWord64 current_bytes_used;
  StgWord64 current_bytes_slop;
  StgWord64 max_bytes_slop;
  StgWord64 peak_megabytes_allocated;
  StgWord64 par_tot_bytes_copied;
  StgWord64 par_max_bytes_copied;
  StgDouble mutator_cpu_seconds;
  StgDouble mutator_wall_seconds;
  StgDouble gc_cpu_seconds;
  StgDouble gc_wall_seconds;
  StgDouble cpu_seconds;
  StgDouble wall_seconds;
} GCStats;
void getGCStats (GCStats *s);
rtsBool getGCStatsEnabled (void);

// These don't change over execution, so do them elsewhere
//  StgDouble init_cpu_seconds;
//  StgDouble init_wall_seconds;

typedef struct _ParGCStats {
  StgWord64 tot_copied;
  StgWord64 max_copied;
} ParGCStats;
void getParGCStats (ParGCStats *s);

/*
typedef struct _TaskStats {
  StgWord64 mut_time;
  StgWord64 mut_etime;
  StgWord64 gc_time;
  StgWord64 gc_etime;
} TaskStats;
// would need to allocate arbitrarily large amount of memory
// because it's a linked list of results
void getTaskStats (TaskStats **s);
// Need to stuff SparkCounters in a public header file...
void getSparkStats (SparkCounters *s);
*/

// Returns the total number of bytes allocated since the start of the program.
HsInt64 getAllocations (void);

/* -----------------------------------------------------------------------------
   This is the write barrier for MUT_VARs, a.k.a. IORefs.  A
   MUT_VAR_CLEAN object is not on the mutable list; a MUT_VAR_DIRTY
   is.  When written to, a MUT_VAR_CLEAN turns into a MUT_VAR_DIRTY
   and is put on the mutable list.
   -------------------------------------------------------------------------- */

void dirty_MUT_VAR(StgRegTable *reg, StgClosure *p);

/* set to disable CAF garbage collection in GHCi. */
/* (needed when dynamic libraries are used). */
extern rtsBool keepCAFs;

INLINE_HEADER void initBdescr(bdescr *bd, generation *gen, generation *dest)
{
    bd->gen     = gen;
    bd->gen_no  = gen->no;
    bd->dest_no = dest->no;
}

#endif /* RTS_STORAGE_GC_H */
{-# START_FILE include/ghc-7.10.2/rts/storage/InfoTables.h #-}
/* ----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2002
 *
 * Info Tables
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_STORAGE_INFOTABLES_H
#define RTS_STORAGE_INFOTABLES_H

/* ----------------------------------------------------------------------------
   Relative pointers

   Several pointer fields in info tables are expressed as offsets
   relative to the info pointer, so that we can generate
   position-independent code.

   Note [x86-64-relative]
   There is a complication on the x86_64 platform, where pointeres are
   64 bits, but the tools don't support 64-bit relative relocations.
   However, the default memory model (small) ensures that all symbols
   have values in the lower 2Gb of the address space, so offsets all
   fit in 32 bits.  Hence we can use 32-bit offset fields.

   Somewhere between binutils-2.16.1 and binutils-2.16.91.0.6,
   support for 64-bit PC-relative relocations was added, so maybe this
   hackery can go away sometime.
   ------------------------------------------------------------------------- */

#if x86_64_TARGET_ARCH
#define OFFSET_FIELD(n) StgHalfInt n; StgHalfWord __pad_##n
#else
#define OFFSET_FIELD(n) StgInt n
#endif

/* -----------------------------------------------------------------------------
   Profiling info
   -------------------------------------------------------------------------- */

typedef struct {
#ifndef TABLES_NEXT_TO_CODE
    char *closure_type;
    char *closure_desc;
#else
    OFFSET_FIELD(closure_type_off);
    OFFSET_FIELD(closure_desc_off);
#endif
} StgProfInfo;

/* -----------------------------------------------------------------------------
   Ticky info

   There is no ticky-specific stuff in an info table at this time.
   -------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
   Debugging info
   -------------------------------------------------------------------------- */

#ifdef DEBUG_CLOSURE

typedef struct {
        ... whatever ...
} StgDebugInfo;

#else /* !DEBUG_CLOSURE */

/* There is no DEBUG-specific stuff in an info table at this time. */

#endif /* DEBUG_CLOSURE */

/* -----------------------------------------------------------------------------
   Closure flags
   -------------------------------------------------------------------------- */

/* The type flags provide quick access to certain properties of a closure. */

#define _HNF (1<<0)  /* head normal form?    */
#define _BTM (1<<1)  /* uses info->layout.bitmap */
#define _NS  (1<<2)  /* non-sparkable        */
#define _STA (1<<3)  /* static?              */
#define _THU (1<<4)  /* thunk?               */
#define _MUT (1<<5)  /* mutable?             */
#define _UPT (1<<6)  /* unpointed?           */
#define _SRT (1<<7)  /* has an SRT?          */
#define _IND (1<<8)  /* is an indirection?   */

#define isSTATIC(flags)    ((flags) &_STA)
#define isMUTABLE(flags)   ((flags) &_MUT)
#define isBITMAP(flags)    ((flags) &_BTM)
#define isTHUNK(flags)     ((flags) &_THU)
#define isUNPOINTED(flags) ((flags) &_UPT)
#define hasSRT(flags)      ((flags) &_SRT)

extern StgWord16 closure_flags[];

#define closureFlags(c)         (closure_flags[get_itbl(UNTAG_CLOSURE(c))->type])

#define closure_HNF(c)          (  closureFlags(c) & _HNF)
#define closure_BITMAP(c)       (  closureFlags(c) & _BTM)
#define closure_NON_SPARK(c)    ( (closureFlags(c) & _NS))
#define closure_SHOULD_SPARK(c) (!(closureFlags(c) & _NS))
#define closure_STATIC(c)       (  closureFlags(c) & _STA)
#define closure_THUNK(c)        (  closureFlags(c) & _THU)
#define closure_MUTABLE(c)      (  closureFlags(c) & _MUT)
#define closure_UNPOINTED(c)    (  closureFlags(c) & _UPT)
#define closure_SRT(c)          (  closureFlags(c) & _SRT)
#define closure_IND(c)          (  closureFlags(c) & _IND)

/* same as above but for info-ptr rather than closure */
#define ipFlags(ip)             (closure_flags[ip->type])

#define ip_HNF(ip)               (  ipFlags(ip) & _HNF)
#define ip_BITMAP(ip)            (  ipFlags(ip) & _BTM)
#define ip_SHOULD_SPARK(ip)      (!(ipFlags(ip) & _NS))
#define ip_STATIC(ip)            (  ipFlags(ip) & _STA)
#define ip_THUNK(ip)             (  ipFlags(ip) & _THU)
#define ip_MUTABLE(ip)           (  ipFlags(ip) & _MUT)
#define ip_UNPOINTED(ip)         (  ipFlags(ip) & _UPT)
#define ip_SRT(ip)               (  ipFlags(ip) & _SRT)
#define ip_IND(ip)               (  ipFlags(ip) & _IND)

/* -----------------------------------------------------------------------------
   Bitmaps

   These are used to describe the pointerhood of a sequence of words
   (usually on the stack) to the garbage collector.  The two primary
   uses are for stack frames, and functions (where we need to describe
   the layout of a PAP to the GC).

   In these bitmaps: 0 == ptr, 1 == non-ptr.
   -------------------------------------------------------------------------- */

/*
 * Small bitmaps:  for a small bitmap, we store the size and bitmap in
 * the same word, using the following macros.  If the bitmap doesn't
 * fit in a single word, we use a pointer to an StgLargeBitmap below.
 */
#define MK_SMALL_BITMAP(size,bits) (((bits)<<BITMAP_BITS_SHIFT) | (size))

#define BITMAP_SIZE(bitmap) ((bitmap) & BITMAP_SIZE_MASK)
#define BITMAP_BITS(bitmap) ((bitmap) >> BITMAP_BITS_SHIFT)

/*
 * A large bitmap.
 */
typedef struct {
  StgWord size;
  StgWord bitmap[FLEXIBLE_ARRAY];
} StgLargeBitmap;

/* -----------------------------------------------------------------------------
   SRTs  (Static Reference Tables)

   These tables are used to keep track of the static objects referred
   to by the code for a closure or stack frame, so that we can follow
   static data references from code and thus accurately
   garbage-collect CAFs.
   -------------------------------------------------------------------------- */

/* An SRT is just an array of closure pointers: */
typedef StgClosure* StgSRT[];

/*
 * Each info table refers to some subset of the closure pointers in an
 * SRT.  It does this using a pair of an StgSRT pointer and a
 * half-word bitmap.  If the half-word bitmap isn't large enough, then
 * we fall back to a large SRT, including an unbounded bitmap.  If the
 * half-word bitmap is set to all ones (0xffff), then the StgSRT
 * pointer instead points to an StgLargeSRT:
 */
typedef struct StgLargeSRT_ {
    StgSRT *srt;
    StgLargeBitmap l;
} StgLargeSRT;

/* ----------------------------------------------------------------------------
   Info Tables
   ------------------------------------------------------------------------- */

/*
 * Stuff describing the closure layout.  Well, actually, it might
 * contain the selector index for a THUNK_SELECTOR.  This union is one
 * word long.
 */
typedef union {
    struct {                    /* Heap closure payload layout: */
        StgHalfWord ptrs;       /* number of pointers */
        StgHalfWord nptrs;      /* number of non-pointers */
    } payload;

    StgWord bitmap;               /* word-sized bit pattern describing */
                                  /*  a stack frame: see below */

#ifndef TABLES_NEXT_TO_CODE
    StgLargeBitmap* large_bitmap; /* pointer to large bitmap structure */
#else
    OFFSET_FIELD(large_bitmap_offset);  /* offset from info table to large bitmap structure */
#endif

    StgWord selector_offset;      /* used in THUNK_SELECTORs */

} StgClosureInfo;


/*
 * The "standard" part of an info table.  Every info table has this bit.
 */
typedef struct StgInfoTable_ {

#if !defined(TABLES_NEXT_TO_CODE)
    StgFunPtr       entry;      /* pointer to the entry code */
#endif

#ifdef PROFILING
    StgProfInfo     prof;
#endif
#ifdef TICKY
  /* Ticky-specific stuff would go here. */
#endif
#ifdef DEBUG_CLOSURE
  /* Debug-specific stuff would go here. */
#endif

    StgClosureInfo  layout;     /* closure layout info (one word) */

    StgHalfWord     type;       /* closure type */
    StgHalfWord     srt_bitmap;
       /* In a CONSTR:
            - the constructor tag
          In a FUN/THUNK
            - a bitmap of SRT entries
       */

#ifdef TABLES_NEXT_TO_CODE
    StgCode         code[FLEXIBLE_ARRAY];
#endif
} *StgInfoTablePtr;


/* -----------------------------------------------------------------------------
   Function info tables

   This is the general form of function info tables.  The compiler
   will omit some of the fields in common cases:

   -  If fun_type is not ARG_GEN or ARG_GEN_BIG, then the slow_apply
      and bitmap fields may be left out (they are at the end, so omitting
      them doesn't affect the layout).

   -  If srt_bitmap (in the std info table part) is zero, then the srt
      field may be omitted.  This only applies if the slow_apply and
      bitmap fields have also been omitted.
   -------------------------------------------------------------------------- */

typedef struct StgFunInfoExtraRev_ {
    OFFSET_FIELD(slow_apply_offset); /* apply to args on the stack */
    union {
        StgWord bitmap;
        OFFSET_FIELD(bitmap_offset);    /* arg ptr/nonptr bitmap */
    } b;
    OFFSET_FIELD(srt_offset);   /* pointer to the SRT table */
    StgHalfWord    fun_type;    /* function type */
    StgHalfWord    arity;       /* function arity */
} StgFunInfoExtraRev;

typedef struct StgFunInfoExtraFwd_ {
    StgHalfWord    fun_type;    /* function type */
    StgHalfWord    arity;       /* function arity */
    StgSRT         *srt;        /* pointer to the SRT table */
    union { /* union for compat. with TABLES_NEXT_TO_CODE version */
        StgWord        bitmap;  /* arg ptr/nonptr bitmap */
    } b;
    StgFun         *slow_apply; /* apply to args on the stack */
} StgFunInfoExtraFwd;

typedef struct {
#if defined(TABLES_NEXT_TO_CODE)
    StgFunInfoExtraRev f;
    StgInfoTable i;
#else
    StgInfoTable i;
    StgFunInfoExtraFwd f;
#endif
} StgFunInfoTable;

// canned bitmap for each arg type, indexed by constants in FunTypes.h
extern StgWord stg_arg_bitmaps[];

/* -----------------------------------------------------------------------------
   Return info tables
   -------------------------------------------------------------------------- */

/*
 * When info tables are laid out backwards, we can omit the SRT
 * pointer iff srt_bitmap is zero.
 */

typedef struct {
#if defined(TABLES_NEXT_TO_CODE)
    OFFSET_FIELD(srt_offset);   /* offset to the SRT table */
    StgInfoTable i;
#else
    StgInfoTable i;
    StgSRT      *srt;   /* pointer to the SRT table */
#endif
} StgRetInfoTable;

/* -----------------------------------------------------------------------------
   Thunk info tables
   -------------------------------------------------------------------------- */

/*
 * When info tables are laid out backwards, we can omit the SRT
 * pointer iff srt_bitmap is zero.
 */

typedef struct StgThunkInfoTable_ {
#if !defined(TABLES_NEXT_TO_CODE)
    StgInfoTable i;
#endif
#if defined(TABLES_NEXT_TO_CODE)
    OFFSET_FIELD(srt_offset);   /* offset to the SRT table */
#else
    StgSRT         *srt;        /* pointer to the SRT table */
#endif
#if defined(TABLES_NEXT_TO_CODE)
    StgInfoTable i;
#endif
} StgThunkInfoTable;

/* -----------------------------------------------------------------------------
   Constructor info tables
   -------------------------------------------------------------------------- */

typedef struct StgConInfoTable_ {
#if !defined(TABLES_NEXT_TO_CODE)
    StgInfoTable i;
#endif

#if defined(TABLES_NEXT_TO_CODE)
    OFFSET_FIELD(con_desc); // the name of the data constructor
                            // as: Package:Module.Name
#else
    char *con_desc;
#endif

#if defined(TABLES_NEXT_TO_CODE)
    StgInfoTable i;
#endif
} StgConInfoTable;


/* -----------------------------------------------------------------------------
   Accessor macros for fields that might be offsets (C version)
   -------------------------------------------------------------------------- */

/*
 * GET_SRT(info)
 * info must be a Stg[Ret|Thunk]InfoTable* (an info table that has a SRT)
 */
#ifdef TABLES_NEXT_TO_CODE
#define GET_SRT(info) ((StgSRT*) (((StgWord) ((info)+1)) + (info)->srt_offset))
#else
#define GET_SRT(info) ((info)->srt)
#endif

/*
 * GET_CON_DESC(info)
 * info must be a StgConInfoTable*.
 */
#ifdef TABLES_NEXT_TO_CODE
#define GET_CON_DESC(info) ((char *)((StgWord)((info)+1) + (info->con_desc)))
#else
#define GET_CON_DESC(info) ((info)->con_desc)
#endif

/*
 * GET_FUN_SRT(info)
 * info must be a StgFunInfoTable*
 */
#ifdef TABLES_NEXT_TO_CODE
#define GET_FUN_SRT(info) ((StgSRT*) (((StgWord) ((info)+1)) + (info)->f.srt_offset))
#else
#define GET_FUN_SRT(info) ((info)->f.srt)
#endif

#ifdef TABLES_NEXT_TO_CODE
#define GET_LARGE_BITMAP(info) ((StgLargeBitmap*) (((StgWord) ((info)+1)) \
                                        + (info)->layout.large_bitmap_offset))
#else
#define GET_LARGE_BITMAP(info) ((info)->layout.large_bitmap)
#endif

#ifdef TABLES_NEXT_TO_CODE
#define GET_FUN_LARGE_BITMAP(info) ((StgLargeBitmap*) (((StgWord) ((info)+1)) \
                                        + (info)->f.b.bitmap_offset))
#else
#define GET_FUN_LARGE_BITMAP(info) ((StgLargeBitmap*) ((info)->f.b.bitmap))
#endif

/*
 * GET_PROF_TYPE, GET_PROF_DESC
 */
#ifdef TABLES_NEXT_TO_CODE
#define GET_PROF_TYPE(info) ((char *)((StgWord)((info)+1) + (info->prof.closure_type_off)))
#else
#define GET_PROF_TYPE(info) ((info)->prof.closure_type)
#endif
#ifdef TABLES_NEXT_TO_CODE
#define GET_PROF_DESC(info) ((char *)((StgWord)((info)+1) + (info->prof.closure_desc_off)))
#else
#define GET_PROF_DESC(info) ((info)->prof.closure_desc)
#endif

#endif /* RTS_STORAGE_INFOTABLES_H */
{-# START_FILE include/ghc-7.10.2/rts/storage/MBlock.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2008
 *
 * MegaBlock Allocator interface.
 *
 * See wiki commentary at
 *  http://ghc.haskell.org/trac/ghc/wiki/Commentary/HeapAlloced
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_STORAGE_MBLOCK_H
#define RTS_STORAGE_MBLOCK_H

extern W_ peak_mblocks_allocated;
extern W_ mblocks_allocated;

extern void initMBlocks(void);
extern void * getMBlock(void);
extern void * getMBlocks(nat n);
extern void freeMBlocks(void *addr, nat n);
extern void freeAllMBlocks(void);

extern void *getFirstMBlock(void);
extern void *getNextMBlock(void *mblock);

#ifdef THREADED_RTS
// needed for HEAP_ALLOCED below
extern SpinLock gc_alloc_block_sync;
#endif

/* -----------------------------------------------------------------------------
   The HEAP_ALLOCED() test.

   HEAP_ALLOCED is called FOR EVERY SINGLE CLOSURE during GC.
   It needs to be FAST.

   See wiki commentary at
     http://ghc.haskell.org/trac/ghc/wiki/Commentary/HeapAlloced

   Implementation of HEAP_ALLOCED
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

   Since heap is allocated in chunks of megablocks (MBLOCK_SIZE), we
   can just use a table to record which megablocks in the address
   space belong to the heap.  On a 32-bit machine, with 1Mb
   megablocks, using 8 bits for each entry in the table, the table
   requires 4k.  Lookups during GC will be fast, because the table
   will be quickly cached (indeed, performance measurements showed no
   measurable difference between doing the table lookup and using a
   constant comparison).

   On 64-bit machines, we cache one 12-bit block map that describes
   4096 megablocks or 4GB of memory. If HEAP_ALLOCED is called for
   an address that is not in the cache, it calls slowIsHeapAlloced
   (see MBlock.c) which will find the block map for the 4GB block in
   question.
   -------------------------------------------------------------------------- */

#if SIZEOF_VOID_P == 4
extern StgWord8 mblock_map[];

/* On a 32-bit machine a 4KB table is always sufficient */
# define MBLOCK_MAP_SIZE        4096
# define MBLOCK_MAP_ENTRY(p)    ((StgWord)(p) >> MBLOCK_SHIFT)
# define HEAP_ALLOCED(p)        mblock_map[MBLOCK_MAP_ENTRY(p)]
# define HEAP_ALLOCED_GC(p)     HEAP_ALLOCED(p)

/* -----------------------------------------------------------------------------
   HEAP_ALLOCED for 64-bit machines.

 Here are some cache layout options:

 [1]
 16KB cache of 16-bit entries, 1MB lines (capacity 8GB)
  mblock size =          20 bits
  entries   =     8192   13 bits
  line size =             0 bits (1 bit of value)
  tag size  =            15 bits
                       = 48 bits

 [2]
 32KB cache of 16-bit entries, 4MB lines (capacity 32GB)
  mblock size =          20 bits
  entries   =    16384   14 bits
  line size =             2 bits (4 bits of value)
  tag size  =            12 bits
                       = 48 bits

 [3]
 16KB cache of 16-bit entries, 2MB lines (capacity 16GB)
  mblock size =          20 bits
  entries   =    8192    13 bits
  line size =             1 bits (2 bits of value)
  tag size  =            14 bits
                       = 48 bits

 [4]
 4KB cache of 32-bit entries, 16MB lines (capacity 16GB)
  mblock size =          20 bits
  entries   =     1024   10 bits
  line size =             4 bits (16 bits of value)
  tag size  =            14 bits
                       = 48 bits

 [5]
 4KB cache of 64-bit entries, 32MB lines (capacity 16GB)
  mblock size =          20 bits
  entries   =     512     9 bits
  line size =             5 bits (32 bits of value)
  tag size  =            14 bits
                       = 48 bits

 We actually use none of the above.  After much experimentation it was
 found that optimising the lookup is the most important factor,
 followed by reducing the number of misses.  To that end, we use a
 variant of [1] in which each cache entry is ((mblock << 1) + value)
 where value is 0 for non-heap and 1 for heap.  The cache entries can
 be 32 bits, since the mblock number is 48-20 = 28 bits, and we need
 1 bit for the value.  The cache can be as big as we like, but
 currently we use 8k entries, giving us 8GB capacity.

 ---------------------------------------------------------------------------- */

#elif SIZEOF_VOID_P == 8

#define MBC_LINE_BITS 0
#define MBC_TAG_BITS 15

#if x86_64_HOST_ARCH
// 32bits are enough for 'entry' as modern amd64 boxes have
// only 48bit sized virtual addres.
typedef StgWord32 MbcCacheLine;
#else
// 32bits is not enough here as some arches (like ia64) use
// upper address bits to distinct memory areas.
typedef StgWord64 MbcCacheLine;
#endif

typedef StgWord8  MBlockMapLine;

#define MBLOCK_MAP_LINE(p)  (((StgWord)p & 0xffffffff) >> (MBLOCK_SHIFT + MBC_LINE_BITS))

#define MBC_LINE_SIZE  (1<<MBC_LINE_BITS)
#define MBC_SHIFT      (48 - MBLOCK_SHIFT - MBC_LINE_BITS - MBC_TAG_BITS)
#define MBC_ENTRIES    (1<<MBC_SHIFT)

extern MbcCacheLine mblock_cache[];

#define MBC_LINE(p) ((StgWord)p >> (MBLOCK_SHIFT + MBC_LINE_BITS))

#define MBLOCK_MAP_ENTRIES  (1 << (32 - MBLOCK_SHIFT - MBC_LINE_BITS))

typedef struct {
    StgWord32    addrHigh32;
    MBlockMapLine lines[MBLOCK_MAP_ENTRIES];
} MBlockMap;

extern W_ mpc_misses;

StgBool HEAP_ALLOCED_miss(StgWord mblock, void *p);

INLINE_HEADER
StgBool HEAP_ALLOCED(void *p)
{
    StgWord mblock;
    nat entry_no;
    MbcCacheLine entry, value;

    mblock   = (StgWord)p >> MBLOCK_SHIFT;
    entry_no = mblock & (MBC_ENTRIES-1);
    entry    = mblock_cache[entry_no];
    value    = entry ^ (mblock << 1);
    // this formulation coaxes gcc into prioritising the value==1
    // case, which we expect to be the most common.
    // __builtin_expect() didn't have any useful effect (gcc-4.3.0).
    if (value == 1) {
        return 1;
    } else if (value == 0) {
        return 0;
    } else {
        // putting the rest out of line turned out to be a slight
        // performance improvement:
        return HEAP_ALLOCED_miss(mblock,p);
    }
}

// In the parallel GC, the cache itself is safe to *read*, and can be
// updated atomically, but we need to place a lock around operations
// that touch the MBlock map.
INLINE_HEADER
StgBool HEAP_ALLOCED_GC(void *p)
{
    StgWord mblock;
    nat entry_no;
    MbcCacheLine entry, value;
    StgBool b;

    mblock   = (StgWord)p >> MBLOCK_SHIFT;
    entry_no = mblock & (MBC_ENTRIES-1);
    entry    = mblock_cache[entry_no];
    value    = entry ^ (mblock << 1);
    if (value == 1) {
        return 1;
    } else if (value == 0) {
        return 0;
    } else {
        // putting the rest out of line turned out to be a slight
        // performance improvement:
        ACQUIRE_SPIN_LOCK(&gc_alloc_block_sync);
        b = HEAP_ALLOCED_miss(mblock,p);
        RELEASE_SPIN_LOCK(&gc_alloc_block_sync);
        return b;
    }
}

#else
# error HEAP_ALLOCED not defined
#endif

#endif /* RTS_STORAGE_MBLOCK_H */
{-# START_FILE include/ghc-7.10.2/rts/storage/SMPClosureOps.h #-}
/* ----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2005-2013
 *
 * Macros for THREADED_RTS support
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_STORAGE_SMPCLOSUREOPS_H
#define RTS_STORAGE_SMPCLOSUREOPS_H

#ifdef CMINUSMINUS

/* Lock closure, equivalent to ccall lockClosure but the condition is inlined.
 * Arguments are swapped for uniformity with unlockClosure. */
#if defined(THREADED_RTS)
#define LOCK_CLOSURE(closure, info)                             \
    if (CInt[n_capabilities] == 1 :: CInt) {                    \
        info = GET_INFO(closure);                               \
    } else {                                                    \
        ("ptr" info) = ccall reallyLockClosure(closure "ptr");  \
    }
#else
#define LOCK_CLOSURE(closure, info) info = GET_INFO(closure)
#endif

#define unlockClosure(ptr,info)                 \
    prim_write_barrier;                         \
    StgHeader_info(ptr) = info;

#else

INLINE_HEADER StgInfoTable *lockClosure(StgClosure *p);
EXTERN_INLINE StgInfoTable *reallyLockClosure(StgClosure *p);
EXTERN_INLINE StgInfoTable *tryLockClosure(StgClosure *p);
EXTERN_INLINE void unlockClosure(StgClosure *p, const StgInfoTable *info);

#if defined(THREADED_RTS)

/* -----------------------------------------------------------------------------
 * Locking/unlocking closures
 *
 * This is used primarily in the implementation of MVars.
 * -------------------------------------------------------------------------- */

// We want a callable copy of reallyLockClosure() so that we can refer to it
// from .cmm files compiled using the native codegen, so these are given
// EXTERN_INLINE.  C-- should use LOCK_CLOSURE not lockClosure, so we've
// kept it INLINE_HEADER.
EXTERN_INLINE StgInfoTable *reallyLockClosure(StgClosure *p)
{
    StgWord info;
    do {
        nat i = 0;
        do {
            info = xchg((P_)(void *)&p->header.info, (W_)&stg_WHITEHOLE_info);
            if (info != (W_)&stg_WHITEHOLE_info) return (StgInfoTable *)info;
        } while (++i < SPIN_COUNT);
        yieldThread();
    } while (1);
}

INLINE_HEADER StgInfoTable *lockClosure(StgClosure *p)
{
    if (n_capabilities == 1) {
        return (StgInfoTable *)p->header.info;
    }
    else {
        return reallyLockClosure(p);
    }
}

// ToDo: consider splitting tryLockClosure into reallyTryLockClosure,
// same as lockClosure
EXTERN_INLINE StgInfoTable *tryLockClosure(StgClosure *p)
{
    StgWord info;
    if (n_capabilities == 1) {
        return (StgInfoTable *)p->header.info;
    }
    else {
        info = xchg((P_)(void *)&p->header.info, (W_)&stg_WHITEHOLE_info);
        if (info != (W_)&stg_WHITEHOLE_info) {
            return (StgInfoTable *)info;
        } else {
            return NULL;
        }
    }
}

#else /* !THREADED_RTS */

EXTERN_INLINE StgInfoTable *
reallyLockClosure(StgClosure *p)
{ return (StgInfoTable *)p->header.info; }

INLINE_HEADER StgInfoTable *
lockClosure(StgClosure *p)
{ return (StgInfoTable *)p->header.info; }

EXTERN_INLINE StgInfoTable *
tryLockClosure(StgClosure *p)
{ return (StgInfoTable *)p->header.info; }

#endif /* THREADED_RTS */

EXTERN_INLINE void unlockClosure(StgClosure *p, const StgInfoTable *info)
{
    // This is a strictly ordered write, so we need a write_barrier():
    write_barrier();
    p->header.info = info;
}

// Handy specialised versions of lockClosure()/unlockClosure()
INLINE_HEADER void lockTSO(StgTSO *tso);
INLINE_HEADER void lockTSO(StgTSO *tso)
{ lockClosure((StgClosure *)tso); }

INLINE_HEADER void unlockTSO(StgTSO *tso);
INLINE_HEADER void unlockTSO(StgTSO *tso)
{ unlockClosure((StgClosure*)tso, (const StgInfoTable *)&stg_TSO_info); }

#endif /* CMINUSMINUS */

#endif /* RTS_STORAGE_SMPCLOSUREOPS_H */
{-# START_FILE include/ghc-7.10.2/rts/storage/TSO.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * The definitions for Thread State Objects.
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_STORAGE_TSO_H
#define RTS_STORAGE_TSO_H

/*
 * PROFILING info in a TSO
 */
typedef struct {
  CostCentreStack *cccs;       /* thread's current CCS */
} StgTSOProfInfo;

/*
 * There is no TICKY info in a TSO at this time.
 */

/*
 * Thread IDs are 32 bits.
 */
typedef StgWord32 StgThreadID;

#define tsoLocked(tso) ((tso)->flags & TSO_LOCKED)

/*
 * Type returned after running a thread.  Values of this type
 * include HeapOverflow, StackOverflow etc.  See Constants.h for the
 * full list.
 */
typedef unsigned int StgThreadReturnCode;

#if defined(mingw32_HOST_OS)
/* results from an async I/O request + its request ID. */
typedef struct {
  unsigned int reqID;
  int          len;
  int          errCode;
} StgAsyncIOResult;
#endif

/* Reason for thread being blocked. See comment above struct StgTso_. */
typedef union {
  StgClosure *closure;
  StgTSO *prev; // a back-link when the TSO is on the run queue (NotBlocked)
  struct MessageBlackHole_ *bh;
  struct MessageThrowTo_ *throwto;
  struct MessageWakeup_  *wakeup;
  StgInt fd;    /* StgInt instead of int, so that it's the same size as the ptrs */
#if defined(mingw32_HOST_OS)
  StgAsyncIOResult *async_result;
#endif
#if !defined(THREADED_RTS)
  StgWord target;
    // Only for the non-threaded RTS: the target time for a thread
    // blocked in threadDelay, in units of 1ms.  This is a
    // compromise: we don't want to take up much space in the TSO.  If
    // you want better resolution for threadDelay, use -threaded.
#endif
} StgTSOBlockInfo;


/*
 * TSOs live on the heap, and therefore look just like heap objects.
 * Large TSOs will live in their own "block group" allocated by the
 * storage manager, and won't be copied during garbage collection.
 */

/*
 * Threads may be blocked for several reasons.  A blocked thread will
 * have the reason in the why_blocked field of the TSO, and some
 * further info (such as the closure the thread is blocked on, or the
 * file descriptor if the thread is waiting on I/O) in the block_info
 * field.
 */

typedef struct StgTSO_ {
    StgHeader               header;

    /* The link field, for linking threads together in lists (e.g. the
       run queue on a Capability.
    */
    struct StgTSO_*         _link;
    /*
      Currently used for linking TSOs on:
      * cap->run_queue_{hd,tl}
      * (non-THREADED_RTS); the blocked_queue
      * and pointing to the next chunk for a ThreadOldStack

       NOTE!!!  do not modify _link directly, it is subject to
       a write barrier for generational GC.  Instead use the
       setTSOLink() function.  Exceptions to this rule are:

       * setting the link field to END_TSO_QUEUE
       * setting the link field of the currently running TSO, as it
         will already be dirty.
    */

    struct StgTSO_*         global_link;    // Links threads on the
                                            // generation->threads lists

    /*
     * The thread's stack
     */
    struct StgStack_       *stackobj;

    /*
     * The tso->dirty flag indicates that this TSO's stack should be
     * scanned during garbage collection.  It also indicates that this
     * TSO is on the mutable list.
     *
     * NB. The dirty flag gets a word to itself, so that it can be set
     * safely by multiple threads simultaneously (the flags field is
     * not safe for this purpose; see #3429).  It is harmless for the
     * TSO to be on the mutable list multiple times.
     *
     * tso->dirty is set by dirty_TSO(), and unset by the garbage
     * collector (only).
     */

    StgWord16               what_next;      // Values defined in Constants.h
    StgWord16               why_blocked;    // Values defined in Constants.h
    StgWord32               flags;          // Values defined in Constants.h
    StgTSOBlockInfo         block_info;
    StgThreadID             id;
    StgWord32               saved_errno;
    StgWord32               dirty;          /* non-zero => dirty */
    struct InCall_*         bound;
    struct Capability_*     cap;

    struct StgTRecHeader_ * trec;       /* STM transaction record */

    /*
     * A list of threads blocked on this TSO waiting to throw exceptions.
    */
    struct MessageThrowTo_ * blocked_exceptions;

    /*
     * A list of StgBlockingQueue objects, representing threads
     * blocked on thunks that are under evaluation by this thread.
    */
    struct StgBlockingQueue_ *bq;

    /*
     * The allocation limit for this thread, which is updated as the
     * thread allocates.  If the value drops below zero, and
     * TSO_ALLOC_LIMIT is set in flags, we raise an exception in the
     * thread, and give the thread a little more space to handle the
     * exception before we raise the exception again.
     *
     * This is an integer, because we might update it in a place where
     * it isn't convenient to raise the exception, so we want it to
     * stay negative until we get around to checking it.
     *
     * Use only PK_Int64/ASSIGN_Int64 macros to get/set the value of alloc_limit
     * in C code otherwise you will cause alignment issues on SPARC
     */
    StgInt64  alloc_limit;     /* in bytes */

    /*
     * sum of the sizes of all stack chunks (in words), used to decide
     * whether to throw the StackOverflow exception when the stack
     * overflows, or whether to just chain on another stack chunk.
     *
     * Note that this overestimates the real stack size, because each
     * chunk will have a gap at the end, of +RTS -kb<size> words.
     * This means stack overflows are not entirely accurate, because
     * the more gaps there are, the sooner the stack will run into the
     * hard +RTS -K<size> limit.
     */
    StgWord32  tot_stack_size;

#ifdef TICKY_TICKY
    /* TICKY-specific stuff would go here. */
#endif
#ifdef PROFILING
    StgTSOProfInfo prof;
#endif
#ifdef mingw32_HOST_OS
    StgWord32 saved_winerror;
#endif

} *StgTSOPtr;

typedef struct StgStack_ {
    StgHeader  header;
    StgWord32  stack_size;     // stack size in *words*
    StgWord32  dirty;          // non-zero => dirty
    StgPtr     sp;             // current stack pointer
    StgWord    stack[FLEXIBLE_ARRAY];
} StgStack;

// Calculate SpLim from a TSO (reads tso->stackobj, but no fields from
// the stackobj itself).
INLINE_HEADER StgPtr tso_SpLim (StgTSO* tso)
{
    return tso->stackobj->stack + RESERVED_STACK_WORDS;
}

/* -----------------------------------------------------------------------------
   functions
   -------------------------------------------------------------------------- */

void dirty_TSO  (Capability *cap, StgTSO *tso);
void setTSOLink (Capability *cap, StgTSO *tso, StgTSO *target);
void setTSOPrev (Capability *cap, StgTSO *tso, StgTSO *target);

void dirty_STACK (Capability *cap, StgStack *stack);

/* -----------------------------------------------------------------------------
   Invariants:

   An active thread has the following properties:

      tso->stack < tso->sp < tso->stack+tso->stack_size
      tso->stack_size <= tso->max_stack_size

      RESERVED_STACK_WORDS is large enough for any heap-check or
      stack-check failure.

      The size of the TSO struct plus the stack is either
        (a) smaller than a block, or
        (b) a multiple of BLOCK_SIZE

        tso->why_blocked       tso->block_info      location
        ----------------------------------------------------------------------
        NotBlocked             END_TSO_QUEUE        runnable_queue, or running

        BlockedOnBlackHole     the BLACKHOLE        blackhole_queue

        BlockedOnMVar          the MVAR             the MVAR's queue

        BlockedOnSTM           END_TSO_QUEUE        STM wait queue(s)
        BlockedOnSTM           STM_AWOKEN           run queue

        BlockedOnMsgThrowTo    MessageThrowTo *     TSO->blocked_exception

        BlockedOnRead          NULL                 blocked_queue
        BlockedOnWrite         NULL                 blocked_queue
        BlockedOnDelay         NULL                 blocked_queue
        BlockedOnGA            closure TSO blocks on   BQ of that closure
        BlockedOnGA_NoSend     closure TSO blocks on   BQ of that closure

      tso->link == END_TSO_QUEUE, if the thread is currently running.

   A zombie thread has the following properties:

      tso->what_next == ThreadComplete or ThreadKilled
      tso->link     ==  (could be on some queue somewhere)
      tso->sp       ==  tso->stack + tso->stack_size - 1 (i.e. top stack word)
      tso->sp[0]    ==  return value of thread, if what_next == ThreadComplete,
                        exception             , if what_next == ThreadKilled

      (tso->sp is left pointing at the top word on the stack so that
      the return value or exception will be retained by a GC).

   The 2 cases BlockedOnGA and BlockedOnGA_NoSend are needed in a GUM
   setup only. They mark a TSO that has entered a FETCH_ME or
   FETCH_ME_BQ closure, respectively; only the first TSO hitting the
   closure will send a Fetch message.
   Currently we have no separate code for blocking on an RBH; we use the
   BlockedOnBlackHole case for that.   -- HWL

 ---------------------------------------------------------------------------- */

/* this is the NIL ptr for a TSO queue (e.g. runnable queue) */
#define END_TSO_QUEUE  ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure)

#endif /* RTS_STORAGE_TSO_H */
{-# START_FILE include/ghc-7.10.2/rts/Threads.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team 1998-2009
 *
 * External API for the scheduler.  For most uses, the functions in
 * RtsAPI.h should be enough.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_THREADS_H
#define RTS_THREADS_H

#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif

//
// Creating threads
//
StgTSO *createThread (Capability *cap, W_ stack_size);

void scheduleWaitThread (/* in    */ StgTSO *tso,
                         /* out   */ HaskellObj* ret,
                         /* inout */ Capability **cap);

StgTSO *createGenThread       (Capability *cap, W_ stack_size,
                               StgClosure *closure);
StgTSO *createIOThread        (Capability *cap, W_ stack_size,
                               StgClosure *closure);
StgTSO *createStrictIOThread  (Capability *cap, W_ stack_size,
                               StgClosure *closure);

// Suspending/resuming threads around foreign calls
void *        suspendThread (StgRegTable *, rtsBool interruptible);
StgRegTable * resumeThread  (void *);

//
// Thread operations from Threads.c
//
int     cmp_thread                       (StgPtr tso1, StgPtr tso2);
int     rts_getThreadId                  (StgPtr tso);
HsInt64 rts_getThreadAllocationCounter   (StgPtr tso);
void    rts_setThreadAllocationCounter   (StgPtr tso, HsInt64 i);
void    rts_enableThreadAllocationLimit  (StgPtr tso);
void    rts_disableThreadAllocationLimit (StgPtr tso);

#if !defined(mingw32_HOST_OS)
pid_t  forkProcess     (HsStablePtr *entry);
#else
pid_t  forkProcess     (HsStablePtr *entry)
    GNU_ATTRIBUTE(__noreturn__);
#endif

HsBool rtsSupportsBoundThreads (void);

// The number of Capabilities
extern unsigned int n_capabilities;

// The number of Capabilities that are not disabled
extern nat enabled_capabilities;

#if !IN_STG_CODE
extern Capability MainCapability;
#endif

//
// Change the number of capabilities (only supports increasing the
// current value at the moment).
//
extern void setNumCapabilities (nat new_);

#endif /* RTS_THREADS_H */
{-# START_FILE include/ghc-7.10.2/rts/Ticky.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * TICKY_TICKY types
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_TICKY_H
#define RTS_TICKY_H

/* -----------------------------------------------------------------------------
   The StgEntCounter type - needed regardless of TICKY_TICKY
   -------------------------------------------------------------------------- */

typedef struct _StgEntCounter {
  /* Using StgWord for everything, because both the C and asm code
     generators make trouble if you try to pack things tighter */
    StgWord     registeredp;    /* 0 == no, 1 == yes */
    StgInt      arity;          /* arity (static info) */
    StgInt      allocd;         /* # allocation of this closure */
                                /* (rest of args are in registers) */
    char        *str;           /* name of the thing */
    char        *arg_kinds;     /* info about the args types */
    StgInt      entry_count;    /* Trips to fast entry code */
    StgInt      allocs;         /* number of allocations by this fun */
    struct _StgEntCounter *link;/* link to chain them all together */
} StgEntCounter;

#endif /* RTS_TICKY_H */
{-# START_FILE include/ghc-7.10.2/rts/Timer.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1995-2009
 *
 * Interface to the RTS timer signal (uses OS-dependent Ticker.h underneath)
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_TIMER_H
#define RTS_TIMER_H

void startTimer (void);
void stopTimer  (void);
int rtsTimerSignal (void);

#endif /* RTS_TIMER_H */
{-# START_FILE include/ghc-7.10.2/rts/TTY.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2009
 *
 * POSIX TTY-related functionality
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_TTY_H
#define RTS_TTY_H

void* __hscore_get_saved_termios(int fd);
void  __hscore_set_saved_termios(int fd, void* ts);

#endif /* RTS_TTY_H */
{-# START_FILE include/ghc-7.10.2/rts/Types.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * RTS-specific types.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_TYPES_H
#define RTS_TYPES_H

#include <stddef.h>

typedef unsigned int     nat;           /* at least 32 bits (like int) */

// Deprecated; just use StgWord instead
typedef StgWord lnat;

/* ullong (64|128-bit) type: only include if needed (not ANSI) */
#if defined(__GNUC__) 
#define LL(x) (x##LL)
#else
#define LL(x) (x##L)
#endif
  
typedef enum { 
    rtsFalse = 0, 
    rtsTrue 
} rtsBool;

typedef struct StgClosure_   StgClosure;
typedef struct StgInfoTable_ StgInfoTable;
typedef struct StgTSO_       StgTSO;

#endif /* RTS_TYPES_H */
{-# START_FILE include/ghc-7.10.2/rts/Utils.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * RTS external APIs.  This file declares everything that the GHC RTS
 * exposes externally.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_UTILS_H
#define RTS_UTILS_H

/* Alternate to raise(3) for threaded rts, for BSD-based OSes */
int genericRaise(int sig);

#endif /* RTS_UTILS_H */
{-# START_FILE include/ghc-7.10.2/Rts.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * RTS external APIs.  This file declares everything that the GHC RTS
 * exposes externally.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_H
#define RTS_H

#ifdef __cplusplus
extern "C" {
#endif

/* We include windows.h very early, as on Win64 the CONTEXT type has
   fields "R8", "R9" and "R10", which goes bad if we've already
   #define'd those names for our own purposes (in stg/Regs.h) */
#if defined(HAVE_WINDOWS_H)
#include <windows.h>
#endif

#ifndef IN_STG_CODE
#define IN_STG_CODE 0
#endif
#include "Stg.h"

#include "HsFFI.h"
#include "RtsAPI.h"

// Turn off inlining when debugging - it obfuscates things
#ifdef DEBUG
# undef  STATIC_INLINE
# define STATIC_INLINE static
#endif

#include "rts/Types.h"

#if __GNUC__ >= 3
/* Assume that a flexible array member at the end of a struct
 * can be defined thus: T arr[]; */
#define FLEXIBLE_ARRAY
#else
/* Assume that it must be defined thus: T arr[0]; */
#define FLEXIBLE_ARRAY 0
#endif

#if __GNUC__ >= 3
#define ATTRIBUTE_ALIGNED(n) __attribute__((aligned(n)))
#else
#define ATTRIBUTE_ALIGNED(n) /*nothing*/
#endif

// Symbols that are extern, but private to the RTS, are declared
// with visibility "hidden" to hide them outside the RTS shared
// library.
#if defined(HAS_VISIBILITY_HIDDEN)
#define RTS_PRIVATE  GNUC3_ATTRIBUTE(visibility("hidden"))
#else
#define RTS_PRIVATE  /* disabled: RTS_PRIVATE */
#endif

#if __GNUC__ >= 4
#define RTS_UNLIKELY(p) __builtin_expect((p),0)
#else
#define RTS_UNLIKELY(p) p
#endif

/* Fix for mingw stat problem (done here so it's early enough) */
#ifdef mingw32_HOST_OS
#define __MSVCRT__ 1
#endif

/* Needed to get the macro version of errno on some OSs, and also to
   get prototypes for the _r versions of C library functions. */
#ifndef _REENTRANT
#define _REENTRANT 1
#endif

/*
 * We often want to know the size of something in units of an
 * StgWord... (rounded up, of course!)
 */
#define ROUNDUP_BYTES_TO_WDS(n) (((n) + sizeof(W_) - 1) / sizeof(W_))

#define sizeofW(t) ROUNDUP_BYTES_TO_WDS(sizeof(t))

/* -----------------------------------------------------------------------------
   Assertions and Debuggery

   CHECK(p)   evaluates p and terminates with an error if p is false
   ASSERT(p)  like CHECK(p) if DEBUG is on, otherwise a no-op
   -------------------------------------------------------------------------- */

void _assertFail(const char *filename, unsigned int linenum)
   GNUC3_ATTRIBUTE(__noreturn__);

#define CHECK(predicate)                        \
        if (predicate)                          \
            /*null*/;                           \
        else                                    \
            _assertFail(__FILE__, __LINE__)

#define CHECKM(predicate, msg, ...)             \
        if (predicate)                          \
            /*null*/;                           \
        else                                    \
            barf(msg, ##__VA_ARGS__)

#ifndef DEBUG
#define ASSERT(predicate) /* nothing */
#define ASSERTM(predicate,msg,...) /* nothing */
#else
#define ASSERT(predicate) CHECK(predicate)
#define ASSERTM(predicate,msg,...) CHECKM(predicate,msg,##__VA_ARGS__)
#endif /* DEBUG */

/*
 * Use this on the RHS of macros which expand to nothing
 * to make sure that the macro can be used in a context which
 * demands a non-empty statement.
 */

#define doNothing() do { } while (0)

#ifdef DEBUG
#define USED_IF_DEBUG
#define USED_IF_NOT_DEBUG STG_UNUSED
#else
#define USED_IF_DEBUG STG_UNUSED
#define USED_IF_NOT_DEBUG
#endif

#ifdef THREADED_RTS
#define USED_IF_THREADS
#define USED_IF_NOT_THREADS STG_UNUSED
#else
#define USED_IF_THREADS STG_UNUSED
#define USED_IF_NOT_THREADS
#endif

#define FMT_SizeT    "zu"
#define FMT_HexSizeT "zx"

/* -----------------------------------------------------------------------------
   Time values in the RTS
   -------------------------------------------------------------------------- */

// For most time values in the RTS we use a fixed resolution of nanoseconds,
// normalising the time we get from platform-dependent APIs to this
// resolution.
#define TIME_RESOLUTION 1000000000
typedef StgInt64 Time;

#define TIME_MAX HS_INT64_MAX

#if TIME_RESOLUTION == 1000000000
// I'm being lazy, but it's awkward to define fully general versions of these
#define TimeToUS(t)      ((t) / 1000)
#define TimeToNS(t)      (t)
#define USToTime(t)      ((Time)(t) * 1000)
#define NSToTime(t)      ((Time)(t))
#else
#error Fix TimeToNS(), TimeToUS() etc.
#endif

#define SecondsToTime(t) ((Time)(t) * TIME_RESOLUTION)
#define TimeToSeconds(t) ((t) / TIME_RESOLUTION)

// Use instead of SecondsToTime() when we have a floating-point
// seconds value, to avoid truncating it.
INLINE_HEADER Time fsecondsToTime (double t)
{
    return (Time)(t * TIME_RESOLUTION);
}

/* -----------------------------------------------------------------------------
   Include everything STG-ish
   -------------------------------------------------------------------------- */

/* System headers: stdlib.h is needed so that we can use NULL.  It must
 * come after MachRegs.h, because stdlib.h might define some inline
 * functions which may only be defined after register variables have
 * been declared.
 */
#include <stdlib.h>

#include "rts/Config.h"

/* Global constaints */
#include "rts/Constants.h"

/* Profiling information */
#include "rts/prof/CCS.h"
#include "rts/prof/LDV.h"

/* Parallel information */
#include "rts/OSThreads.h"
#include "rts/SpinLock.h"

#include "rts/Messages.h"
#include "rts/Threads.h"

/* Storage format definitions */
#include "rts/storage/FunTypes.h"
#include "rts/storage/InfoTables.h"
#include "rts/storage/Closures.h"
#include "rts/storage/ClosureTypes.h"
#include "rts/storage/TSO.h"
#include "stg/MiscClosures.h" /* InfoTables, closures etc. defined in the RTS */
#include "rts/storage/SMPClosureOps.h"
#include "rts/storage/Block.h"
#include "rts/storage/ClosureMacros.h"
#include "rts/storage/MBlock.h"
#include "rts/storage/GC.h"

/* Other RTS external APIs */
#include "rts/Parallel.h"
#include "rts/Hooks.h"
#include "rts/Signals.h"
#include "rts/BlockSignals.h"
#include "rts/Hpc.h"
#include "rts/Flags.h"
#include "rts/Adjustor.h"
#include "rts/FileLock.h"
#include "rts/GetTime.h"
#include "rts/Globals.h"
#include "rts/IOManager.h"
#include "rts/Linker.h"
#include "rts/Ticky.h"
#include "rts/Timer.h"
#include "rts/Stable.h"
#include "rts/TTY.h"
#include "rts/Utils.h"
#include "rts/PrimFloat.h"
#include "rts/Main.h"
#include "rts/StaticPtrTable.h"

/* Misc stuff without a home */
DLL_IMPORT_RTS extern char **prog_argv; /* so we can get at these from Haskell */
DLL_IMPORT_RTS extern int    prog_argc;
DLL_IMPORT_RTS extern char  *prog_name;

#ifdef mingw32_HOST_OS
// We need these two from Haskell too
void getWin32ProgArgv(int *argc, wchar_t **argv[]);
void setWin32ProgArgv(int argc, wchar_t *argv[]);
#endif

void stackOverflow(StgTSO* tso);

void stg_exit(int n) GNU_ATTRIBUTE(__noreturn__);

#ifndef mingw32_HOST_OS
int stg_sig_install (int, int, void *);
#endif

/* -----------------------------------------------------------------------------
   Ways
   -------------------------------------------------------------------------- */

// Returns non-zero if the RTS is a profiling version
int rts_isProfiled(void);

// Returns non-zero if the RTS is a dynamically-linked version
int rts_isDynamic(void);

/* -----------------------------------------------------------------------------
   RTS Exit codes
   -------------------------------------------------------------------------- */

/* 255 is allegedly used by dynamic linkers to report linking failure */
#define EXIT_INTERNAL_ERROR 254
#define EXIT_DEADLOCK       253
#define EXIT_INTERRUPTED    252
#define EXIT_HEAPOVERFLOW   251
#define EXIT_KILLED         250

/* -----------------------------------------------------------------------------
   Miscellaneous garbage
   -------------------------------------------------------------------------- */

#ifdef DEBUG
#define TICK_VAR(arity) \
  extern StgInt SLOW_CALLS_##arity; \
  extern StgInt RIGHT_ARITY_##arity; \
  extern StgInt TAGGED_PTR_##arity;

extern StgInt TOTAL_CALLS;

TICK_VAR(1)
TICK_VAR(2)
#endif

/* -----------------------------------------------------------------------------
   Assertions and Debuggery
   -------------------------------------------------------------------------- */

#define IF_RTSFLAGS(c,s)  if (RtsFlags.c) { s; }

#ifdef DEBUG
#if IN_STG_CODE
#define IF_DEBUG(c,s)  if (RtsFlags[0].DebugFlags.c) { s; }
#else
#define IF_DEBUG(c,s)  if (RtsFlags.DebugFlags.c) { s; }
#endif
#else
#define IF_DEBUG(c,s)  doNothing()
#endif

#ifdef DEBUG
#define DEBUG_ONLY(s) s
#else
#define DEBUG_ONLY(s) doNothing()
#endif

#ifdef DEBUG
#define DEBUG_IS_ON   1
#else
#define DEBUG_IS_ON   0
#endif

/* -----------------------------------------------------------------------------
   Useful macros and inline functions
   -------------------------------------------------------------------------- */

#if defined(__GNUC__)
#define SUPPORTS_TYPEOF
#endif

#if defined(SUPPORTS_TYPEOF)
#define stg_min(a,b) ({typeof(a) _a = (a), _b = (b); _a <= _b ? _a : _b; })
#define stg_max(a,b) ({typeof(a) _a = (a), _b = (b); _a <= _b ? _b : _a; })
#else
#define stg_min(a,b) ((a) <= (b) ? (a) : (b))
#define stg_max(a,b) ((a) <= (b) ? (b) : (a))
#endif

/* -------------------------------------------------------------------------- */

#ifdef __cplusplus
}
#endif

#endif /* RTS_H */
{-# START_FILE include/ghc-7.10.2/RtsAPI.h #-}
/* ----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2004
 *
 * API for invoking Haskell functions via the RTS
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * --------------------------------------------------------------------------*/

#ifndef RTSAPI_H
#define RTSAPI_H

#ifdef __cplusplus
extern "C" {
#endif

#include "HsFFI.h"

/*
 * Running the scheduler
 */
typedef enum {
    NoStatus,    /* not finished yet */
    Success,     /* completed successfully */
    Killed,      /* uncaught exception */
    Interrupted, /* stopped in response to a call to interruptStgRts */
    HeapExhausted /* out of memory */
} SchedulerStatus;

typedef struct StgClosure_ *HaskellObj;

/*
 * An abstract type representing the token returned by rts_lock() and
 * used when allocating objects and threads in the RTS.
 */
typedef struct Capability_ Capability;

/*
 * The public view of a Capability: we can be sure it starts with
 * these two components (but it may have more private fields).
 */
typedef struct CapabilityPublic_ {
    StgFunTable f;
    StgRegTable r;
} CapabilityPublic;

/* ----------------------------------------------------------------------------
   RTS configuration settings, for passing to hs_init_ghc()
   ------------------------------------------------------------------------- */

typedef enum {
    RtsOptsNone,         // +RTS causes an error
    RtsOptsSafeOnly,     // safe RTS options allowed; others cause an error
    RtsOptsAll           // all RTS options allowed
  } RtsOptsEnabledEnum;

// The RtsConfig struct is passed (by value) to hs_init_ghc().  The
// reason for using a struct is extensibility: we can add more
// fields to this later without breaking existing client code.
typedef struct {
    RtsOptsEnabledEnum rts_opts_enabled;
    const char *rts_opts;
    HsBool rts_hs_main;
} RtsConfig;

// Clients should start with defaultRtsConfig and then customise it.
// Bah, I really wanted this to be a const struct value, but it seems
// you can't do that in C (it generates code).
extern const RtsConfig defaultRtsConfig;

/* ----------------------------------------------------------------------------
   Starting up and shutting down the Haskell RTS.
   ------------------------------------------------------------------------- */

/* DEPRECATED, use hs_init() or hs_init_ghc() instead  */
extern void startupHaskell         ( int argc, char *argv[],
                                     void (*init_root)(void) );

/* DEPRECATED, use hs_exit() instead  */
extern void shutdownHaskell        ( void );

/* Like hs_init(), but allows rtsopts. For more complicated usage,
 * use hs_init_ghc. */
extern void hs_init_with_rtsopts (int *argc, char **argv[]);

/*
 * GHC-specific version of hs_init() that allows specifying whether
 * +RTS ... -RTS options are allowed or not (default: only "safe"
 * options are allowed), and allows passing an option string that is
 * to be interpreted by the RTS only, not passed to the program.
 */
extern void hs_init_ghc (int *argc, char **argv[],   // program arguments
                         RtsConfig rts_config);      // RTS configuration

extern void shutdownHaskellAndExit (int exitCode, int fastExit)
    GNUC3_ATTRIBUTE(__noreturn__);

#ifndef mingw32_HOST_OS
extern void shutdownHaskellAndSignal (int sig, int fastExit)
     GNUC3_ATTRIBUTE(__noreturn__);
#endif

extern void getProgArgv            ( int *argc, char **argv[] );
extern void setProgArgv            ( int argc, char *argv[] );
extern void getFullProgArgv        ( int *argc, char **argv[] );
extern void setFullProgArgv        ( int argc, char *argv[] );
extern void freeFullProgArgv       ( void ) ;

/* exit() override */
extern void (*exitFn)(int);

/* ----------------------------------------------------------------------------
   Locking.

   You have to surround all access to the RtsAPI with these calls.
   ------------------------------------------------------------------------- */

// acquires a token which may be used to create new objects and
// evaluate them.
Capability *rts_lock (void);

// releases the token acquired with rts_lock().
void rts_unlock (Capability *token);

// If you are in a context where you know you have a current capability but
// do not know what it is, then use this to get it. Basically this only
// applies to "unsafe" foreign calls (as unsafe foreign calls are made with
// the capability held).
//
// WARNING: There is *no* guarantee this returns anything sensible (eg NULL)
// when there is no current capability.
Capability *rts_unsafeGetMyCapability (void);

/* ----------------------------------------------------------------------------
   Building Haskell objects from C datatypes.
   ------------------------------------------------------------------------- */
HaskellObj   rts_mkChar       ( Capability *, HsChar   c );
HaskellObj   rts_mkInt        ( Capability *, HsInt    i );
HaskellObj   rts_mkInt8       ( Capability *, HsInt8   i );
HaskellObj   rts_mkInt16      ( Capability *, HsInt16  i );
HaskellObj   rts_mkInt32      ( Capability *, HsInt32  i );
HaskellObj   rts_mkInt64      ( Capability *, HsInt64  i );
HaskellObj   rts_mkWord       ( Capability *, HsWord   w );
HaskellObj   rts_mkWord8      ( Capability *, HsWord8  w );
HaskellObj   rts_mkWord16     ( Capability *, HsWord16 w );
HaskellObj   rts_mkWord32     ( Capability *, HsWord32 w );
HaskellObj   rts_mkWord64     ( Capability *, HsWord64 w );
HaskellObj   rts_mkPtr        ( Capability *, HsPtr    a );
HaskellObj   rts_mkFunPtr     ( Capability *, HsFunPtr a );
HaskellObj   rts_mkFloat      ( Capability *, HsFloat  f );
HaskellObj   rts_mkDouble     ( Capability *, HsDouble f );
HaskellObj   rts_mkStablePtr  ( Capability *, HsStablePtr s );
HaskellObj   rts_mkBool       ( Capability *, HsBool   b );
HaskellObj   rts_mkString     ( Capability *, char    *s );

HaskellObj   rts_apply        ( Capability *, HaskellObj, HaskellObj );

/* ----------------------------------------------------------------------------
   Deconstructing Haskell objects
   ------------------------------------------------------------------------- */
HsChar       rts_getChar      ( HaskellObj );
HsInt        rts_getInt       ( HaskellObj );
HsInt8       rts_getInt8      ( HaskellObj );
HsInt16      rts_getInt16     ( HaskellObj );
HsInt32      rts_getInt32     ( HaskellObj );
HsInt64      rts_getInt64     ( HaskellObj );
HsWord       rts_getWord      ( HaskellObj );
HsWord8      rts_getWord8     ( HaskellObj );
HsWord16     rts_getWord16    ( HaskellObj );
HsWord32     rts_getWord32    ( HaskellObj );
HsWord64     rts_getWord64    ( HaskellObj );
HsPtr        rts_getPtr       ( HaskellObj );
HsFunPtr     rts_getFunPtr    ( HaskellObj );
HsFloat      rts_getFloat     ( HaskellObj );
HsDouble     rts_getDouble    ( HaskellObj );
HsStablePtr  rts_getStablePtr ( HaskellObj );
HsBool       rts_getBool      ( HaskellObj );

/* ----------------------------------------------------------------------------
   Evaluating Haskell expressions

   The versions ending in '_' allow you to specify an initial stack size.
   Note that these calls may cause Garbage Collection, so all HaskellObj
   references are rendered invalid by these calls.

   All of these functions take a (Capability **) - there is a
   Capability pointer both input and output.  We use an inout
   parameter because this is less error-prone for the client than a
   return value - the client could easily forget to use the return
   value, whereas incorrectly using an inout parameter will usually
   result in a type error.
   ------------------------------------------------------------------------- */

void rts_eval (/* inout */ Capability **,
               /* in    */ HaskellObj p,
               /* out */   HaskellObj *ret);

void rts_eval_ (/* inout */ Capability **,
                /* in    */ HaskellObj p,
                /* in    */ unsigned int stack_size,
                /* out   */ HaskellObj *ret);

void rts_evalIO (/* inout */ Capability **,
                 /* in    */ HaskellObj p,
                 /* out */   HaskellObj *ret);

void rts_evalStableIO (/* inout */ Capability **,
                       /* in    */ HsStablePtr s,
                       /* out */   HsStablePtr *ret);

void rts_evalLazyIO (/* inout */ Capability **,
                     /* in    */ HaskellObj p,
                     /* out */   HaskellObj *ret);

void rts_evalLazyIO_ (/* inout */ Capability **,
                      /* in    */ HaskellObj p,
                      /* in    */ unsigned int stack_size,
                      /* out   */ HaskellObj *ret);

void rts_checkSchedStatus (char* site, Capability *);

SchedulerStatus rts_getSchedStatus (Capability *cap);

/*
 * The RTS allocates some thread-local data when you make a call into
 * Haskell using one of the rts_eval() functions.  This data is not
 * normally freed until hs_exit().  If you want to free it earlier
 * than this, perhaps because the thread is about to exit, then call
 * rts_done() from the thread.
 *
 * It is safe to make more rts_eval() calls after calling rts_done(),
 * but the next one will cause allocation of the thread-local memory
 * again.
 */
void rts_done (void);

/* --------------------------------------------------------------------------
   Wrapper closures

   These are used by foreign export and foreign import "wrapper" stubs.
   ----------------------------------------------------------------------- */

// When producing Windows DLLs the we need to know which symbols are in the
//      local package/DLL vs external ones.
//
//      Note that RtsAPI.h is also included by foreign export stubs in
//      the base package itself.
//
#if defined(COMPILING_WINDOWS_DLL) && !defined(COMPILING_BASE_PACKAGE)
__declspec(dllimport) extern StgWord base_GHCziTopHandler_runIO_closure[];
__declspec(dllimport) extern StgWord base_GHCziTopHandler_runNonIO_closure[];
#else
extern StgWord base_GHCziTopHandler_runIO_closure[];
extern StgWord base_GHCziTopHandler_runNonIO_closure[];
#endif

#define runIO_closure     base_GHCziTopHandler_runIO_closure
#define runNonIO_closure  base_GHCziTopHandler_runNonIO_closure

/* ------------------------------------------------------------------------ */

#ifdef __cplusplus
}
#endif

#endif /* RTSAPI_H */
{-# START_FILE include/ghc-7.10.2/stg/DLL.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * Support for Windows DLLs.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef __STGDLL_H__
#define __STGDLL_H__ 1

#if defined(COMPILING_WINDOWS_DLL)
#  if defined(x86_64_HOST_ARCH)
#    define DLL_IMPORT_DATA_REF(x) (__imp_##x)
#    define DLL_IMPORT_DATA_VARNAME(x) *__imp_##x
#  else
#    define DLL_IMPORT_DATA_REF(x) (_imp__##x)
#    define DLL_IMPORT_DATA_VARNAME(x) *_imp__##x
#  endif
#  if __GNUC__ && !defined(__declspec)
#    define DLLIMPORT
#  else
#    define DLLIMPORT __declspec(dllimport)
#    if defined(x86_64_HOST_ARCH)
#      define DLLIMPORT_DATA(x) __imp_##x
#    else
#      define DLLIMPORT_DATA(x) _imp__##x
#    endif
#  endif
#else
#  define DLL_IMPORT_DATA_REF(x) (&(x))
#  define DLL_IMPORT_DATA_VARNAME(x) x
#  define DLLIMPORT
#endif

/* The view of the ghc/includes/ header files differ ever so
   slightly depending on whether the RTS is being compiled
   or not - so we're forced to distinguish between two.
   [oh, you want details :) : Data symbols defined by the RTS
    have to be accessed through an extra level of indirection
    when compiling generated .hc code compared to when the RTS
    sources are being processed. This is only the case when 
    using Win32 DLLs. ]
*/
#ifdef COMPILING_RTS
#define DLL_IMPORT DLLIMPORT
#define DLL_IMPORT_RTS
#define DLL_IMPORT_DATA_VAR(x) x
#else
#define DLL_IMPORT
#define DLL_IMPORT_RTS DLLIMPORT
# if defined(COMPILING_WINDOWS_DLL)
#  if defined(x86_64_HOST_ARCH)
#   define DLL_IMPORT_DATA_VAR(x) __imp_##x
#  else
#   define DLL_IMPORT_DATA_VAR(x) _imp__##x
#  endif
# else
#  define DLL_IMPORT_DATA_VAR(x) x
# endif
#endif


#ifdef COMPILING_STDLIB
#define DLL_IMPORT_STDLIB
#else
#define DLL_IMPORT_STDLIB DLLIMPORT
#endif

#endif /* __STGDLL_H__ */
{-# START_FILE include/ghc-7.10.2/stg/HaskellMachRegs.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2011
 *
 * Registers used in STG code.  Might or might not correspond to
 * actual machine registers.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef HASKELLMACHREGS_H
#define HASKELLMACHREGS_H

/*
 * Defining NO_REGS causes no global registers to be used.  NO_REGS is
 * typically defined by GHC, via a command-line option passed to gcc,
 * when the -funregisterised flag is given.
 *
 * NB. When NO_REGS is on, calling & return conventions may be
 * different.  For example, all function arguments will be passed on
 * the stack, and components of an unboxed tuple will be returned on
 * the stack rather than in registers.
 */
#ifdef NO_REGS

#define MACHREGS_NO_REGS 1

#else

#define MACHREGS_NO_REGS 0

#define MACHREGS_i386     i386_TARGET_ARCH
#define MACHREGS_x86_64   x86_64_TARGET_ARCH
#define MACHREGS_powerpc  (powerpc_TARGET_ARCH || powerpc64_TARGET_ARCH || rs6000_TARGET_ARCH)
#define MACHREGS_sparc    sparc_TARGET_ARCH
#define MACHREGS_arm      arm_TARGET_ARCH
#define MACHREGS_aarch64  aarch64_TARGET_ARCH
#define MACHREGS_darwin   darwin_TARGET_OS

#endif

#include "MachRegs.h"

#endif /* HASKELLMACHREGS_H */
{-# START_FILE include/ghc-7.10.2/stg/MachRegs.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2014
 *
 * Registers used in STG code.  Might or might not correspond to
 * actual machine registers.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef MACHREGS_H
#define MACHREGS_H

/* This file is #included into Haskell code in the compiler: #defines
 * only in here please.
 */

/*
 * Undefine these as a precaution: some of them were found to be
 * defined by system headers on ARM/Linux.
 */
#undef REG_R1
#undef REG_R2
#undef REG_R3
#undef REG_R4
#undef REG_R5
#undef REG_R6
#undef REG_R7
#undef REG_R8
#undef REG_R9
#undef REG_R10

/*
 * Defining MACHREGS_NO_REGS to 1 causes no global registers to be used.
 * MACHREGS_NO_REGS is typically controlled by NO_REGS, which is
 * typically defined by GHC, via a command-line option passed to gcc,
 * when the -funregisterised flag is given.
 *
 * NB. When MACHREGS_NO_REGS to 1, calling & return conventions may be
 * different.  For example, all function arguments will be passed on
 * the stack, and components of an unboxed tuple will be returned on
 * the stack rather than in registers.
 */
#if MACHREGS_NO_REGS == 1

/* Nothing */

#elif MACHREGS_NO_REGS == 0

/* ----------------------------------------------------------------------------
   Caller saves and callee-saves regs.

   Caller-saves regs have to be saved around C-calls made from STG
   land, so this file defines CALLER_SAVES_<reg> for each <reg> that
   is designated caller-saves in that machine's C calling convention.

   As it stands, the only registers that are ever marked caller saves
   are the RX, FX, DX and USER registers; as a result, if you
   decide to caller save a system register (e.g. SP, HP, etc), note that
   this code path is completely untested! -- EZY
   -------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
   The x86 register mapping

   Ok, we've only got 6 general purpose registers, a frame pointer and a
   stack pointer.  \tr{%eax} and \tr{%edx} are return values from C functions,
   hence they get trashed across ccalls and are caller saves. \tr{%ebx},
   \tr{%esi}, \tr{%edi}, \tr{%ebp} are all callee-saves.

   Reg     STG-Reg
   ---------------
   ebx     Base
   ebp     Sp
   esi     R1
   edi     Hp

   Leaving SpLim out of the picture.
   -------------------------------------------------------------------------- */

#if MACHREGS_i386

#define REG(x) __asm__("%" #x)

#ifndef not_doing_dynamic_linking
#define REG_Base    ebx
#endif
#define REG_Sp      ebp

#ifndef STOLEN_X86_REGS
#define STOLEN_X86_REGS 4
#endif

#if STOLEN_X86_REGS >= 3
# define REG_R1     esi
#endif

#if STOLEN_X86_REGS >= 4
# define REG_Hp     edi
#endif

#define REG_XMM1    xmm0
#define REG_XMM2    xmm1
#define REG_XMM3    xmm2
#define REG_XMM4    xmm3

#define REG_YMM1    ymm0
#define REG_YMM2    ymm1
#define REG_YMM3    ymm2
#define REG_YMM4    ymm3

#define REG_ZMM1    zmm0
#define REG_ZMM2    zmm1
#define REG_ZMM3    zmm2
#define REG_ZMM4    zmm3

#define MAX_REAL_VANILLA_REG 1  /* always, since it defines the entry conv */
#define MAX_REAL_FLOAT_REG   0
#define MAX_REAL_DOUBLE_REG  0
#define MAX_REAL_LONG_REG    0
#define MAX_REAL_XMM_REG     4
#define MAX_REAL_YMM_REG     4
#define MAX_REAL_ZMM_REG     4

/* -----------------------------------------------------------------------------
  The x86-64 register mapping

  %rax          caller-saves, don't steal this one
  %rbx          YES
  %rcx          arg reg, caller-saves
  %rdx          arg reg, caller-saves
  %rsi          arg reg, caller-saves
  %rdi          arg reg, caller-saves
  %rbp          YES (our *prime* register)
  %rsp          (unavailable - stack pointer)
  %r8           arg reg, caller-saves
  %r9           arg reg, caller-saves
  %r10          caller-saves
  %r11          caller-saves
  %r12          YES
  %r13          YES
  %r14          YES
  %r15          YES

  %xmm0-7       arg regs, caller-saves
  %xmm8-15      caller-saves

  Use the caller-saves regs for Rn, because we don't always have to
  save those (as opposed to Sp/Hp/SpLim etc. which always have to be
  saved).

  --------------------------------------------------------------------------- */

#elif MACHREGS_x86_64

#define REG(x) __asm__("%" #x)

#define REG_Base  r13
#define REG_Sp    rbp
#define REG_Hp    r12
#define REG_R1    rbx
#define REG_R2    r14
#define REG_R3    rsi
#define REG_R4    rdi
#define REG_R5    r8
#define REG_R6    r9
#define REG_SpLim r15

/*
Map both Fn and Dn to register xmmn so that we can pass a function any
combination of up to six Float# or Double# arguments without touching
the stack. See Note [Overlapping global registers] for implications.
*/

#define REG_F1    xmm1
#define REG_F2    xmm2
#define REG_F3    xmm3
#define REG_F4    xmm4
#define REG_F5    xmm5
#define REG_F6    xmm6

#define REG_D1    xmm1
#define REG_D2    xmm2
#define REG_D3    xmm3
#define REG_D4    xmm4
#define REG_D5    xmm5
#define REG_D6    xmm6

#define REG_XMM1    xmm1
#define REG_XMM2    xmm2
#define REG_XMM3    xmm3
#define REG_XMM4    xmm4
#define REG_XMM5    xmm5
#define REG_XMM6    xmm6

#define REG_YMM1    ymm1
#define REG_YMM2    ymm2
#define REG_YMM3    ymm3
#define REG_YMM4    ymm4
#define REG_YMM5    ymm5
#define REG_YMM6    ymm6

#define REG_ZMM1    zmm1
#define REG_ZMM2    zmm2
#define REG_ZMM3    zmm3
#define REG_ZMM4    zmm4
#define REG_ZMM5    zmm5
#define REG_ZMM6    zmm6

#if !defined(mingw32_HOST_OS)
#define CALLER_SAVES_R3
#define CALLER_SAVES_R4
#endif
#define CALLER_SAVES_R5
#define CALLER_SAVES_R6

#define CALLER_SAVES_F1
#define CALLER_SAVES_F2
#define CALLER_SAVES_F3
#define CALLER_SAVES_F4
#define CALLER_SAVES_F5
#if !defined(mingw32_HOST_OS)
#define CALLER_SAVES_F6
#endif

#define CALLER_SAVES_D1
#define CALLER_SAVES_D2
#define CALLER_SAVES_D3
#define CALLER_SAVES_D4
#define CALLER_SAVES_D5
#if !defined(mingw32_HOST_OS)
#define CALLER_SAVES_D6
#endif

#define CALLER_SAVES_XMM1
#define CALLER_SAVES_XMM2
#define CALLER_SAVES_XMM3
#define CALLER_SAVES_XMM4
#define CALLER_SAVES_XMM5
#if !defined(mingw32_HOST_OS)
#define CALLER_SAVES_XMM6
#endif

#define CALLER_SAVES_YMM1
#define CALLER_SAVES_YMM2
#define CALLER_SAVES_YMM3
#define CALLER_SAVES_YMM4
#define CALLER_SAVES_YMM5
#if !defined(mingw32_HOST_OS)
#define CALLER_SAVES_YMM6
#endif

#define CALLER_SAVES_ZMM1
#define CALLER_SAVES_ZMM2
#define CALLER_SAVES_ZMM3
#define CALLER_SAVES_ZMM4
#define CALLER_SAVES_ZMM5
#if !defined(mingw32_HOST_OS)
#define CALLER_SAVES_ZMM6
#endif

#define MAX_REAL_VANILLA_REG 6
#define MAX_REAL_FLOAT_REG   6
#define MAX_REAL_DOUBLE_REG  6
#define MAX_REAL_LONG_REG    0
#define MAX_REAL_XMM_REG     6
#define MAX_REAL_YMM_REG     6
#define MAX_REAL_ZMM_REG     6

/* -----------------------------------------------------------------------------
   The PowerPC register mapping

   0            system glue?    (caller-save, volatile)
   1            SP              (callee-save, non-volatile)
   2            AIX, powerpc64-linux:
                    RTOC        (a strange special case)
                darwin:
                                (caller-save, volatile)
                powerpc32-linux:
                                reserved for use by system

   3-10         args/return     (caller-save, volatile)
   11,12        system glue?    (caller-save, volatile)
   13           on 64-bit:      reserved for thread state pointer
                on 32-bit:      (callee-save, non-volatile)
   14-31                        (callee-save, non-volatile)

   f0                           (caller-save, volatile)
   f1-f13       args/return     (caller-save, volatile)
   f14-f31                      (callee-save, non-volatile)

   \tr{14}--\tr{31} are wonderful callee-save registers on all ppc OSes.
   \tr{0}--\tr{12} are caller-save registers.

   \tr{%f14}--\tr{%f31} are callee-save floating-point registers.

   We can do the Whole Business with callee-save registers only!
   -------------------------------------------------------------------------- */

#elif MACHREGS_powerpc

#define REG(x) __asm__(#x)

#define REG_R1          r14
#define REG_R2          r15
#define REG_R3          r16
#define REG_R4          r17
#define REG_R5          r18
#define REG_R6          r19
#define REG_R7          r20
#define REG_R8          r21

#if MACHREGS_darwin

#define REG_F1          f14
#define REG_F2          f15
#define REG_F3          f16
#define REG_F4          f17

#define REG_D1          f18
#define REG_D2          f19

#else

#define REG_F1          fr14
#define REG_F2          fr15
#define REG_F3          fr16
#define REG_F4          fr17

#define REG_D1          fr18
#define REG_D2          fr19

#endif

#define REG_Sp          r22
#define REG_SpLim       r24

#define REG_Hp          r25

#define REG_Base        r27

/* -----------------------------------------------------------------------------
   The Sun SPARC register mapping

   !! IMPORTANT: if you change this register mapping you must also update
                 compiler/nativeGen/SPARC/Regs.hs. That file handles the
                 mapping for the NCG. This one only affects via-c code.

   The SPARC register (window) story: Remember, within the Haskell
   Threaded World, we essentially ``shut down'' the register-window
   mechanism---the window doesn't move at all while in this World.  It
   *does* move, of course, if we call out to arbitrary~C...

   The %i, %l, and %o registers (8 each) are the input, local, and
   output registers visible in one register window.  The 8 %g (global)
   registers are visible all the time.

      zero: always zero
   scratch: volatile across C-fn calls. used by linker.
       app: usable by application
    system: reserved for system

     alloc: allocated to in the register allocator, intra-closure only

                GHC usage     v8 ABI        v9 ABI
   Global
     %g0        zero        zero          zero
     %g1        alloc       scratch       scrach
     %g2        alloc       app           app
     %g3        alloc       app           app
     %g4        alloc       app           scratch
     %g5                    system        scratch
     %g6                    system        system
     %g7                    system        system

   Output: can be zapped by callee
     %o0-o5     alloc       caller saves
     %o6                    C stack ptr
     %o7                    C ret addr

   Local: maintained by register windowing mechanism
     %l0        alloc
     %l1        R1
     %l2        R2
     %l3        R3
     %l4        R4
     %l5        R5
     %l6        alloc
     %l7        alloc

   Input
     %i0        Sp
     %i1        Base
     %i2        SpLim
     %i3        Hp
     %i4        alloc
     %i5        R6
     %i6                    C frame ptr
     %i7                    C ret addr

   The paired nature of the floating point registers causes complications for
   the native code generator.  For convenience, we pretend that the first 22
   fp regs %f0 .. %f21 are actually 11 double regs, and the remaining 10 are
   float (single) regs.  The NCG acts accordingly.  That means that the
   following FP assignment is rather fragile, and should only be changed
   with extreme care.  The current scheme is:

      %f0 /%f1    FP return from C
      %f2 /%f3    D1
      %f4 /%f5    D2
      %f6 /%f7    ncg double spill tmp #1
      %f8 /%f9    ncg double spill tmp #2
      %f10/%f11   allocatable
      %f12/%f13   allocatable
      %f14/%f15   allocatable
      %f16/%f17   allocatable
      %f18/%f19   allocatable
      %f20/%f21   allocatable

      %f22        F1
      %f23        F2
      %f24        F3
      %f25        F4
      %f26        ncg single spill tmp #1
      %f27        ncg single spill tmp #2
      %f28        allocatable
      %f29        allocatable
      %f30        allocatable
      %f31        allocatable

   -------------------------------------------------------------------------- */

#elif MACHREGS_sparc

#define REG(x) __asm__("%" #x)

#define CALLER_SAVES_USER

#define CALLER_SAVES_F1
#define CALLER_SAVES_F2
#define CALLER_SAVES_F3
#define CALLER_SAVES_F4
#define CALLER_SAVES_D1
#define CALLER_SAVES_D2

#define REG_R1          l1
#define REG_R2          l2
#define REG_R3          l3
#define REG_R4          l4
#define REG_R5          l5
#define REG_R6          i5

#define REG_F1          f22
#define REG_F2          f23
#define REG_F3          f24
#define REG_F4          f25

/* for each of the double arg regs,
   Dn_2 is the high half. */

#define REG_D1          f2
#define REG_D1_2        f3

#define REG_D2          f4
#define REG_D2_2        f5

#define REG_Sp          i0
#define REG_SpLim       i2

#define REG_Hp          i3

#define REG_Base        i1

#define NCG_FirstFloatReg f22

/* -----------------------------------------------------------------------------
   The ARM EABI register mapping

   Here we consider ARM mode (i.e. 32bit isns)
   and also CPU with full VFPv3 implementation

   ARM registers (see Chapter 5.1 in ARM IHI 0042D)

   r15  PC         The Program Counter.
   r14  LR         The Link Register.
   r13  SP         The Stack Pointer.
   r12  IP         The Intra-Procedure-call scratch register.
   r11  v8         Variable-register 8.
   r10  v7         Variable-register 7.
   r9   v6/SB/TR   Platform register. The meaning of this register is
                   defined by the platform standard.
   r8   v5         Variable-register 5.
   r7   v4         Variable register 4.
   r6   v3         Variable register 3.
   r5   v2         Variable register 2.
   r4   v1         Variable register 1.
   r3   a4         Argument / scratch register 4.
   r2   a3         Argument / scratch register 3.
   r1   a2         Argument / result / scratch register 2.
   r0   a1         Argument / result / scratch register 1.

   VFPv2/VFPv3/NEON registers
   s0-s15/d0-d7/q0-q3    Argument / result/ scratch registers
   s16-s31/d8-d15/q4-q7  callee-saved registers (must be preserved across
                         subrutine calls)

   VFPv3/NEON registers (added to the VFPv2 registers set)
   d16-d31/q8-q15        Argument / result/ scratch registers
   ----------------------------------------------------------------------------- */

#elif MACHREGS_arm

#define REG(x) __asm__(#x)

#define REG_Base        r4
#define REG_Sp          r5
#define REG_Hp          r6
#define REG_R1          r7
#define REG_R2          r8
#define REG_R3          r9
#define REG_R4          r10
#define REG_SpLim       r11

#if !defined(arm_HOST_ARCH_PRE_ARMv6)
/* d8 */
#define REG_F1    s16
#define REG_F2    s17
/* d9 */
#define REG_F3    s18
#define REG_F4    s19

#define REG_D1    d10
#define REG_D2    d11
#endif

/* -----------------------------------------------------------------------------
   The ARMv8/AArch64 ABI register mapping

   The AArch64 provides 31 64-bit general purpose registers
   and 32 128-bit SIMD/floating point registers.

   General purpose registers (see Chapter 5.1.1 in ARM IHI 0055B)

   Register | Special | Role in the procedure call standard
   ---------+---------+------------------------------------
     SP     |         | The Stack Pointer
     r30    |  LR     | The Link Register
     r29    |  FP     | The Frame Pointer
   r19-r28  |         | Callee-saved registers
     r18    |         | The Platform Register, if needed; 
            |         | or temporary register
     r17    |  IP1    | The second intra-procedure-call temporary register
     r16    |  IP0    | The first intra-procedure-call scratch register
    r9-r15  |         | Temporary registers
     r8     |         | Indirect result location register
    r0-r7   |         | Parameter/result registers


   FPU/SIMD registers

   s/d/q/v0-v7    Argument / result/ scratch registers
   s/d/q/v8-v15   callee-saved registers (must be preserved across subrutine calls,
                  but only bottom 64-bit value needs to be preserved)
   s/d/q/v16-v31  temporary registers

   ----------------------------------------------------------------------------- */

#elif MACHREGS_aarch64

#define REG(x) __asm__(#x)

#define REG_Base        r19
#define REG_Sp          r20
#define REG_Hp          r21
#define REG_R1          r22
#define REG_R2          r23
#define REG_R3          r24
#define REG_R4          r25
#define REG_R5          r26
#define REG_R6          r27
#define REG_SpLim       r28

#define REG_F1          s8
#define REG_F2          s9
#define REG_F3          s10
#define REG_F4          s11

#define REG_D1          d12
#define REG_D2          d13
#define REG_D3          d14
#define REG_D4          d15

#else

#error Cannot find platform to give register info for

#endif

#else

#error Bad MACHREGS_NO_REGS value

#endif

/* -----------------------------------------------------------------------------
 * These constants define how many stg registers will be used for
 * passing arguments (and results, in the case of an unboxed-tuple
 * return).
 *
 * We usually set MAX_REAL_VANILLA_REG and co. to be the number of the
 * highest STG register to occupy a real machine register, otherwise
 * the calling conventions will needlessly shuffle data between the
 * stack and memory-resident STG registers.  We might occasionally
 * set these macros to other values for testing, though.
 *
 * Registers above these values might still be used, for instance to
 * communicate with PrimOps and RTS functions.
 */

#ifndef MAX_REAL_VANILLA_REG
#  if   defined(REG_R10)
#  define MAX_REAL_VANILLA_REG 10
#  elif   defined(REG_R9)
#  define MAX_REAL_VANILLA_REG 9
#  elif   defined(REG_R8)
#  define MAX_REAL_VANILLA_REG 8
#  elif defined(REG_R7)
#  define MAX_REAL_VANILLA_REG 7
#  elif defined(REG_R6)
#  define MAX_REAL_VANILLA_REG 6
#  elif defined(REG_R5)
#  define MAX_REAL_VANILLA_REG 5
#  elif defined(REG_R4)
#  define MAX_REAL_VANILLA_REG 4
#  elif defined(REG_R3)
#  define MAX_REAL_VANILLA_REG 3
#  elif defined(REG_R2)
#  define MAX_REAL_VANILLA_REG 2
#  elif defined(REG_R1)
#  define MAX_REAL_VANILLA_REG 1
#  else
#  define MAX_REAL_VANILLA_REG 0
#  endif
#endif

#ifndef MAX_REAL_FLOAT_REG
#  if   defined(REG_F4)
#  define MAX_REAL_FLOAT_REG 4
#  elif defined(REG_F3)
#  define MAX_REAL_FLOAT_REG 3
#  elif defined(REG_F2)
#  define MAX_REAL_FLOAT_REG 2
#  elif defined(REG_F1)
#  define MAX_REAL_FLOAT_REG 1
#  else
#  define MAX_REAL_FLOAT_REG 0
#  endif
#endif

#ifndef MAX_REAL_DOUBLE_REG
#  if   defined(REG_D2)
#  define MAX_REAL_DOUBLE_REG 2
#  elif defined(REG_D1)
#  define MAX_REAL_DOUBLE_REG 1
#  else
#  define MAX_REAL_DOUBLE_REG 0
#  endif
#endif

#ifndef MAX_REAL_LONG_REG
#  if   defined(REG_L1)
#  define MAX_REAL_LONG_REG 1
#  else
#  define MAX_REAL_LONG_REG 0
#  endif
#endif

#ifndef MAX_REAL_XMM_REG
#  if   defined(REG_XMM6)
#  define MAX_REAL_XMM_REG 6
#  elif defined(REG_XMM5)
#  define MAX_REAL_XMM_REG 5
#  elif defined(REG_XMM4)
#  define MAX_REAL_XMM_REG 4
#  elif defined(REG_XMM3)
#  define MAX_REAL_XMM_REG 3
#  elif defined(REG_XMM2)
#  define MAX_REAL_XMM_REG 2
#  elif defined(REG_XMM1)
#  define MAX_REAL_XMM_REG 1
#  else
#  define MAX_REAL_XMM_REG 0
#  endif
#endif

/* define NO_ARG_REGS if we have no argument registers at all (we can
 * optimise certain code paths using this predicate).
 */
#if MAX_REAL_VANILLA_REG < 2
#define NO_ARG_REGS
#else
#undef NO_ARG_REGS
#endif

#endif /* MACHREGS_H */
{-# START_FILE include/ghc-7.10.2/stg/MiscClosures.h #-}
/* ----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * Declarations for various symbols exported by the RTS.
 *
 * ToDo: many of the symbols in here don't need to be exported, but
 * our Cmm code generator doesn't know how to generate local symbols
 * for the RTS bits (it assumes all RTS symbols are external).
 *
 * See wiki:Commentary/Compiler/Backends/PprC#Prototypes
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * --------------------------------------------------------------------------*/

#ifndef STGMISCCLOSURES_H
#define STGMISCCLOSURES_H

#if IN_STG_CODE
#  define RTS_RET_INFO(i)   extern W_(i)[]
#  define RTS_FUN_INFO(i)   extern W_(i)[]
#  define RTS_THUNK_INFO(i) extern W_(i)[]
#  define RTS_INFO(i)       extern W_(i)[]
#  define RTS_CLOSURE(i)    extern W_(i)[]
#  define RTS_FUN_DECL(f)   extern DLL_IMPORT_RTS StgFunPtr f(void)
#else
#  define RTS_RET_INFO(i)   extern DLL_IMPORT_RTS const StgRetInfoTable i
#  define RTS_FUN_INFO(i)   extern DLL_IMPORT_RTS const StgFunInfoTable i
#  define RTS_THUNK_INFO(i) extern DLL_IMPORT_RTS const StgThunkInfoTable i
#  define RTS_INFO(i)       extern DLL_IMPORT_RTS const StgInfoTable i
#  define RTS_CLOSURE(i)    extern DLL_IMPORT_RTS StgClosure i
#  define RTS_FUN_DECL(f)   extern DLL_IMPORT_RTS StgFunPtr f(void)
#endif

#ifdef TABLES_NEXT_TO_CODE
#  define RTS_RET(f)      RTS_INFO(f##_info)
#  define RTS_ENTRY(f)    RTS_INFO(f##_info)
#  define RTS_FUN(f)      RTS_FUN_INFO(f##_info)
#  define RTS_THUNK(f)    RTS_THUNK_INFO(f##_info)
#else
#  define RTS_RET(f)      RTS_INFO(f##_info);  RTS_FUN_DECL(f##_ret)
#  define RTS_ENTRY(f)    RTS_INFO(f##_info);  RTS_FUN_DECL(f##_entry)
#  define RTS_FUN(f)      RTS_FUN_INFO(f##_info); RTS_FUN_DECL(f##_entry)
#  define RTS_THUNK(f)    RTS_THUNK_INFO(f##_info); RTS_FUN_DECL(f##_entry)
#endif

/* Stack frames */
RTS_RET(stg_upd_frame);
RTS_RET(stg_bh_upd_frame);
RTS_RET(stg_marked_upd_frame);
RTS_RET(stg_noupd_frame);
RTS_RET(stg_catch_frame);
RTS_RET(stg_catch_retry_frame);
RTS_RET(stg_atomically_frame);
RTS_RET(stg_atomically_waiting_frame);
RTS_RET(stg_catch_stm_frame);
RTS_RET(stg_unmaskAsyncExceptionszh_ret);
RTS_RET(stg_maskUninterruptiblezh_ret);
RTS_RET(stg_maskAsyncExceptionszh_ret);
RTS_RET(stg_stack_underflow_frame);
RTS_RET(stg_restore_cccs);

// RTS_FUN(stg_interp_constr_entry);
//
// This is referenced using the FFI in the compiler (ByteCodeItbls),
// so we can't give it the correct type here because the prototypes
// would clash (FFI references are always declared with type StgWord[]
// in the generated C code).

/* Magic glue code for when compiled code returns a value in R1/F1/D1
   or a VoidRep to the interpreter. */
RTS_RET(stg_ctoi_R1p);
RTS_RET(stg_ctoi_R1unpt);
RTS_RET(stg_ctoi_R1n);
RTS_RET(stg_ctoi_F1);
RTS_RET(stg_ctoi_D1);
RTS_RET(stg_ctoi_L1);
RTS_RET(stg_ctoi_V);

RTS_RET(stg_apply_interp);

RTS_ENTRY(stg_IND);
RTS_ENTRY(stg_IND_direct);
RTS_ENTRY(stg_IND_STATIC);
RTS_ENTRY(stg_IND_PERM);
RTS_ENTRY(stg_BLACKHOLE);
RTS_ENTRY(stg_CAF_BLACKHOLE);
RTS_ENTRY(__stg_EAGER_BLACKHOLE);
RTS_ENTRY(stg_WHITEHOLE);
RTS_ENTRY(stg_BLOCKING_QUEUE_CLEAN);
RTS_ENTRY(stg_BLOCKING_QUEUE_DIRTY);

RTS_FUN(stg_BCO);
RTS_ENTRY(stg_EVACUATED);
RTS_ENTRY(stg_WEAK);
RTS_ENTRY(stg_DEAD_WEAK);
RTS_ENTRY(stg_C_FINALIZER_LIST);
RTS_ENTRY(stg_STABLE_NAME);
RTS_ENTRY(stg_MVAR_CLEAN);
RTS_ENTRY(stg_MVAR_DIRTY);
RTS_ENTRY(stg_TVAR_CLEAN);
RTS_ENTRY(stg_TVAR_DIRTY);
RTS_ENTRY(stg_TSO);
RTS_ENTRY(stg_STACK);
RTS_ENTRY(stg_ARR_WORDS);
RTS_ENTRY(stg_MUT_ARR_WORDS);
RTS_ENTRY(stg_MUT_ARR_PTRS_CLEAN);
RTS_ENTRY(stg_MUT_ARR_PTRS_DIRTY);
RTS_ENTRY(stg_MUT_ARR_PTRS_FROZEN);
RTS_ENTRY(stg_MUT_ARR_PTRS_FROZEN0);
RTS_ENTRY(stg_SMALL_MUT_ARR_PTRS_CLEAN);
RTS_ENTRY(stg_SMALL_MUT_ARR_PTRS_DIRTY);
RTS_ENTRY(stg_SMALL_MUT_ARR_PTRS_FROZEN);
RTS_ENTRY(stg_SMALL_MUT_ARR_PTRS_FROZEN0);
RTS_ENTRY(stg_MUT_VAR_CLEAN);
RTS_ENTRY(stg_MUT_VAR_DIRTY);
RTS_ENTRY(stg_END_TSO_QUEUE);
RTS_ENTRY(stg_GCD_CAF);
RTS_ENTRY(stg_STM_AWOKEN);
RTS_ENTRY(stg_MSG_TRY_WAKEUP);
RTS_ENTRY(stg_MSG_THROWTO);
RTS_ENTRY(stg_MSG_BLACKHOLE);
RTS_ENTRY(stg_MSG_NULL);
RTS_ENTRY(stg_MVAR_TSO_QUEUE);
RTS_ENTRY(stg_catch);
RTS_ENTRY(stg_PAP);
RTS_ENTRY(stg_AP);
RTS_ENTRY(stg_AP_NOUPD);
RTS_ENTRY(stg_AP_STACK);
RTS_ENTRY(stg_AP_STACK_NOUPD);
RTS_ENTRY(stg_dummy_ret);
RTS_ENTRY(stg_raise);
RTS_ENTRY(stg_raise_ret);
RTS_ENTRY(stg_atomically);
RTS_ENTRY(stg_TVAR_WATCH_QUEUE);
RTS_ENTRY(stg_INVARIANT_CHECK_QUEUE);
RTS_ENTRY(stg_ATOMIC_INVARIANT);
RTS_ENTRY(stg_TREC_CHUNK);
RTS_ENTRY(stg_TREC_HEADER);
RTS_ENTRY(stg_END_STM_WATCH_QUEUE);
RTS_ENTRY(stg_END_INVARIANT_CHECK_QUEUE);
RTS_ENTRY(stg_END_STM_CHUNK_LIST);
RTS_ENTRY(stg_NO_TREC);

/* closures */

RTS_CLOSURE(stg_END_TSO_QUEUE_closure);
RTS_CLOSURE(stg_STM_AWOKEN_closure);
RTS_CLOSURE(stg_NO_FINALIZER_closure);
RTS_CLOSURE(stg_dummy_ret_closure);
RTS_CLOSURE(stg_forceIO_closure);

RTS_CLOSURE(stg_END_STM_WATCH_QUEUE_closure);
RTS_CLOSURE(stg_END_INVARIANT_CHECK_QUEUE_closure);
RTS_CLOSURE(stg_END_STM_CHUNK_LIST_closure);
RTS_CLOSURE(stg_NO_TREC_closure);

RTS_ENTRY(stg_NO_FINALIZER_entry);

#if IN_STG_CODE
extern DLL_IMPORT_RTS StgWordArray stg_CHARLIKE_closure;
extern DLL_IMPORT_RTS StgWordArray stg_INTLIKE_closure;
#else
extern DLL_IMPORT_RTS StgIntCharlikeClosure stg_CHARLIKE_closure[];
extern DLL_IMPORT_RTS StgIntCharlikeClosure stg_INTLIKE_closure[];
#endif

/* StgStartup */

RTS_RET(stg_forceIO);
RTS_RET(stg_noforceIO);

/* standard entry points */

/* standard selector thunks */

RTS_ENTRY(stg_sel_0_upd);
RTS_ENTRY(stg_sel_1_upd);
RTS_ENTRY(stg_sel_2_upd);
RTS_ENTRY(stg_sel_3_upd);
RTS_ENTRY(stg_sel_4_upd);
RTS_ENTRY(stg_sel_5_upd);
RTS_ENTRY(stg_sel_6_upd);
RTS_ENTRY(stg_sel_7_upd);
RTS_ENTRY(stg_sel_8_upd);
RTS_ENTRY(stg_sel_9_upd);
RTS_ENTRY(stg_sel_10_upd);
RTS_ENTRY(stg_sel_11_upd);
RTS_ENTRY(stg_sel_12_upd);
RTS_ENTRY(stg_sel_13_upd);
RTS_ENTRY(stg_sel_14_upd);
RTS_ENTRY(stg_sel_15_upd);

RTS_ENTRY(stg_sel_0_noupd);
RTS_ENTRY(stg_sel_1_noupd);
RTS_ENTRY(stg_sel_2_noupd);
RTS_ENTRY(stg_sel_3_noupd);
RTS_ENTRY(stg_sel_4_noupd);
RTS_ENTRY(stg_sel_5_noupd);
RTS_ENTRY(stg_sel_6_noupd);
RTS_ENTRY(stg_sel_7_noupd);
RTS_ENTRY(stg_sel_8_noupd);
RTS_ENTRY(stg_sel_9_noupd);
RTS_ENTRY(stg_sel_10_noupd);
RTS_ENTRY(stg_sel_11_noupd);
RTS_ENTRY(stg_sel_12_noupd);
RTS_ENTRY(stg_sel_13_noupd);
RTS_ENTRY(stg_sel_14_noupd);
RTS_ENTRY(stg_sel_15_noupd);

/* standard ap thunks */

RTS_THUNK(stg_ap_1_upd);
RTS_THUNK(stg_ap_2_upd);
RTS_THUNK(stg_ap_3_upd);
RTS_THUNK(stg_ap_4_upd);
RTS_THUNK(stg_ap_5_upd);
RTS_THUNK(stg_ap_6_upd);
RTS_THUNK(stg_ap_7_upd);

/* standard application routines (see also utils/genapply,
 * and compiler/codeGen/CgStackery.lhs).
 */
RTS_RET(stg_ap_v);
RTS_RET(stg_ap_f);
RTS_RET(stg_ap_d);
RTS_RET(stg_ap_l);
RTS_RET(stg_ap_v16);
RTS_RET(stg_ap_v32);
RTS_RET(stg_ap_v64);
RTS_RET(stg_ap_n);
RTS_RET(stg_ap_p);
RTS_RET(stg_ap_pv);
RTS_RET(stg_ap_pp);
RTS_RET(stg_ap_ppv);
RTS_RET(stg_ap_ppp);
RTS_RET(stg_ap_pppv);
RTS_RET(stg_ap_pppp);
RTS_RET(stg_ap_ppppp);
RTS_RET(stg_ap_pppppp);

RTS_FUN_DECL(stg_ap_0_fast);
RTS_FUN_DECL(stg_ap_v_fast);
RTS_FUN_DECL(stg_ap_f_fast);
RTS_FUN_DECL(stg_ap_d_fast);
RTS_FUN_DECL(stg_ap_l_fast);
RTS_FUN_DECL(stg_ap_v16_fast);
RTS_FUN_DECL(stg_ap_v32_fast);
RTS_FUN_DECL(stg_ap_v64_fast);
RTS_FUN_DECL(stg_ap_n_fast);
RTS_FUN_DECL(stg_ap_p_fast);
RTS_FUN_DECL(stg_ap_pv_fast);
RTS_FUN_DECL(stg_ap_pp_fast);
RTS_FUN_DECL(stg_ap_ppv_fast);
RTS_FUN_DECL(stg_ap_ppp_fast);
RTS_FUN_DECL(stg_ap_pppv_fast);
RTS_FUN_DECL(stg_ap_pppp_fast);
RTS_FUN_DECL(stg_ap_ppppp_fast);
RTS_FUN_DECL(stg_ap_pppppp_fast);
RTS_FUN_DECL(stg_PAP_apply);

/* standard GC & stack check entry points, all defined in HeapStackCheck.hc */

RTS_FUN_DECL(stg_gc_noregs);

RTS_RET(stg_enter_checkbh);

RTS_RET(stg_ret_v);
RTS_RET(stg_ret_p);
RTS_RET(stg_ret_n);
RTS_RET(stg_ret_f);
RTS_RET(stg_ret_d);
RTS_RET(stg_ret_l);

RTS_FUN_DECL(stg_gc_prim);
RTS_FUN_DECL(stg_gc_prim_p);
RTS_FUN_DECL(stg_gc_prim_pp);
RTS_FUN_DECL(stg_gc_prim_n);

RTS_RET(stg_gc_prim_p_ll_ret);
RTS_FUN_DECL(stg_gc_prim_p_ll);

RTS_RET(stg_enter);
RTS_FUN_DECL(__stg_gc_enter_1);

RTS_FUN_DECL(stg_gc_unpt_r1);
RTS_FUN_DECL(stg_gc_unbx_r1);
RTS_FUN_DECL(stg_gc_f1);
RTS_FUN_DECL(stg_gc_d1);
RTS_FUN_DECL(stg_gc_l1);
RTS_FUN_DECL(stg_gc_pp);
RTS_FUN_DECL(stg_gc_ppp);
RTS_FUN_DECL(stg_gc_pppp);

RTS_RET(stg_gc_fun);
RTS_FUN_DECL(__stg_gc_fun);

RTS_FUN_DECL(stg_yield_noregs);
RTS_FUN_DECL(stg_yield_to_interpreter);
RTS_FUN_DECL(stg_block_noregs);
RTS_FUN_DECL(stg_block_blackhole);
RTS_FUN_DECL(stg_block_blackhole_finally);
RTS_FUN_DECL(stg_block_takemvar);
RTS_FUN_DECL(stg_block_readmvar);
RTS_RET(stg_block_takemvar);
RTS_RET(stg_block_readmvar);
RTS_FUN_DECL(stg_block_putmvar);
RTS_RET(stg_block_putmvar);
#ifdef mingw32_HOST_OS
RTS_FUN_DECL(stg_block_async);
RTS_RET(stg_block_async);
RTS_FUN_DECL(stg_block_async_void);
RTS_RET(stg_block_async_void);
#endif
RTS_FUN_DECL(stg_block_stmwait);
RTS_FUN_DECL(stg_block_throwto);
RTS_RET(stg_block_throwto);

/* Entry/exit points from StgStartup.cmm */

RTS_RET(stg_stop_thread);

RTS_FUN_DECL(stg_returnToStackTop);
RTS_FUN_DECL(stg_returnToSched);
RTS_FUN_DECL(stg_returnToSchedNotPaused);
RTS_FUN_DECL(stg_returnToSchedButFirst);
RTS_FUN_DECL(stg_threadFinished);

RTS_FUN_DECL(stg_init_finish);
RTS_FUN_DECL(stg_init);

RTS_FUN_DECL(StgReturn);

/* -----------------------------------------------------------------------------
   PrimOps
   -------------------------------------------------------------------------- */

RTS_FUN_DECL(stg_decodeFloatzuIntzh);
RTS_FUN_DECL(stg_decodeDoublezu2Intzh);
RTS_FUN_DECL(stg_decodeDoublezuInt64zh);

RTS_FUN_DECL(stg_unsafeThawArrayzh);
RTS_FUN_DECL(stg_casArrayzh);
RTS_FUN_DECL(stg_newByteArrayzh);
RTS_FUN_DECL(stg_newPinnedByteArrayzh);
RTS_FUN_DECL(stg_newAlignedPinnedByteArrayzh);
RTS_FUN_DECL(stg_shrinkMutableByteArrayzh);
RTS_FUN_DECL(stg_resizzeMutableByteArrayzh);
RTS_FUN_DECL(stg_casIntArrayzh);
RTS_FUN_DECL(stg_newArrayzh);
RTS_FUN_DECL(stg_newArrayArrayzh);
RTS_FUN_DECL(stg_copyArrayzh);
RTS_FUN_DECL(stg_copyMutableArrayzh);
RTS_FUN_DECL(stg_copyArrayArrayzh);
RTS_FUN_DECL(stg_copyMutableArrayArrayzh);
RTS_FUN_DECL(stg_cloneArrayzh);
RTS_FUN_DECL(stg_cloneMutableArrayzh);
RTS_FUN_DECL(stg_freezzeArrayzh);
RTS_FUN_DECL(stg_thawArrayzh);

RTS_FUN_DECL(stg_newSmallArrayzh);
RTS_FUN_DECL(stg_unsafeThawSmallArrayzh);
RTS_FUN_DECL(stg_cloneSmallArrayzh);
RTS_FUN_DECL(stg_cloneSmallMutableArrayzh);
RTS_FUN_DECL(stg_freezzeSmallArrayzh);
RTS_FUN_DECL(stg_thawSmallArrayzh);
RTS_FUN_DECL(stg_copySmallArrayzh);
RTS_FUN_DECL(stg_copySmallMutableArrayzh);
RTS_FUN_DECL(stg_casSmallArrayzh);

RTS_FUN_DECL(stg_newMutVarzh);
RTS_FUN_DECL(stg_atomicModifyMutVarzh);
RTS_FUN_DECL(stg_casMutVarzh);

RTS_FUN_DECL(stg_isEmptyMVarzh);
RTS_FUN_DECL(stg_newMVarzh);
RTS_FUN_DECL(stg_takeMVarzh);
RTS_FUN_DECL(stg_putMVarzh);
RTS_FUN_DECL(stg_readMVarzh);
RTS_FUN_DECL(stg_tryTakeMVarzh);
RTS_FUN_DECL(stg_tryPutMVarzh);
RTS_FUN_DECL(stg_tryReadMVarzh);

RTS_FUN_DECL(stg_waitReadzh);
RTS_FUN_DECL(stg_waitWritezh);
RTS_FUN_DECL(stg_delayzh);
#ifdef mingw32_HOST_OS
RTS_FUN_DECL(stg_asyncReadzh);
RTS_FUN_DECL(stg_asyncWritezh);
RTS_FUN_DECL(stg_asyncDoProczh);
#endif

RTS_FUN_DECL(stg_catchzh);
RTS_FUN_DECL(stg_raisezh);
RTS_FUN_DECL(stg_raiseIOzh);

RTS_FUN_DECL(stg_makeStableNamezh);
RTS_FUN_DECL(stg_makeStablePtrzh);
RTS_FUN_DECL(stg_deRefStablePtrzh);

RTS_FUN_DECL(stg_forkzh);
RTS_FUN_DECL(stg_forkOnzh);
RTS_FUN_DECL(stg_yieldzh);
RTS_FUN_DECL(stg_killMyself);
RTS_FUN_DECL(stg_killThreadzh);
RTS_FUN_DECL(stg_getMaskingStatezh);
RTS_FUN_DECL(stg_maskAsyncExceptionszh);
RTS_FUN_DECL(stg_maskUninterruptiblezh);
RTS_FUN_DECL(stg_unmaskAsyncExceptionszh);
RTS_FUN_DECL(stg_myThreadIdzh);
RTS_FUN_DECL(stg_labelThreadzh);
RTS_FUN_DECL(stg_isCurrentThreadBoundzh);
RTS_FUN_DECL(stg_threadStatuszh);

RTS_FUN_DECL(stg_mkWeakzh);
RTS_FUN_DECL(stg_mkWeakNoFinalizzerzh);
RTS_FUN_DECL(stg_mkWeakForeignzh);
RTS_FUN_DECL(stg_addCFinalizzerToWeakzh);
RTS_FUN_DECL(stg_finalizzeWeakzh);
RTS_FUN_DECL(stg_deRefWeakzh);

RTS_FUN_DECL(stg_newBCOzh);
RTS_FUN_DECL(stg_mkApUpd0zh);

RTS_FUN_DECL(stg_retryzh);
RTS_FUN_DECL(stg_catchRetryzh);
RTS_FUN_DECL(stg_catchSTMzh);
RTS_FUN_DECL(stg_atomicallyzh);
RTS_FUN_DECL(stg_newTVarzh);
RTS_FUN_DECL(stg_readTVarzh);
RTS_FUN_DECL(stg_readTVarIOzh);
RTS_FUN_DECL(stg_writeTVarzh);
RTS_FUN_DECL(stg_checkzh);

RTS_FUN_DECL(stg_unpackClosurezh);
RTS_FUN_DECL(stg_getApStackValzh);
RTS_FUN_DECL(stg_getSparkzh);
RTS_FUN_DECL(stg_numSparkszh);

RTS_FUN_DECL(stg_noDuplicatezh);

RTS_FUN_DECL(stg_traceCcszh);
RTS_FUN_DECL(stg_traceEventzh);
RTS_FUN_DECL(stg_traceMarkerzh);

/* Other misc stuff */
// See wiki:Commentary/Compiler/Backends/PprC#Prototypes

#if IN_STG_CODE && !IN_STGCRUN

// Interpreter.c
extern StgWord rts_stop_next_breakpoint[];
extern StgWord rts_stop_on_exception[];
extern StgWord rts_breakpoint_io_action[];

// Schedule.c
extern StgWord RTS_VAR(blocked_queue_hd), RTS_VAR(blocked_queue_tl);
extern StgWord RTS_VAR(sleeping_queue);
extern StgWord RTS_VAR(blackhole_queue);
extern StgWord RTS_VAR(sched_mutex);

// Apply.cmm
// canned bitmap for each arg type
extern StgWord stg_arg_bitmaps[];
extern StgWord stg_ap_stack_entries[];
extern StgWord stg_stack_save_entries[];

// Storage.c
extern unsigned int RTS_VAR(g0);
extern unsigned int RTS_VAR(large_alloc_lim);
extern StgWord RTS_VAR(atomic_modify_mutvar_mutex);

// RtsFlags
extern StgWord RTS_VAR(RtsFlags); // bogus type

// Stable.c
extern StgWord RTS_VAR(stable_ptr_table);
extern StgWord RTS_VAR(stable_name_table);

// Profiling.c
extern unsigned int RTS_VAR(era);
extern unsigned int RTS_VAR(entering_PAP);
extern StgWord      RTS_VAR(CC_LIST);          /* registered CC list */
extern StgWord      RTS_VAR(CCS_LIST);         /* registered CCS list */
extern StgWord      CCS_SYSTEM[];
extern unsigned int RTS_VAR(CC_ID);            /* global ids */
extern unsigned int RTS_VAR(CCS_ID);
RTS_FUN_DECL(enterFunCCS);
RTS_FUN_DECL(pushCostCentre);

// Capability.c
extern unsigned int n_capabilities;

#endif

#endif /* STGMISCCLOSURES_H */
{-# START_FILE include/ghc-7.10.2/stg/Prim.h #-}
/* ----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2014-2014
 *
 * Declarations for C fallback primitives implemented by 'ghc-prim' package.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * -------------------------------------------------------------------------- */

#ifndef PRIM_H
#define PRIM_H

/* libraries/ghc-prim/cbits/atomic.c */
StgWord hs_atomic_add8(volatile StgWord8 *x, StgWord val);
StgWord hs_atomic_add16(volatile StgWord16 *x, StgWord val);
StgWord hs_atomic_add32(volatile StgWord32 *x, StgWord val);
StgWord64 hs_atomic_add64(volatile StgWord64 *x, StgWord64 val);
StgWord hs_atomic_sub8(volatile StgWord8 *x, StgWord val);
StgWord hs_atomic_sub16(volatile StgWord16 *x, StgWord val);
StgWord hs_atomic_sub32(volatile StgWord32 *x, StgWord val);
StgWord64 hs_atomic_sub64(volatile StgWord64 *x, StgWord64 val);
StgWord hs_atomic_and8(volatile StgWord8 *x, StgWord val);
StgWord hs_atomic_and16(volatile StgWord16 *x, StgWord val);
StgWord hs_atomic_and32(volatile StgWord32 *x, StgWord val);
StgWord64 hs_atomic_and64(volatile StgWord64 *x, StgWord64 val);
StgWord hs_atomic_nand8(volatile StgWord8 *x, StgWord val);
StgWord hs_atomic_nand16(volatile StgWord16 *x, StgWord val);
StgWord hs_atomic_nand32(volatile StgWord32 *x, StgWord val);
StgWord64 hs_atomic_nand64(volatile StgWord64 *x, StgWord64 val);
StgWord hs_atomic_or8(volatile StgWord8 *x, StgWord val);
StgWord hs_atomic_or16(volatile StgWord16 *x, StgWord val);
StgWord hs_atomic_or32(volatile StgWord32 *x, StgWord val);
StgWord64 hs_atomic_or64(volatile StgWord64 *x, StgWord64 val);
StgWord hs_atomic_xor8(volatile StgWord8 *x, StgWord val);
StgWord hs_atomic_xor16(volatile StgWord16 *x, StgWord val);
StgWord hs_atomic_xor32(volatile StgWord32 *x, StgWord val);
StgWord64 hs_atomic_xor64(volatile StgWord64 *x, StgWord64 val);
StgWord hs_cmpxchg8(volatile StgWord8 *x, StgWord old, StgWord new);
StgWord hs_cmpxchg16(volatile StgWord16 *x, StgWord old, StgWord new);
StgWord hs_cmpxchg32(volatile StgWord32 *x, StgWord old, StgWord new);
StgWord hs_cmpxchg64(volatile StgWord64 *x, StgWord64 old, StgWord64 new);
StgWord hs_atomicread8(volatile StgWord8 *x);
StgWord hs_atomicread16(volatile StgWord16 *x);
StgWord hs_atomicread32(volatile StgWord32 *x);
StgWord64 hs_atomicread64(volatile StgWord64 *x);
void hs_atomicwrite8(volatile StgWord8 *x, StgWord val);
void hs_atomicwrite16(volatile StgWord16 *x, StgWord val);
void hs_atomicwrite32(volatile StgWord32 *x, StgWord val);
void hs_atomicwrite64(volatile StgWord64 *x, StgWord64 val);

/* libraries/ghc-prim/cbits/bswap.c */
StgWord16 hs_bswap16(StgWord16 x);
StgWord32 hs_bswap32(StgWord32 x);
StgWord64 hs_bswap64(StgWord64 x);

/* TODO: longlong.c */

/* libraries/ghc-prim/cbits/popcnt.c */
StgWord hs_popcnt8(StgWord x);
StgWord hs_popcnt16(StgWord x);
StgWord hs_popcnt32(StgWord x);
StgWord hs_popcnt64(StgWord64 x);
StgWord hs_popcnt(StgWord x);

/* libraries/ghc-prim/cbits/word2float.c */
StgFloat hs_word2float32(StgWord x);
StgDouble hs_word2float64(StgWord x);

/* libraries/ghc-prim/cbits/clz.c */
StgWord hs_clz8(StgWord x);
StgWord hs_clz16(StgWord x);
StgWord hs_clz32(StgWord x);
StgWord hs_clz64(StgWord64 x);

/* libraries/ghc-prim/cbits/ctz.c */
StgWord hs_ctz8(StgWord x);
StgWord hs_ctz16(StgWord x);
StgWord hs_ctz32(StgWord x);
StgWord hs_ctz64(StgWord64 x);

#endif /* PRIM_H */
{-# START_FILE include/ghc-7.10.2/stg/Regs.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2012
 *
 * Registers in the STG machine.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef REGS_H
#define REGS_H

/*
 * The STG machine has a collection of "registers", each one of which
 * may or may not correspond to an actual machine register when
 * running code.
 *
 * The register set is backed by a table in memory (struct
 * StgRegTable).  If a particular STG register is not mapped to a
 * machine register, then the appropriate slot in this table is used
 * instead.
 *
 * This table is itself pointed to by another register, BaseReg.  If
 * BaseReg is not in a machine register, then the register table is
 * used from an absolute location (MainCapability).
 *
 */

typedef struct {
  StgWord        stgEagerBlackholeInfo;
  StgFunPtr      stgGCEnter1;
  StgFunPtr      stgGCFun;
} StgFunTable;

/*
 * Vanilla registers are given this union type, which is purely so
 * that we can cast the vanilla reg to a variety of types with the
 * minimum of syntax.  eg.  R1.w instead of (StgWord)R1.
 */
typedef union {
    StgWord        w;
    StgAddr        a;
    StgChar        c;
    StgFloat       f;
    StgInt         i;
    StgPtr         p;
} StgUnion;

/*
 * This is the table that holds shadow-locations for all the STG
 * registers.  The shadow locations are used when:
 *
 *     1) the particular register isn't mapped to a real machine
 *        register, probably because there's a shortage of real registers.
 *     2) caller-saves registers are saved across a CCall
 */
typedef struct {
  StgUnion        rR1;
  StgUnion        rR2;
  StgUnion        rR3;
  StgUnion        rR4;
  StgUnion        rR5;
  StgUnion        rR6;
  StgUnion        rR7;
  StgUnion        rR8;
  StgUnion        rR9;          /* used occasionally by heap/stack checks */
  StgUnion        rR10;         /* used occasionally by heap/stack checks */
  StgFloat        rF1;
  StgFloat        rF2;
  StgFloat        rF3;
  StgFloat        rF4;
  StgFloat        rF5;
  StgFloat        rF6;
  StgDouble       rD1;
  StgDouble       rD2;
  StgDouble       rD3;
  StgDouble       rD4;
  StgDouble       rD5;
  StgDouble       rD6;
  StgWord128      rXMM1;
  StgWord128      rXMM2;
  StgWord128      rXMM3;
  StgWord128      rXMM4;
  StgWord128      rXMM5;
  StgWord128      rXMM6;
  StgWord256      rYMM1;
  StgWord256      rYMM2;
  StgWord256      rYMM3;
  StgWord256      rYMM4;
  StgWord256      rYMM5;
  StgWord256      rYMM6;
  StgWord512      rZMM1;
  StgWord512      rZMM2;
  StgWord512      rZMM3;
  StgWord512      rZMM4;
  StgWord512      rZMM5;
  StgWord512      rZMM6;
  StgWord64       rL1;
  StgPtr          rSp;
  StgPtr          rSpLim;
  StgPtr          rHp;
  StgPtr          rHpLim;
  struct CostCentreStack_ * rCCCS;  /* current cost-centre-stack */
  struct StgTSO_ *     rCurrentTSO;
  struct nursery_ *    rNursery;
  struct bdescr_ *     rCurrentNursery; /* Hp/HpLim point into this block */
  struct bdescr_ *     rCurrentAlloc;   /* for allocation using allocate() */
  StgWord         rHpAlloc;     /* number of *bytes* being allocated in heap */
  StgWord         rRet;  /* holds the return code of the thread */
} StgRegTable;

#if IN_STG_CODE

/*
 * Registers Hp and HpLim are global across the entire system, and are
 * copied into the RegTable or registers before executing a thread.
 *
 * Registers Sp and SpLim are saved in the TSO for the thread, but are
 * copied into the RegTable or registers before executing a thread.
 *
 * All other registers are "general purpose", and are used for passing
 * arguments to functions, and returning values.  The code generator
 * knows how many of these are in real registers, and avoids
 * generating code that uses non-real registers.  General purpose
 * registers are never saved when returning to the scheduler, instead
 * we save whatever is live at the time on the stack, and restore it
 * later.  This should reduce the context switch time, amongst other
 * things.
 *
 * For argument passing, the stack will be used in preference to
 * pseudo-registers if the architecture has too few general purpose
 * registers.
 *
 * Some special RTS functions like newArray and the Integer primitives
 * expect their arguments to be in registers R1-Rn, so we use these
 * (pseudo-)registers in those cases.
 */

/* -----------------------------------------------------------------------------
 * Emit the GCC-specific register declarations for each machine
 * register being used.  If any STG register isn't mapped to a machine
 * register, then map it to an offset from BaseReg.
 *
 * First, the general purpose registers.  The idea is, if a particular
 * general-purpose STG register can't be mapped to a real machine
 * register, it won't be used at all.  Instead, we'll use the stack.
 */

/* define NO_REGS to omit register declarations - used in RTS C code
 * that needs all the STG definitions but not the global register
 * settings.
 */
#define GLOBAL_REG_DECL(type,name,reg) register type name REG(reg);

#if defined(REG_R1) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgUnion,R1,REG_R1)
#else
# define R1 (BaseReg->rR1)
#endif

#if defined(REG_R2) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgUnion,R2,REG_R2)
#else
# define R2 (BaseReg->rR2)
#endif

#if defined(REG_R3) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgUnion,R3,REG_R3)
#else
# define R3 (BaseReg->rR3)
#endif

#if defined(REG_R4) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgUnion,R4,REG_R4)
#else
# define R4 (BaseReg->rR4)
#endif

#if defined(REG_R5) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgUnion,R5,REG_R5)
#else
# define R5 (BaseReg->rR5)
#endif

#if defined(REG_R6) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgUnion,R6,REG_R6)
#else
# define R6 (BaseReg->rR6)
#endif

#if defined(REG_R7) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgUnion,R7,REG_R7)
#else
# define R7 (BaseReg->rR7)
#endif

#if defined(REG_R8) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgUnion,R8,REG_R8)
#else
# define R8 (BaseReg->rR8)
#endif

#if defined(REG_R9) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgUnion,R9,REG_R9)
#else
# define R9 (BaseReg->rR9)
#endif

#if defined(REG_R10) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgUnion,R10,REG_R10)
#else
# define R10 (BaseReg->rR10)
#endif

#if defined(REG_F1) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgFloat,F1,REG_F1)
#else
#define F1 (BaseReg->rF1)
#endif

#if defined(REG_F2) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgFloat,F2,REG_F2)
#else
#define F2 (BaseReg->rF2)
#endif

#if defined(REG_F3) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgFloat,F3,REG_F3)
#else
#define F3 (BaseReg->rF3)
#endif

#if defined(REG_F4) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgFloat,F4,REG_F4)
#else
#define F4 (BaseReg->rF4)
#endif

#if defined(REG_F5) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgFloat,F5,REG_F5)
#else
#define F5 (BaseReg->rF5)
#endif

#if defined(REG_F6) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgFloat,F6,REG_F6)
#else
#define F6 (BaseReg->rF6)
#endif

#if defined(REG_D1) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgDouble,D1,REG_D1)
#else
#define D1 (BaseReg->rD1)
#endif

#if defined(REG_D2) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgDouble,D2,REG_D2)
#else
#define D2 (BaseReg->rD2)
#endif

#if defined(REG_D3) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgDouble,D3,REG_D3)
#else
#define D3 (BaseReg->rD3)
#endif

#if defined(REG_D4) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgDouble,D4,REG_D4)
#else
#define D4 (BaseReg->rD4)
#endif

#if defined(REG_D5) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgDouble,D5,REG_D5)
#else
#define D5 (BaseReg->rD5)
#endif

#if defined(REG_D6) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgDouble,D6,REG_D6)
#else
#define D6 (BaseReg->rD6)
#endif

#if defined(REG_XMM1) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord128,XMM1,REG_XMM1)
#else
#define XMM1 (BaseReg->rXMM1)
#endif

#if defined(REG_XMM2) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord128,XMM2,REG_XMM2)
#else
#define XMM2 (BaseReg->rXMM2)
#endif

#if defined(REG_XMM3) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord128,XMM3,REG_XMM3)
#else
#define XMM3 (BaseReg->rXMM3)
#endif

#if defined(REG_XMM4) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord128,XMM4,REG_XMM4)
#else
#define XMM4 (BaseReg->rXMM4)
#endif

#if defined(REG_XMM5) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord128,XMM5,REG_XMM5)
#else
#define XMM5 (BaseReg->rXMM5)
#endif

#if defined(REG_XMM6) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord128,XMM6,REG_XMM6)
#else
#define XMM6 (BaseReg->rXMM6)
#endif

#if defined(REG_YMM1) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord256,YMM1,REG_YMM1)
#else
#define YMM1 (BaseReg->rYMM1)
#endif

#if defined(REG_YMM2) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord256,YMM2,REG_YMM2)
#else
#define YMM2 (BaseReg->rYMM2)
#endif

#if defined(REG_YMM3) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord256,YMM3,REG_YMM3)
#else
#define YMM3 (BaseReg->rYMM3)
#endif

#if defined(REG_YMM4) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord256,YMM4,REG_YMM4)
#else
#define YMM4 (BaseReg->rYMM4)
#endif

#if defined(REG_YMM5) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord256,YMM5,REG_YMM5)
#else
#define YMM5 (BaseReg->rYMM5)
#endif

#if defined(REG_YMM6) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord256,YMM6,REG_YMM6)
#else
#define YMM6 (BaseReg->rYMM6)
#endif

#if defined(REG_ZMM1) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord512,ZMM1,REG_ZMM1)
#else
#define ZMM1 (BaseReg->rZMM1)
#endif

#if defined(REG_ZMM2) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord512,ZMM2,REG_ZMM2)
#else
#define ZMM2 (BaseReg->rZMM2)
#endif

#if defined(REG_ZMM3) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord512,ZMM3,REG_ZMM3)
#else
#define ZMM3 (BaseReg->rZMM3)
#endif

#if defined(REG_ZMM4) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord512,ZMM4,REG_ZMM4)
#else
#define ZMM4 (BaseReg->rZMM4)
#endif

#if defined(REG_ZMM5) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord512,ZMM5,REG_ZMM5)
#else
#define ZMM5 (BaseReg->rZMM5)
#endif

#if defined(REG_ZMM6) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord512,ZMM6,REG_ZMM6)
#else
#define ZMM6 (BaseReg->rZMM6)
#endif

#if defined(REG_L1) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord64,L1,REG_L1)
#else
#define L1 (BaseReg->rL1)
#endif

/*
 * If BaseReg isn't mapped to a machine register, just use the global
 * address of the current register table (CurrentRegTable in
 * concurrent Haskell, MainRegTable otherwise).
 */

/* A capability is a combination of a FunTable and a RegTable.  In STG
 * code, BaseReg normally points to the RegTable portion of this
 * structure, so that we can index both forwards and backwards to take
 * advantage of shorter instruction forms on some archs (eg. x86).
 * This is a cut-down version of the Capability structure; the full
 * version is defined in Capability.h.
 */
struct PartCapability_ {
    StgFunTable f;
    StgRegTable r;
};

/* No such thing as a MainCapability under THREADED_RTS - each thread must have
 * its own Capability.
 */
#if IN_STG_CODE && !(defined(THREADED_RTS) && !defined(NOSMP))
extern W_ MainCapability[];
#endif

/*
 * Assigning to BaseReg (the ASSIGN_BaseReg macro): this happens on
 * return from a "safe" foreign call, when the thread might be running
 * on a new Capability.  Obviously if BaseReg is not a register, then
 * we are restricted to a single Capability (this invariant is enforced
 * in Capability.c:initCapabilities), and assigning to BaseReg can be omitted.
 */

#if defined(REG_Base) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgRegTable *,BaseReg,REG_Base)
#define ASSIGN_BaseReg(e) (BaseReg = (e))
#else
#if defined(THREADED_RTS) && !defined(NOSMP)
#error BaseReg must be in a register for THREADED_RTS
#endif
#define BaseReg (&((struct PartCapability_ *)MainCapability)->r)
#define ASSIGN_BaseReg(e) (e)
#endif

#if defined(REG_Sp) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(P_,Sp,REG_Sp)
#else
#define Sp (BaseReg->rSp)
#endif

#if defined(REG_SpLim) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(P_,SpLim,REG_SpLim)
#else
#define SpLim (BaseReg->rSpLim)
#endif

#if defined(REG_Hp) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(P_,Hp,REG_Hp)
#else
#define Hp (BaseReg->rHp)
#endif

#if defined(REG_HpLim) && !defined(NO_GLOBAL_REG_DECLS)
#error HpLim cannot be in a register
#else
#define HpLim (BaseReg->rHpLim)
#endif

#if defined(REG_CCCS) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(struct CostCentreStack_ *,CCCS,REG_CCCS)
#else
#define CCCS (BaseReg->rCCCS)
#endif

#if defined(REG_CurrentTSO) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(struct _StgTSO *,CurrentTSO,REG_CurrentTSO)
#else
#define CurrentTSO (BaseReg->rCurrentTSO)
#endif

#if defined(REG_CurrentNursery) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(bdescr *,CurrentNursery,REG_CurrentNursery)
#else
#define CurrentNursery (BaseReg->rCurrentNursery)
#endif

#if defined(REG_HpAlloc) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(bdescr *,HpAlloc,REG_HpAlloc)
#else
#define HpAlloc (BaseReg->rHpAlloc)
#endif

/* -----------------------------------------------------------------------------
   Get absolute function pointers from the register table, to save
   code space.  On x86,

       jmp  *-12(%ebx)

   is shorter than

       jmp absolute_address

   as long as the offset is within the range of a signed byte
   (-128..+127).  So we pick some common absolute_addresses and put
   them in the register table.  As a bonus, linking time should also
   be reduced.

   Other possible candidates in order of importance:

     stg_upd_frame_info
     stg_CAF_BLACKHOLE_info
     stg_IND_STATIC_info

   anything else probably isn't worth the effort.

   -------------------------------------------------------------------------- */


#define FunReg ((StgFunTable *)((void *)BaseReg - STG_FIELD_OFFSET(struct PartCapability_, r)))

#define stg_EAGER_BLACKHOLE_info  (FunReg->stgEagerBlackholeInfo)
#define stg_gc_enter_1            (FunReg->stgGCEnter1)
#define stg_gc_fun                (FunReg->stgGCFun)

#endif /* IN_STG_CODE */

#endif /* REGS_H */
{-# START_FILE include/ghc-7.10.2/stg/RtsMachRegs.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2011
 *
 * Registers used in STG code.  Might or might not correspond to
 * actual machine registers.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTSMACHREGS_H
#define RTSMACHREGS_H

#ifdef UnregisterisedCompiler
#ifndef NO_REGS
#define NO_REGS
#endif
#endif

/*
 * Defining NO_REGS causes no global registers to be used.  NO_REGS is
 * typically defined by GHC, via a command-line option passed to gcc,
 * when the -funregisterised flag is given.
 *
 * NB. When NO_REGS is on, calling & return conventions may be
 * different.  For example, all function arguments will be passed on
 * the stack, and components of an unboxed tuple will be returned on
 * the stack rather than in registers.
 */
#ifdef NO_REGS

#define MACHREGS_NO_REGS 1

#else

#define MACHREGS_NO_REGS 0

#define MACHREGS_i386     i386_HOST_ARCH
#define MACHREGS_x86_64   x86_64_HOST_ARCH
#define MACHREGS_powerpc  (powerpc_HOST_ARCH || powerpc64_HOST_ARCH || rs6000_HOST_ARCH)
#define MACHREGS_sparc    sparc_HOST_ARCH
#define MACHREGS_arm      arm_HOST_ARCH
#define MACHREGS_aarch64  aarch64_HOST_ARCH
#define MACHREGS_darwin   darwin_HOST_OS

#endif

#include "MachRegs.h"

#endif /* RTSMACHREGS_H */
{-# START_FILE include/ghc-7.10.2/stg/SMP.h #-}
/* ----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2005-2011
 *
 * Macros for multi-CPU support
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * -------------------------------------------------------------------------- */

#ifndef SMP_H
#define SMP_H

#if arm_HOST_ARCH && defined(arm_HOST_ARCH_PRE_ARMv6)
void arm_atomic_spin_lock(void);
void arm_atomic_spin_unlock(void);
#endif

#if defined(THREADED_RTS)

/* ----------------------------------------------------------------------------
   Atomic operations
   ------------------------------------------------------------------------- */

#if !IN_STG_CODE || IN_STGCRUN
// We only want the barriers, e.g. write_barrier(), declared in .hc
// files.  Defining the other inline functions here causes type
// mismatch errors from gcc, because the generated C code is assuming
// that there are no prototypes in scope.

/*
 * The atomic exchange operation: xchg(p,w) exchanges the value
 * pointed to by p with the value w, returning the old value.
 *
 * Used for locking closures during updates (see lockClosure() below)
 * and the MVar primops.
 */
EXTERN_INLINE StgWord xchg(StgPtr p, StgWord w);

/*
 * Compare-and-swap.  Atomically does this:
 *
 * cas(p,o,n) {
 *    r = *p;
 *    if (r == o) { *p = n };
 *    return r;
 * }
 */
EXTERN_INLINE StgWord cas(StgVolatilePtr p, StgWord o, StgWord n);

/*
 * Atomic addition by the provided quantity
 *
 * atomic_inc(p, n) {
 *   return ((*p) += n);
 * }
 */
EXTERN_INLINE StgWord atomic_inc(StgVolatilePtr p, StgWord n);


/*
 * Atomic decrement
 *
 * atomic_dec(p) {
 *   return --(*p);
 * }
 */
EXTERN_INLINE StgWord atomic_dec(StgVolatilePtr p);

/*
 * Busy-wait nop: this is a hint to the CPU that we are currently in a
 * busy-wait loop waiting for another CPU to change something.  On a
 * hypertreaded CPU it should yield to another thread, for example.
 */
EXTERN_INLINE void busy_wait_nop(void);

#endif // !IN_STG_CODE

/*
 * Various kinds of memory barrier.
 *  write_barrier: prevents future stores occurring before prededing stores.
 *  store_load_barrier: prevents future loads occurring before preceding stores.
 *  load_load_barrier: prevents future loads occurring before earlier stores.
 *
 * Reference for these: "The JSR-133 Cookbook for Compiler Writers"
 * http://gee.cs.oswego.edu/dl/jmm/cookbook.html
 *
 * To check whether you got these right, try the test in
 *   testsuite/tests/rts/testwsdeque.c
 * This tests the work-stealing deque implementation, which relies on
 * properly working store_load and load_load memory barriers.
 */
EXTERN_INLINE void write_barrier(void);
EXTERN_INLINE void store_load_barrier(void);
EXTERN_INLINE void load_load_barrier(void);

/* ----------------------------------------------------------------------------
   Implementations
   ------------------------------------------------------------------------- */

#if !IN_STG_CODE || IN_STGCRUN

EXTERN_INLINE StgWord
xchg(StgPtr p, StgWord w)
{
    StgWord result;
#if defined(NOSMP)
    result = *p;
    *p = w;
#elif i386_HOST_ARCH || x86_64_HOST_ARCH
    result = w;
    __asm__ __volatile__ (
        // NB: the xchg instruction is implicitly locked, so we do not
        // need a lock prefix here.
          "xchg %1,%0"
          :"+r" (result), "+m" (*p)
          : /* no input-only operands */
        );
#elif powerpc_HOST_ARCH
    __asm__ __volatile__ (
        "1:     lwarx     %0, 0, %2\n"
        "       stwcx.    %1, 0, %2\n"
        "       bne-      1b"
        :"=&r" (result)
        :"r" (w), "r" (p)
    );
#elif sparc_HOST_ARCH
    result = w;
    __asm__ __volatile__ (
        "swap %1,%0"
        : "+r" (result), "+m" (*p)
        : /* no input-only operands */
      );
#elif arm_HOST_ARCH && defined(arm_HOST_ARCH_PRE_ARMv6)
    __asm__ __volatile__ ("swp %0, %1, [%2]"
                         : "=&r" (result)
                         : "r" (w), "r" (p) : "memory");
#elif arm_HOST_ARCH && !defined(arm_HOST_ARCH_PRE_ARMv6)
    // swp instruction which is used in pre-ARMv6 code above
    // is deprecated in AMRv6 and later. ARM, Ltd. *highly* recommends
    // to use ldrex/strex instruction pair for the same purpose
    // see chapter: Synchronization and semaphores in ARM Architecture
    // Reference manual
    StgWord tmp;
    __asm__ __volatile__ (
                          "1:    ldrex  %0, [%3]\n"
                          "      strex  %1, %2, [%3]\n"
                          "      teq    %1, #1\n"
                          "      beq    1b\n"
#if !defined(arm_HOST_ARCH_PRE_ARMv7)
                          "      dmb\n"
#endif
                          : "=&r" (result), "=&r" (tmp)
                          : "r" (w), "r" (p)
                          : "memory"
                          );
#elif aarch64_HOST_ARCH
    StgWord tmp; 
    __asm__ __volatile__ (
                          "1:    ldaxr  %0, [%3]\n"
                          "      stlxr  %w1, %2, [%3]\n"
                          "      cbnz   %w1, 1b\n"
                          "      dmb sy\n"
                          : "=&r" (result), "=&r" (tmp)
                          : "r" (w), "r" (p)
                          : "memory"
                          );
#else
#error xchg() unimplemented on this architecture
#endif
    return result;
}

/*
 * CMPXCHG - the single-word atomic compare-and-exchange instruction.  Used
 * in the STM implementation.
 */
EXTERN_INLINE StgWord
cas(StgVolatilePtr p, StgWord o, StgWord n)
{
#if defined(NOSMP)
    StgWord result;
    result = *p;
    if (result == o) {
        *p = n;
    }
    return result;
#elif i386_HOST_ARCH || x86_64_HOST_ARCH
    __asm__ __volatile__ (
          "lock\ncmpxchg %3,%1"
          :"=a"(o), "+m" (*(volatile unsigned int *)p)
          :"0" (o), "r" (n));
    return o;
#elif powerpc_HOST_ARCH
    StgWord result;
    __asm__ __volatile__ (
        "1:     lwarx     %0, 0, %3\n"
        "       cmpw      %0, %1\n"
        "       bne       2f\n"
        "       stwcx.    %2, 0, %3\n"
        "       bne-      1b\n"
        "2:"
        :"=&r" (result)
        :"r" (o), "r" (n), "r" (p)
        :"cc", "memory"
    );
    return result;
#elif sparc_HOST_ARCH
    __asm__ __volatile__ (
        "cas [%1], %2, %0"
        : "+r" (n)
        : "r" (p), "r" (o)
        : "memory"
    );
    return n;
#elif arm_HOST_ARCH && defined(arm_HOST_ARCH_PRE_ARMv6)
    StgWord r;
    arm_atomic_spin_lock();
    r  = *p;
    if (r == o) { *p = n; }
    arm_atomic_spin_unlock();
    return r;
#elif arm_HOST_ARCH && !defined(arm_HOST_ARCH_PRE_ARMv6)
    StgWord result,tmp;

    __asm__ __volatile__(
        "1:     ldrex   %1, [%2]\n"
        "       mov     %0, #0\n"
        "       teq     %1, %3\n"
        "       it      eq\n"
        "       strexeq %0, %4, [%2]\n"
        "       teq     %0, #1\n"
        "       it      eq\n"
        "       beq     1b\n"
#if !defined(arm_HOST_ARCH_PRE_ARMv7)
        "       dmb\n"
#endif
                : "=&r"(tmp), "=&r"(result)
                : "r"(p), "r"(o), "r"(n)
                : "cc","memory");

    return result;
#elif aarch64_HOST_ARCH
    // Don't think we actually use tmp here, but leaving
    // it for consistent numbering
    StgWord result,tmp;

    __asm__ __volatile__(
        "1:     ldxr %1, [%2]\n"
        "       mov %w0, #0\n"
        "       cmp %1, %3\n"
        "       b.ne 2f\n"
        "       stxr %w0, %4, [%2]\n"
        "       cbnz %w0, 1b\n"
        "2:     dmb sy\n"
                : "=&r"(tmp), "=&r"(result)
                : "r"(p), "r"(o), "r"(n)
                : "cc","memory");

    return result;
#else
#error cas() unimplemented on this architecture
#endif
}

// RRN: Generalized to arbitrary increments to enable fetch-and-add in
// Haskell code (fetchAddIntArray#).
EXTERN_INLINE StgWord
atomic_inc(StgVolatilePtr p, StgWord incr)
{
#if defined(i386_HOST_ARCH) || defined(x86_64_HOST_ARCH)
    StgWord r;
    r = incr;
    __asm__ __volatile__ (
        "lock\nxadd %0,%1":
            "+r" (r), "+m" (*p):
    );
    return r + incr;
#else
    StgWord old, new;
    do {
        old = *p;
        new = old + incr;
    } while (cas(p, old, new) != old);
    return new;
#endif
}

EXTERN_INLINE StgWord
atomic_dec(StgVolatilePtr p)
{
#if defined(i386_HOST_ARCH) || defined(x86_64_HOST_ARCH)
    StgWord r;
    r = (StgWord)-1;
    __asm__ __volatile__ (
        "lock\nxadd %0,%1":
            "+r" (r), "+m" (*p):
    );
    return r-1;
#else
    StgWord old, new;
    do {
        old = *p;
        new = old - 1;
    } while (cas(p, old, new) != old);
    return new;
#endif
}

/*
 * Some architectures have a way to tell the CPU that we're in a
 * busy-wait loop, and the processor should look for something else to
 * do (such as run another hardware thread).
 */
EXTERN_INLINE void
busy_wait_nop(void)
{
#if defined(i386_HOST_ARCH) || defined(x86_64_HOST_ARCH)
    // On Intel, the busy-wait-nop instruction is called "pause",
    // which is actually represented as a nop with the rep prefix.
    // On processors before the P4 this behaves as a nop; on P4 and
    // later it might do something clever like yield to another
    // hyperthread.  In any case, Intel recommends putting one
    // of these in a spin lock loop.
    __asm__ __volatile__ ("rep; nop");
#else
    // nothing
#endif
}

#endif // !IN_STG_CODE

/*
 * We need to tell both the compiler AND the CPU about the barriers.
 * It's no good preventing the CPU from reordering the operations if
 * the compiler has already done so - hence the "memory" restriction
 * on each of the barriers below.
 */
EXTERN_INLINE void
write_barrier(void) {
#if defined(NOSMP)
    return;
#elif i386_HOST_ARCH || x86_64_HOST_ARCH
    __asm__ __volatile__ ("" : : : "memory");
#elif powerpc_HOST_ARCH
    __asm__ __volatile__ ("lwsync" : : : "memory");
#elif sparc_HOST_ARCH
    /* Sparc in TSO mode does not require store/store barriers. */
    __asm__ __volatile__ ("" : : : "memory");
#elif arm_HOST_ARCH && defined(arm_HOST_ARCH_PRE_ARMv7)
    __asm__ __volatile__ ("" : : : "memory");
#elif (arm_HOST_ARCH && !defined(arm_HOST_ARCH_PRE_ARMv7)) || aarch64_HOST_ARCH
    __asm__ __volatile__ ("dmb  st" : : : "memory");
#else
#error memory barriers unimplemented on this architecture
#endif
}

EXTERN_INLINE void
store_load_barrier(void) {
#if defined(NOSMP)
    return;
#elif i386_HOST_ARCH
    __asm__ __volatile__ ("lock; addl $0,0(%%esp)" : : : "memory");
#elif x86_64_HOST_ARCH
    __asm__ __volatile__ ("lock; addq $0,0(%%rsp)" : : : "memory");
#elif powerpc_HOST_ARCH
    __asm__ __volatile__ ("sync" : : : "memory");
#elif sparc_HOST_ARCH
    __asm__ __volatile__ ("membar #StoreLoad" : : : "memory");
#elif arm_HOST_ARCH && defined(arm_HOST_ARCH_PRE_ARMv7)
    __asm__ __volatile__ ("" : : : "memory");
#elif arm_HOST_ARCH && !defined(arm_HOST_ARCH_PRE_ARMv7)
    __asm__ __volatile__ ("dmb" : : : "memory");
#elif aarch64_HOST_ARCH
    __asm__ __volatile__ ("dmb sy" : : : "memory");
#else
#error memory barriers unimplemented on this architecture
#endif
}

EXTERN_INLINE void
load_load_barrier(void) {
#if defined(NOSMP)
    return;
#elif i386_HOST_ARCH
    __asm__ __volatile__ ("" : : : "memory");
#elif x86_64_HOST_ARCH
    __asm__ __volatile__ ("" : : : "memory");
#elif powerpc_HOST_ARCH
    __asm__ __volatile__ ("lwsync" : : : "memory");
#elif sparc_HOST_ARCH
    /* Sparc in TSO mode does not require load/load barriers. */
    __asm__ __volatile__ ("" : : : "memory");
#elif arm_HOST_ARCH && defined(arm_HOST_ARCH_PRE_ARMv7)
    __asm__ __volatile__ ("" : : : "memory");
#elif arm_HOST_ARCH && !defined(arm_HOST_ARCH_PRE_ARMv7)
    __asm__ __volatile__ ("dmb" : : : "memory");
#elif aarch64_HOST_ARCH
    __asm__ __volatile__ ("dmb sy" : : : "memory");
#else
#error memory barriers unimplemented on this architecture
#endif
}

// Load a pointer from a memory location that might be being modified
// concurrently.  This prevents the compiler from optimising away
// multiple loads of the memory location, as it might otherwise do in
// a busy wait loop for example.
#define VOLATILE_LOAD(p) (*((StgVolatilePtr)(p)))

/* ---------------------------------------------------------------------- */
#else /* !THREADED_RTS */

EXTERN_INLINE void write_barrier(void);
EXTERN_INLINE void store_load_barrier(void);
EXTERN_INLINE void load_load_barrier(void);
EXTERN_INLINE void write_barrier     () {} /* nothing */
EXTERN_INLINE void store_load_barrier() {} /* nothing */
EXTERN_INLINE void load_load_barrier () {} /* nothing */

#if !IN_STG_CODE || IN_STGCRUN
INLINE_HEADER StgWord
xchg(StgPtr p, StgWord w)
{
    StgWord old = *p;
    *p = w;
    return old;
}

EXTERN_INLINE StgWord cas(StgVolatilePtr p, StgWord o, StgWord n);
EXTERN_INLINE StgWord
cas(StgVolatilePtr p, StgWord o, StgWord n)
{
    StgWord result;
    result = *p;
    if (result == o) {
        *p = n;
    }
    return result;
}

EXTERN_INLINE StgWord atomic_inc(StgVolatilePtr p, StgWord incr);
EXTERN_INLINE StgWord
atomic_inc(StgVolatilePtr p, StgWord incr)
{
    return ((*p) += incr);
}


INLINE_HEADER StgWord
atomic_dec(StgVolatilePtr p)
{
    return --(*p);
}
#endif

#define VOLATILE_LOAD(p) ((StgWord)*((StgWord*)(p)))

#endif /* !THREADED_RTS */

#endif /* SMP_H */
{-# START_FILE include/ghc-7.10.2/stg/Ticky.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2009
 *
 * Declarations for counters used by ticky-ticky profiling.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * -------------------------------------------------------------------------- */


#ifndef TICKYCOUNTERS_H
#define TICKYCOUNTERS_H

/* These should probably be automatically generated in order to
   keep them consistent with the macros that use them (which are
   defined in Cmm.h) */

/* Here are all the counter declarations: */
/* If you change this list, make the corresponding change
   in RTS_TICKY_SYMBOLS in rts/Linker.c  */

/* These two are explicitly declared in rts/Ticky.c, and
   hence should not be extern'd except when using this header
   file from STG code; hence IN_STG_CODE */

#if IN_STG_CODE
extern W_ ticky_entry_ctrs[];
extern W_ top_ct[];
#endif

/* The rest are not explicity declared in rts/Ticky.c.  Instead
   we use the same trick as in the former StgTicky.h: recycle the 
   same declarations for both extern decls (which are included everywhere)
   and initializations (which only happen once) 
   TICKY_C is defined only in rts/Ticky.c */
#ifdef TICKY_C
#define INIT(ializer) = ializer
#define EXTERN
#else
#define INIT(ializer)
#define EXTERN extern
#endif

EXTERN StgInt ENT_VIA_NODE_ctr INIT(0);
EXTERN StgInt ENT_STATIC_THK_SINGLE_ctr INIT(0);
EXTERN StgInt ENT_DYN_THK_SINGLE_ctr INIT(0);
EXTERN StgInt ENT_STATIC_THK_MANY_ctr INIT(0);
EXTERN StgInt ENT_DYN_THK_MANY_ctr INIT(0);
EXTERN StgInt ENT_STATIC_FUN_DIRECT_ctr INIT(0);
EXTERN StgInt ENT_DYN_FUN_DIRECT_ctr INIT(0);
EXTERN StgInt ENT_STATIC_CON_ctr INIT(0);
EXTERN StgInt ENT_DYN_CON_ctr INIT(0);
EXTERN StgInt ENT_STATIC_IND_ctr INIT(0);
EXTERN StgInt ENT_DYN_IND_ctr INIT(0);
EXTERN StgInt ENT_PERM_IND_ctr INIT(0);
EXTERN StgInt ENT_PAP_ctr INIT(0);
EXTERN StgInt ENT_AP_ctr INIT(0);
EXTERN StgInt ENT_AP_STACK_ctr INIT(0);
EXTERN StgInt ENT_BH_ctr INIT(0);
EXTERN StgInt ENT_LNE_ctr INIT(0);

EXTERN StgInt UNKNOWN_CALL_ctr INIT(0);

EXTERN StgInt SLOW_CALL_fast_v16_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_v_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_f_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_d_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_l_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_n_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_p_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_pv_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_pp_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_ppv_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_ppp_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_pppv_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_pppp_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_ppppp_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_pppppp_ctr INIT(0);
EXTERN StgInt VERY_SLOW_CALL_ctr INIT(0);

EXTERN StgInt ticky_slow_call_unevald;
EXTERN StgInt SLOW_CALL_ctr INIT(0);
EXTERN StgInt MULTI_CHUNK_SLOW_CALL_ctr INIT(0);
EXTERN StgInt MULTI_CHUNK_SLOW_CALL_CHUNKS_ctr INIT(0);
EXTERN StgInt KNOWN_CALL_ctr INIT(0);
EXTERN StgInt KNOWN_CALL_TOO_FEW_ARGS_ctr INIT(0);
EXTERN StgInt KNOWN_CALL_EXTRA_ARGS_ctr INIT(0);
EXTERN StgInt SLOW_CALL_FUN_TOO_FEW_ctr INIT(0);
EXTERN StgInt SLOW_CALL_FUN_CORRECT_ctr INIT(0);
EXTERN StgInt SLOW_CALL_FUN_TOO_MANY_ctr INIT(0);
EXTERN StgInt SLOW_CALL_PAP_TOO_FEW_ctr INIT(0);
EXTERN StgInt SLOW_CALL_PAP_CORRECT_ctr INIT(0);
EXTERN StgInt SLOW_CALL_PAP_TOO_MANY_ctr INIT(0);
EXTERN StgInt SLOW_CALL_UNEVALD_ctr INIT(0);


EXTERN StgInt UPDF_OMITTED_ctr INIT(0);
EXTERN StgInt UPDF_PUSHED_ctr INIT(0);
EXTERN StgInt CATCHF_PUSHED_ctr INIT(0);
EXTERN StgInt UPDF_RCC_PUSHED_ctr INIT(0);
EXTERN StgInt UPDF_RCC_OMITTED_ctr INIT(0);

EXTERN StgInt UPD_SQUEEZED_ctr INIT(0);
EXTERN StgInt UPD_CON_IN_NEW_ctr INIT(0);
EXTERN StgInt UPD_CON_IN_PLACE_ctr INIT(0);
EXTERN StgInt UPD_PAP_IN_NEW_ctr INIT(0);
EXTERN StgInt UPD_PAP_IN_PLACE_ctr INIT(0);

EXTERN StgInt ALLOC_HEAP_ctr INIT(0);
EXTERN StgInt ALLOC_HEAP_tot INIT(0);

EXTERN StgInt HEAP_CHK_ctr INIT(0);
EXTERN StgInt STK_CHK_ctr INIT(0);

EXTERN StgInt ALLOC_RTS_ctr INIT(0);
EXTERN StgInt ALLOC_RTS_tot INIT(0);

EXTERN StgInt ALLOC_FUN_ctr INIT(0);
EXTERN StgInt ALLOC_FUN_adm INIT(0);
EXTERN StgInt ALLOC_FUN_gds INIT(0);
EXTERN StgInt ALLOC_FUN_slp INIT(0);

EXTERN StgInt UPD_NEW_IND_ctr INIT(0);
EXTERN StgInt UPD_NEW_PERM_IND_ctr INIT(0);
EXTERN StgInt UPD_OLD_IND_ctr INIT(0);
EXTERN StgInt UPD_OLD_PERM_IND_ctr INIT(0);

EXTERN StgInt UPD_BH_UPDATABLE_ctr INIT(0);
EXTERN StgInt UPD_CAF_BH_UPDATABLE_ctr INIT(0);
EXTERN StgInt UPD_CAF_BH_SINGLE_ENTRY_ctr INIT(0);

EXTERN StgInt GC_SEL_ABANDONED_ctr INIT(0);
EXTERN StgInt GC_SEL_MINOR_ctr INIT(0);
EXTERN StgInt GC_SEL_MAJOR_ctr INIT(0);

EXTERN StgInt GC_FAILED_PROMOTION_ctr INIT(0);

EXTERN StgInt ALLOC_UP_THK_ctr INIT(0);
EXTERN StgInt ALLOC_SE_THK_ctr INIT(0);
EXTERN StgInt ALLOC_THK_adm INIT(0);
EXTERN StgInt ALLOC_THK_gds INIT(0);
EXTERN StgInt ALLOC_THK_slp INIT(0);

EXTERN StgInt ALLOC_CON_ctr INIT(0);
EXTERN StgInt ALLOC_CON_adm INIT(0);
EXTERN StgInt ALLOC_CON_gds INIT(0);
EXTERN StgInt ALLOC_CON_slp INIT(0);

EXTERN StgInt ALLOC_TUP_ctr INIT(0);
EXTERN StgInt ALLOC_TUP_adm INIT(0);
EXTERN StgInt ALLOC_TUP_gds INIT(0);
EXTERN StgInt ALLOC_TUP_slp INIT(0);

EXTERN StgInt ALLOC_BH_ctr INIT(0);
EXTERN StgInt ALLOC_BH_adm INIT(0);
EXTERN StgInt ALLOC_BH_gds INIT(0);
EXTERN StgInt ALLOC_BH_slp INIT(0);

EXTERN StgInt ALLOC_PRIM_ctr INIT(0);
EXTERN StgInt ALLOC_PRIM_adm INIT(0);
EXTERN StgInt ALLOC_PRIM_gds INIT(0);
EXTERN StgInt ALLOC_PRIM_slp INIT(0);

EXTERN StgInt ALLOC_PAP_ctr INIT(0);
EXTERN StgInt ALLOC_PAP_adm INIT(0);
EXTERN StgInt ALLOC_PAP_gds INIT(0);
EXTERN StgInt ALLOC_PAP_slp INIT(0);

EXTERN StgInt ALLOC_TSO_ctr INIT(0);
EXTERN StgInt ALLOC_TSO_adm INIT(0);
EXTERN StgInt ALLOC_TSO_gds INIT(0);
EXTERN StgInt ALLOC_TSO_slp INIT(0);

EXTERN StgInt RET_NEW_ctr INIT(0);
EXTERN StgInt RET_OLD_ctr INIT(0);
EXTERN StgInt RET_UNBOXED_TUP_ctr INIT(0);

EXTERN StgInt RET_SEMI_loads_avoided INIT(0);

/* End of counter declarations. */

/* This is ugly, but the story is:
   We got rid of StgTicky.h, which was previously
   defining these macros for the benefit of C code
   so, we define them here instead (to be no-ops).
   (since those macros are only defined in Cmm.h) 

   Note that these macros must be defined whether
   TICKY_TICKY is defined or not. */
  
#ifndef CMINUSMINUS
#define TICK_BUMP_BY(ctr,n) ctr = (StgInt) ctr + n
#define TICK_BUMP(ctr)      TICK_BUMP_BY(ctr,1)

#define TICK_ALLOC_PRIM(x,y,z)
#define TICK_UPD_OLD_IND()
#define TICK_UPD_NEW_IND()
#define TICK_UPD_SQUEEZED()
#define TICK_ALLOC_HEAP_NOCTR(bytes)
#define TICK_GC_FAILED_PROMOTION()
#define TICK_ALLOC_TSO()
#define TICK_ALLOC_STACK(g)
#define TICK_ALLOC_UP_THK(g,s)
#define TICK_ALLOC_SE_THK(g,s)

#endif


#endif /* TICKYCOUNTERS_H */
{-# START_FILE include/ghc-7.10.2/stg/Types.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2004
 *
 * Various C datatypes used in the run-time system.  This is the
 * lowest-level include file, after ghcconfig.h and RtsConfig.h.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * NOTE: assumes #include "ghcconfig.h"
 *
 * Works with or without _POSIX_SOURCE.
 *
 * WARNING: Keep this file, MachDeps.h, and HsFFI.h in synch!
 *
 * ---------------------------------------------------------------------------*/

#ifndef STGTYPES_H
#define STGTYPES_H

/*
 * This module should define types *only*, all beginning with "Stg".
 *
 * Specifically:

        StgInt8,  16, 32, 64
        StgWord8, 16, 32, 64
        StgChar, StgFloat, StgDouble

        ***** All the same size (i.e. sizeof(void *)): *****
        StgPtr                  Basic pointer type
        StgWord                 Unit of heap allocation
        StgInt                  Signed version of StgWord
        StgAddr                 Generic address type

        StgBool, StgVoid, StgPtr, StgOffset,
        StgCode, StgStablePtr, StgFunPtr,
        StgUnion.
 */

/*
 * First, platform-dependent definitions of size-specific integers.
 */

typedef signed   char            StgInt8;
typedef unsigned char            StgWord8;

typedef signed   short           StgInt16;
typedef unsigned short           StgWord16;

#if SIZEOF_INT == 4
typedef signed   int             StgInt32;
typedef unsigned int             StgWord32;
#define FMT_Word32    "u"
#define FMT_HexWord32 "x"
#define FMT_Int32     "d"
#elif SIZEOF_LONG == 4
typedef signed   long            StgInt32;
typedef unsigned long            StgWord32;
#define FMT_Word32    "lu"
#define FMT_HexWord32 "lx"
#define FMT_Int32     "ld"
#else
#error GHC untested on this architecture: sizeof(int) != 4
#endif

#if SIZEOF_LONG == 8
typedef signed   long          StgInt64;
typedef unsigned long          StgWord64;
#define FMT_Word64    "lu"
#define FMT_HexWord64 "lx"
#define FMT_Int64     "ld"
#elif SIZEOF_LONG_LONG == 8
typedef signed long long int   StgInt64;
typedef unsigned long long int StgWord64;
#define FMT_Word64    "llu"
#define FMT_HexWord64 "llx"
#define FMT_Int64     "lld"
#else
#error cannot find a way to define StgInt64
#endif

typedef struct { StgWord64 h; StgWord64 l; } StgWord128;

typedef struct { StgWord128 h; StgWord128 l; } StgWord256;

typedef struct { StgWord256 h; StgWord256 l; } StgWord512;

/*
 * Define the standard word size we'll use on this machine: make it
 * big enough to hold a pointer.
 */

#if SIZEOF_VOID_P == 8
typedef StgInt64           StgInt;
typedef StgWord64          StgWord;
typedef StgInt32           StgHalfInt;
typedef StgWord32          StgHalfWord;
#define FMT_Word     FMT_Word64
#define FMT_HexWord  FMT_HexWord64
#define FMT_Int      FMT_Int64
#else
#if SIZEOF_VOID_P == 4
typedef StgInt32           StgInt;
typedef StgWord32          StgWord;
typedef StgInt16           StgHalfInt;
typedef StgWord16          StgHalfWord;
#define FMT_Word     FMT_Word32
#define FMT_HexWord  FMT_HexWord32
#define FMT_Int      FMT_Int32
#else
#error GHC untested on this architecture: sizeof(void *) != 4 or 8
#endif
#endif

#define W_MASK  (sizeof(W_)-1)

/*
 * Other commonly-used STG datatypes.
 */

typedef void*              StgAddr;
typedef StgWord32          StgChar;
typedef int                StgBool;
typedef float              StgFloat;
typedef double             StgDouble;
typedef StgWord*           StgPtr;           /* heap or stack pointer */
typedef StgWord volatile*  StgVolatilePtr;   /* pointer to volatile word   */
typedef StgWord            StgOffset;        /* byte offset within closure */
typedef StgWord8           StgCode;          /* close enough */
typedef void*              StgStablePtr;
typedef StgWord8*          StgByteArray;

/*
  Types for generated C functions when compiling via C.

  The C functions take no arguments, and return a pointer to the next
  function to be called use: Ptr to Fun that returns a Ptr to Fun
  which returns Ptr to void

  Note: Neither StgFunPtr not StgFun is quite right (that is,
  StgFunPtr != StgFun*).  So, the functions we define all have type
  StgFun but we always have to cast them to StgFunPtr when we assign
  them to something.
  The only way round this would be to write a recursive type but
  C only allows that if you're defining a struct or union.
*/

typedef void  *(*(*StgFunPtr)(void))(void);
typedef StgFunPtr StgFun(void);

#endif /* STGTYPES_H */
{-# START_FILE include/ghc-7.10.2/Stg.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * Top-level include file for everything required when compiling .hc
 * code.  NOTE: in .hc files, Stg.h must be included *before* any
 * other headers, because we define some register variables which must
 * be done before any inline functions are defined (some system
 * headers have been known to define the odd inline function).
 *
 * We generally try to keep as little visible as possible when
 * compiling .hc files.  So for example the definitions of the
 * InfoTable structs, closure structs and other RTS types are not
 * visible here.  The compiler knows enough about the representations
 * of these types to generate code which manipulates them directly
 * with pointer arithmetic.
 *
 * In ordinary C code, do not #include this file directly: #include
 * "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef STG_H
#define STG_H

/*
 * If we are compiling a .hc file, then we want all the register
 * variables.  This is the what happens if you #include "Stg.h" first:
 * we assume this is a .hc file, and set IN_STG_CODE==1, which later
 * causes the register variables to be enabled in stg/Regs.h.
 *
 * If instead "Rts.h" is included first, then we are compiling a
 * vanilla C file.  Everything from Stg.h is provided, except that
 * IN_STG_CODE is not defined, and the register variables will not be
 * active.
 */
#ifndef IN_STG_CODE
# define IN_STG_CODE 1

// Turn on C99 for .hc code.  This gives us the INFINITY and NAN
// constants from math.h, which we occasionally need to use in .hc (#1861)
# define _ISOC99_SOURCE

// We need _BSD_SOURCE so that math.h defines things like gamma
// on Linux
# define _BSD_SOURCE

// '_BSD_SOURCE' is deprecated since glibc-2.20
// in favour of '_DEFAULT_SOURCE'
# define _DEFAULT_SOURCE
#endif

#if IN_STG_CODE == 0 || defined(llvm_CC_FLAVOR)
// C compilers that use an LLVM back end (clang or llvm-gcc) do not
// correctly support global register variables so we make sure that
// we do not declare them for these compilers.
# define NO_GLOBAL_REG_DECLS    /* don't define fixed registers */
#endif

/* Configuration */
#include "ghcconfig.h"

/* The code generator calls the math functions directly in .hc code.
   NB. after configuration stuff above, because this sets #defines
   that depend on config info, such as __USE_FILE_OFFSET64 */
#include <math.h>

// On Solaris, we don't get the INFINITY and NAN constants unless we
// #define _STDC_C99, and we can't do that unless we also use -std=c99,
// because _STDC_C99 causes the headers to use C99 syntax (e.g. restrict).
// We aren't ready for -std=c99 yet, so define INFINITY/NAN by hand using
// the gcc builtins.
#if !defined(INFINITY)
#if defined(__GNUC__)
#define INFINITY __builtin_inf()
#else
#error No definition for INFINITY
#endif
#endif

#if !defined(NAN)
#if defined(__GNUC__)
#define NAN __builtin_nan("")
#else
#error No definition for NAN
#endif
#endif

/* -----------------------------------------------------------------------------
   Useful definitions
   -------------------------------------------------------------------------- */

/*
 * The C backend likes to refer to labels by just mentioning their
 * names.  However, when a symbol is declared as a variable in C, the
 * C compiler will implicitly dereference it when it occurs in source.
 * So we must subvert this behaviour for .hc files by declaring
 * variables as arrays, which eliminates the implicit dereference.
 */
#if IN_STG_CODE
#define RTS_VAR(x) (x)[]
#define RTS_DEREF(x) (*(x))
#else
#define RTS_VAR(x) x
#define RTS_DEREF(x) x
#endif

/* bit macros
 */
#define BITS_PER_BYTE 8
#define BITS_IN(x) (BITS_PER_BYTE * sizeof(x))

/* Compute offsets of struct fields
 */
#define STG_FIELD_OFFSET(s_type, field) ((StgWord)&(((s_type*)0)->field))

/*
 * 'Portable' inlining:
 * INLINE_HEADER is for inline functions in header files (macros)
 * STATIC_INLINE is for inline functions in source files
 * EXTERN_INLINE is for functions that we want to inline sometimes
 * (we also compile a static version of the function; see Inlines.c)
 */
#if defined(__GNUC__) || defined( __INTEL_COMPILER)

# define INLINE_HEADER static inline
# define INLINE_ME inline
# define STATIC_INLINE INLINE_HEADER

// The special "extern inline" behaviour is now only supported by gcc
// when _GNUC_GNU_INLINE__ is defined, and you have to use
// __attribute__((gnu_inline)).  So when we don't have this, we use
// ordinary static inline.
//
// Apple's gcc defines __GNUC_GNU_INLINE__ without providing
// gnu_inline, so we exclude MacOS X and fall through to the safe
// version.
//
#if defined(__GNUC_GNU_INLINE__) && !defined(__APPLE__)
#  if defined(KEEP_INLINES)
#    define EXTERN_INLINE inline
#  else
#    define EXTERN_INLINE extern inline __attribute__((gnu_inline))
#  endif
#else
#  if defined(KEEP_INLINES)
#    define EXTERN_INLINE
#  else
#    define EXTERN_INLINE INLINE_HEADER
#  endif
#endif

#elif defined(_MSC_VER)

# define INLINE_HEADER __inline static
# define INLINE_ME __inline
# define STATIC_INLINE INLINE_HEADER

# if defined(KEEP_INLINES)
#  define EXTERN_INLINE __inline
# else
#  define EXTERN_INLINE __inline extern
# endif

#else

# error "Don't know how to inline functions with your C compiler."

#endif


/*
 * GCC attributes
 */
#if defined(__GNUC__)
#define GNU_ATTRIBUTE(at) __attribute__((at))
#else
#define GNU_ATTRIBUTE(at)
#endif

#if __GNUC__ >= 3
#define GNUC3_ATTRIBUTE(at) __attribute__((at))
#else
#define GNUC3_ATTRIBUTE(at)
#endif

#if __GNUC__ > 4 || __GNUC__ == 4 && __GNUC_MINOR__ >= 3
#define GNUC_ATTR_HOT __attribute__((hot))
#else
#define GNUC_ATTR_HOT /* nothing */
#endif

#define STG_UNUSED    GNUC3_ATTRIBUTE(__unused__)

/* -----------------------------------------------------------------------------
   Global type definitions
   -------------------------------------------------------------------------- */

#include "MachDeps.h"
#include "stg/Types.h"

/* -----------------------------------------------------------------------------
   Shorthand forms
   -------------------------------------------------------------------------- */

typedef StgChar      C_;
typedef StgWord      W_;
typedef StgWord*  P_;
typedef StgInt    I_;
typedef StgWord StgWordArray[];
typedef StgFunPtr       F_;

#define EI_(X)          extern StgWordArray (X) GNU_ATTRIBUTE(aligned (8))
#define II_(X)          static StgWordArray (X) GNU_ATTRIBUTE(aligned (8))
#define IF_(f)    static StgFunPtr GNUC3_ATTRIBUTE(used) f(void)
#define FN_(f)    StgFunPtr f(void)
#define EF_(f)    extern StgFunPtr f()   /* See Note [External function prototypes] */

/* Note [External function prototypes]  See Trac #8965
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
The external-function macro EF_(F) used to be defined as
    extern StgFunPtr f(void)
i.e a function of zero arguments.  On most platforms this doesn't
matter very much: calls to these functions put the parameters in the
usual places anyway, and (with the exception of varargs) things just
work.

However, the ELFv2 ABI on ppc64 optimises stack allocation
(http://gcc.gnu.org/ml/gcc-patches/2013-11/msg01149.html): a call to a
function that has a prototype, is not varargs, and receives all parameters
in registers rather than on the stack does not require the caller to
allocate an argument save area.  The incorrect prototypes cause GCC to
believe that all functions declared this way can be called without an
argument save area, but if the callee has sufficiently many arguments then
it will expect that area to be present, and will thus corrupt the caller's
stack.  This happens in particular with calls to runInteractiveProcess in
libraries/process/cbits/runProcess.c, and led to Trac #8965.

The simplest fix appears to be to declare these external functions with an
unspecified argument list rather than a void argument list.  This is no
worse for platforms that don't care either way, and allows a successful
bootstrap of GHC 7.8 on little-endian Linux ppc64 (which uses the ELFv2
ABI).
*/


/* -----------------------------------------------------------------------------
   Tail calls
   -------------------------------------------------------------------------- */

#define JMP_(cont) return((StgFunPtr)(cont))

/* -----------------------------------------------------------------------------
   Other Stg stuff...
   -------------------------------------------------------------------------- */

#include "stg/DLL.h"
#include "stg/RtsMachRegs.h"
#include "stg/Regs.h"
#include "stg/Ticky.h"

#if IN_STG_CODE
/*
 * This is included later for RTS sources, after definitions of
 * StgInfoTable, StgClosure and so on.
 */
#include "stg/MiscClosures.h"
#endif

#include "stg/Prim.h" /* ghc-prim fallbacks */
#include "stg/SMP.h" // write_barrier() inline is required

/* -----------------------------------------------------------------------------
   Moving Floats and Doubles

   ASSIGN_FLT is for assigning a float to memory (usually the
              stack/heap).  The memory address is guaranteed to be
         StgWord aligned (currently == sizeof(void *)).

   PK_FLT     is for pulling a float out of memory.  The memory is
              guaranteed to be StgWord aligned.
   -------------------------------------------------------------------------- */

INLINE_HEADER void     ASSIGN_FLT (W_ [], StgFloat);
INLINE_HEADER StgFloat    PK_FLT     (W_ []);

#if ALIGNMENT_FLOAT <= ALIGNMENT_VOID_P

INLINE_HEADER void     ASSIGN_FLT(W_ p_dest[], StgFloat src) { *(StgFloat *)p_dest = src; }
INLINE_HEADER StgFloat PK_FLT    (W_ p_src[])                { return *(StgFloat *)p_src; }

#else  /* ALIGNMENT_FLOAT > ALIGNMENT_UNSIGNED_INT */

INLINE_HEADER void ASSIGN_FLT(W_ p_dest[], StgFloat src)
{
    float_thing y;
    y.f = src;
    *p_dest = y.fu;
}

INLINE_HEADER StgFloat PK_FLT(W_ p_src[])
{
    float_thing y;
    y.fu = *p_src;
    return(y.f);
}

#endif /* ALIGNMENT_FLOAT > ALIGNMENT_VOID_P */

#if ALIGNMENT_DOUBLE <= ALIGNMENT_VOID_P

INLINE_HEADER void     ASSIGN_DBL (W_ [], StgDouble);
INLINE_HEADER StgDouble   PK_DBL     (W_ []);

INLINE_HEADER void      ASSIGN_DBL(W_ p_dest[], StgDouble src) { *(StgDouble *)p_dest = src; }
INLINE_HEADER StgDouble PK_DBL    (W_ p_src[])                 { return *(StgDouble *)p_src; }

#else /* ALIGNMENT_DOUBLE > ALIGNMENT_VOID_P */

/* Sparc uses two floating point registers to hold a double.  We can
 * write ASSIGN_DBL and PK_DBL by directly accessing the registers
 * independently - unfortunately this code isn't writable in C, we
 * have to use inline assembler.
 */
#if sparc_HOST_ARCH

#define ASSIGN_DBL(dst0,src) \
    { StgPtr dst = (StgPtr)(dst0); \
      __asm__("st %2,%0\n\tst %R2,%1" : "=m" (((P_)(dst))[0]), \
   "=m" (((P_)(dst))[1]) : "f" (src)); \
    }

#define PK_DBL(src0) \
    ( { StgPtr src = (StgPtr)(src0); \
        register double d; \
      __asm__("ld %1,%0\n\tld %2,%R0" : "=f" (d) : \
   "m" (((P_)(src))[0]), "m" (((P_)(src))[1])); d; \
    } )

#else /* ! sparc_HOST_ARCH */

INLINE_HEADER void     ASSIGN_DBL (W_ [], StgDouble);
INLINE_HEADER StgDouble   PK_DBL     (W_ []);

typedef struct
  { StgWord dhi;
    StgWord dlo;
  } unpacked_double;

typedef union
  { StgDouble d;
    unpacked_double du;
  } double_thing;

INLINE_HEADER void ASSIGN_DBL(W_ p_dest[], StgDouble src)
{
    double_thing y;
    y.d = src;
    p_dest[0] = y.du.dhi;
    p_dest[1] = y.du.dlo;
}

/* GCC also works with this version, but it generates
   the same code as the previous one, and is not ANSI

#define ASSIGN_DBL( p_dest, src ) \
   *p_dest = ((double_thing) src).du.dhi; \
   *(p_dest+1) = ((double_thing) src).du.dlo \
*/

INLINE_HEADER StgDouble PK_DBL(W_ p_src[])
{
    double_thing y;
    y.du.dhi = p_src[0];
    y.du.dlo = p_src[1];
    return(y.d);
}

#endif /* ! sparc_HOST_ARCH */

#endif /* ALIGNMENT_DOUBLE > ALIGNMENT_UNSIGNED_INT */


/* -----------------------------------------------------------------------------
   Moving 64-bit quantities around

   ASSIGN_Word64      assign an StgWord64/StgInt64 to a memory location
   PK_Word64          load an StgWord64/StgInt64 from a amemory location

   In both cases the memory location might not be 64-bit aligned.
   -------------------------------------------------------------------------- */

#if SIZEOF_HSWORD == 4

typedef struct
  { StgWord dhi;
    StgWord dlo;
  } unpacked_double_word;

typedef union
  { StgInt64 i;
    unpacked_double_word iu;
  } int64_thing;

typedef union
  { StgWord64 w;
    unpacked_double_word wu;
  } word64_thing;

INLINE_HEADER void ASSIGN_Word64(W_ p_dest[], StgWord64 src)
{
    word64_thing y;
    y.w = src;
    p_dest[0] = y.wu.dhi;
    p_dest[1] = y.wu.dlo;
}

INLINE_HEADER StgWord64 PK_Word64(W_ p_src[])
{
    word64_thing y;
    y.wu.dhi = p_src[0];
    y.wu.dlo = p_src[1];
    return(y.w);
}

INLINE_HEADER void ASSIGN_Int64(W_ p_dest[], StgInt64 src)
{
    int64_thing y;
    y.i = src;
    p_dest[0] = y.iu.dhi;
    p_dest[1] = y.iu.dlo;
}

INLINE_HEADER StgInt64 PK_Int64(W_ p_src[])
{
    int64_thing y;
    y.iu.dhi = p_src[0];
    y.iu.dlo = p_src[1];
    return(y.i);
}

#elif SIZEOF_VOID_P == 8

INLINE_HEADER void ASSIGN_Word64(W_ p_dest[], StgWord64 src)
{
   p_dest[0] = src;
}

INLINE_HEADER StgWord64 PK_Word64(W_ p_src[])
{
    return p_src[0];
}

INLINE_HEADER void ASSIGN_Int64(W_ p_dest[], StgInt64 src)
{
    p_dest[0] = src;
}

INLINE_HEADER StgInt64 PK_Int64(W_ p_src[])
{
    return p_src[0];
}

#endif /* SIZEOF_HSWORD == 4 */

/* -----------------------------------------------------------------------------
   Split markers
   -------------------------------------------------------------------------- */

#if defined(USE_SPLIT_MARKERS)
#if defined(LEADING_UNDERSCORE)
#define __STG_SPLIT_MARKER __asm__("\n___stg_split_marker:");
#else
#define __STG_SPLIT_MARKER __asm__("\n__stg_split_marker:");
#endif
#else
#define __STG_SPLIT_MARKER /* nothing */
#endif

/* -----------------------------------------------------------------------------
   Integer multiply with overflow
   -------------------------------------------------------------------------- */

/* Multiply with overflow checking.
 *
 * This is tricky - the usual sign rules for add/subtract don't apply.
 *
 * On 32-bit machines we use gcc's 'long long' types, finding
 * overflow with some careful bit-twiddling.
 *
 * On 64-bit machines where gcc's 'long long' type is also 64-bits,
 * we use a crude approximation, testing whether either operand is
 * larger than 32-bits; if neither is, then we go ahead with the
 * multiplication.
 *
 * Return non-zero if there is any possibility that the signed multiply
 * of a and b might overflow.  Return zero only if you are absolutely sure
 * that it won't overflow.  If in doubt, return non-zero.
 */

#if SIZEOF_VOID_P == 4

#ifdef WORDS_BIGENDIAN
#define RTS_CARRY_IDX__ 0
#define RTS_REM_IDX__  1
#else
#define RTS_CARRY_IDX__ 1
#define RTS_REM_IDX__ 0
#endif

typedef union {
    StgInt64 l;
    StgInt32 i[2];
} long_long_u ;

#define mulIntMayOflo(a,b)       \
({                                              \
  StgInt32 r, c;           \
  long_long_u z;           \
  z.l = (StgInt64)a * (StgInt64)b;     \
  r = z.i[RTS_REM_IDX__];        \
  c = z.i[RTS_CARRY_IDX__];         \
  if (c == 0 || c == -1) {       \
    c = ((StgWord)((a^b) ^ r))         \
      >> (BITS_IN (I_) - 1);        \
  }                  \
  c;                                            \
})

/* Careful: the carry calculation above is extremely delicate.  Make sure
 * you test it thoroughly after changing it.
 */

#else

/* Approximate version when we don't have long arithmetic (on 64-bit archs) */

/* If we have n-bit words then we have n-1 bits after accounting for the
 * sign bit, so we can fit the result of multiplying 2 (n-1)/2-bit numbers */
#define HALF_POS_INT  (((I_)1) << ((BITS_IN (I_) - 1) / 2))
#define HALF_NEG_INT  (-HALF_POS_INT)

#define mulIntMayOflo(a,b)       \
({                                              \
  I_ c;              \
  if ((I_)a <= HALF_NEG_INT || a >= HALF_POS_INT    \
      || (I_)b <= HALF_NEG_INT || b >= HALF_POS_INT) {\
    c = 1;              \
  } else {              \
    c = 0;              \
  }                  \
  c;                                            \
})
#endif

#endif /* STG_H */
{-# START_FILE include/ghc-8.0.2/Cmm.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The University of Glasgow 2004-2013
 *
 * This file is included at the top of all .cmm source files (and
 * *only* .cmm files).  It defines a collection of useful macros for
 * making .cmm code a bit less error-prone to write, and a bit easier
 * on the eye for the reader.
 *
 * For the syntax of .cmm files, see the parser in ghc/compiler/cmm/CmmParse.y.
 *
 * Accessing fields of structures defined in the RTS header files is
 * done via automatically-generated macros in DerivedConstants.h.  For
 * example, where previously we used
 *
 *          CurrentTSO->what_next = x
 *
 * in C-- we now use
 *
 *          StgTSO_what_next(CurrentTSO) = x
 *
 * where the StgTSO_what_next() macro is automatically generated by
 * mkDerivedConstants.c.  If you need to access a field that doesn't
 * already have a macro, edit that file (it's pretty self-explanatory).
 *
 * -------------------------------------------------------------------------- */

#ifndef CMM_H
#define CMM_H

/*
 * In files that are included into both C and C-- (and perhaps
 * Haskell) sources, we sometimes need to conditionally compile bits
 * depending on the language.  CMINUSMINUS==1 in .cmm sources:
 */
#define CMINUSMINUS 1

#include "ghcconfig.h"

/* -----------------------------------------------------------------------------
   Types

   The following synonyms for C-- types are declared here:

     I8, I16, I32, I64    MachRep-style names for convenience

     W_                   is shorthand for the word type (== StgWord)
     F_                   shorthand for float  (F_ == StgFloat == C's float)
     D_                   shorthand for double (D_ == StgDouble == C's double)

     CInt                 has the same size as an int in C on this platform
     CLong                has the same size as a long in C on this platform

  --------------------------------------------------------------------------- */

#define I8  bits8
#define I16 bits16
#define I32 bits32
#define I64 bits64
#define P_  gcptr

#if SIZEOF_VOID_P == 4
#define W_ bits32
/* Maybe it's better to include MachDeps.h */
#define TAG_BITS                2
#elif SIZEOF_VOID_P == 8
#define W_ bits64
/* Maybe it's better to include MachDeps.h */
#define TAG_BITS                3
#else
#error Unknown word size
#endif

/*
 * The RTS must sometimes UNTAG a pointer before dereferencing it.
 * See the wiki page Commentary/Rts/HaskellExecution/PointerTagging
 */
#define TAG_MASK ((1 << TAG_BITS) - 1)
#define UNTAG(p) (p & ~TAG_MASK)
#define GETTAG(p) (p & TAG_MASK)

#if SIZEOF_INT == 4
#define CInt bits32
#elif SIZEOF_INT == 8
#define CInt bits64
#else
#error Unknown int size
#endif

#if SIZEOF_LONG == 4
#define CLong bits32
#elif SIZEOF_LONG == 8
#define CLong bits64
#else
#error Unknown long size
#endif

#define F_   float32
#define D_   float64
#define L_   bits64
#define V16_ bits128
#define V32_ bits256
#define V64_ bits512

#define SIZEOF_StgDouble 8
#define SIZEOF_StgWord64 8

/* -----------------------------------------------------------------------------
   Misc useful stuff
   -------------------------------------------------------------------------- */

#define ccall foreign "C"

#define NULL (0::W_)

#define STRING(name,str)                        \
  section "rodata" {                            \
        name : bits8[] str;                     \
  }                                             \

#ifdef TABLES_NEXT_TO_CODE
#define RET_LBL(f) f##_info
#else
#define RET_LBL(f) f##_ret
#endif

#ifdef TABLES_NEXT_TO_CODE
#define ENTRY_LBL(f) f##_info
#else
#define ENTRY_LBL(f) f##_entry
#endif

/* -----------------------------------------------------------------------------
   Byte/word macros

   Everything in C-- is in byte offsets (well, most things).  We use
   some macros to allow us to express offsets in words and to try to
   avoid byte/word confusion.
   -------------------------------------------------------------------------- */

#define SIZEOF_W  SIZEOF_VOID_P
#define W_MASK    (SIZEOF_W-1)

#if SIZEOF_W == 4
#define W_SHIFT 2
#elif SIZEOF_W == 8
#define W_SHIFT 3
#endif

/* Converting quantities of words to bytes */
#define WDS(n) ((n)*SIZEOF_W)

/*
 * Converting quantities of bytes to words
 * NB. these work on *unsigned* values only
 */
#define BYTES_TO_WDS(n) ((n) / SIZEOF_W)
#define ROUNDUP_BYTES_TO_WDS(n) (((n) + SIZEOF_W - 1) / SIZEOF_W)

/* TO_W_(n) converts n to W_ type from a smaller type */
#if SIZEOF_W == 4
#define TO_W_(x) %sx32(x)
#define HALF_W_(x) %lobits16(x)
#elif SIZEOF_W == 8
#define TO_W_(x) %sx64(x)
#define HALF_W_(x) %lobits32(x)
#endif

#if SIZEOF_INT == 4 && SIZEOF_W == 8
#define W_TO_INT(x) %lobits32(x)
#elif SIZEOF_INT == SIZEOF_W
#define W_TO_INT(x) (x)
#endif

#if SIZEOF_LONG == 4 && SIZEOF_W == 8
#define W_TO_LONG(x) %lobits32(x)
#elif SIZEOF_LONG == SIZEOF_W
#define W_TO_LONG(x) (x)
#endif

/* -----------------------------------------------------------------------------
   Heap/stack access, and adjusting the heap/stack pointers.
   -------------------------------------------------------------------------- */

#define Sp(n)  W_[Sp + WDS(n)]
#define Hp(n)  W_[Hp + WDS(n)]

#define Sp_adj(n) Sp = Sp + WDS(n)  /* pronounced "spadge" */
#define Hp_adj(n) Hp = Hp + WDS(n)

/* -----------------------------------------------------------------------------
   Assertions and Debuggery
   -------------------------------------------------------------------------- */

#ifdef DEBUG
#define ASSERT(predicate)                       \
        if (predicate) {                        \
            /*null*/;                           \
        } else {                                \
            foreign "C" _assertFail(NULL, __LINE__) never returns; \
        }
#else
#define ASSERT(p) /* nothing */
#endif

#ifdef DEBUG
#define DEBUG_ONLY(s) s
#else
#define DEBUG_ONLY(s) /* nothing */
#endif

/*
 * The IF_DEBUG macro is useful for debug messages that depend on one
 * of the RTS debug options.  For example:
 *
 *   IF_DEBUG(RtsFlags_DebugFlags_apply,
 *      foreign "C" fprintf(stderr, stg_ap_0_ret_str));
 *
 * Note the syntax is slightly different to the C version of this macro.
 */
#ifdef DEBUG
#define IF_DEBUG(c,s)  if (RtsFlags_DebugFlags_##c(RtsFlags) != 0::I32) { s; }
#else
#define IF_DEBUG(c,s)  /* nothing */
#endif

/* -----------------------------------------------------------------------------
   Entering

   It isn't safe to "enter" every closure.  Functions in particular
   have no entry code as such; their entry point contains the code to
   apply the function.

   ToDo: range should end in N_CLOSURE_TYPES-1, not N_CLOSURE_TYPES,
   but switch doesn't allow us to use exprs there yet.

   If R1 points to a tagged object it points either to
   * A constructor.
   * A function with arity <= TAG_MASK.
   In both cases the right thing to do is to return.
   Note: it is rather lucky that we can use the tag bits to do this
         for both objects. Maybe it points to a brittle design?

   Indirections can contain tagged pointers, so their tag is checked.
   -------------------------------------------------------------------------- */

#ifdef PROFILING

// When profiling, we cannot shortcut ENTER() by checking the tag,
// because LDV profiling relies on entering closures to mark them as
// "used".

#define LOAD_INFO(ret,x)                        \
    info = %INFO_PTR(UNTAG(x));

#define UNTAG_IF_PROF(x) UNTAG(x)

#else

#define LOAD_INFO(ret,x)                        \
  if (GETTAG(x) != 0) {                         \
      ret(x);                                   \
  }                                             \
  info = %INFO_PTR(x);

#define UNTAG_IF_PROF(x) (x) /* already untagged */

#endif

// We need two versions of ENTER():
//  - ENTER(x) takes the closure as an argument and uses return(),
//    for use in civilized code where the stack is handled by GHC
//
//  - ENTER_NOSTACK() where the closure is in R1, and returns are
//    explicit jumps, for use when we are doing the stack management
//    ourselves.

#define ENTER(x) ENTER_(return,x)
#define ENTER_R1() ENTER_(RET_R1,R1)

#define RET_R1(x) jump %ENTRY_CODE(Sp(0)) [R1]

#define ENTER_(ret,x)                                   \
 again:                                                 \
  W_ info;                                              \
  LOAD_INFO(ret,x)                                       \
  switch [INVALID_OBJECT .. N_CLOSURE_TYPES]            \
         (TO_W_( %INFO_TYPE(%STD_INFO(info)) )) {       \
  case                                                  \
    IND,                                                \
    IND_PERM,                                           \
    IND_STATIC:                                         \
   {                                                    \
      x = StgInd_indirectee(x);                         \
      goto again;                                       \
   }                                                    \
  case                                                  \
    FUN,                                                \
    FUN_1_0,                                            \
    FUN_0_1,                                            \
    FUN_2_0,                                            \
    FUN_1_1,                                            \
    FUN_0_2,                                            \
    FUN_STATIC,                                         \
    BCO,                                                \
    PAP:                                                \
   {                                                    \
       ret(x);                                          \
   }                                                    \
  default:                                              \
   {                                                    \
       x = UNTAG_IF_PROF(x);                            \
       jump %ENTRY_CODE(info) (x);                      \
   }                                                    \
  }

// The FUN cases almost never happen: a pointer to a non-static FUN
// should always be tagged.  This unfortunately isn't true for the
// interpreter right now, which leaves untagged FUNs on the stack.

/* -----------------------------------------------------------------------------
   Constants.
   -------------------------------------------------------------------------- */

#include "rts/Constants.h"
#include "DerivedConstants.h"
#include "rts/storage/ClosureTypes.h"
#include "rts/storage/FunTypes.h"
#include "rts/storage/SMPClosureOps.h"
#include "rts/OSThreads.h"

/*
 * Need MachRegs, because some of the RTS code is conditionally
 * compiled based on REG_R1, REG_R2, etc.
 */
#include "stg/RtsMachRegs.h"

#include "rts/prof/LDV.h"

#undef BLOCK_SIZE
#undef MBLOCK_SIZE
#include "rts/storage/Block.h"  /* For Bdescr() */


#define MyCapability()  (BaseReg - OFFSET_Capability_r)

/* -------------------------------------------------------------------------
   Info tables
   ------------------------------------------------------------------------- */

#if defined(PROFILING)
#define PROF_HDR_FIELDS(w_,hdr1,hdr2)          \
  w_ hdr1,                                     \
  w_ hdr2,
#else
#define PROF_HDR_FIELDS(w_,hdr1,hdr2) /* nothing */
#endif

/* -------------------------------------------------------------------------
   Allocation and garbage collection
   ------------------------------------------------------------------------- */

/*
 * ALLOC_PRIM is for allocating memory on the heap for a primitive
 * object.  It is used all over PrimOps.cmm.
 *
 * We make the simplifying assumption that the "admin" part of a
 * primitive closure is just the header when calculating sizes for
 * ticky-ticky.  It's not clear whether eg. the size field of an array
 * should be counted as "admin", or the various fields of a BCO.
 */
#define ALLOC_PRIM(bytes)                                       \
   HP_CHK_GEN_TICKY(bytes);                                     \
   TICK_ALLOC_PRIM(SIZEOF_StgHeader,bytes-SIZEOF_StgHeader,0);  \
   CCCS_ALLOC(bytes);

#define HEAP_CHECK(bytes,failure)                       \
    TICK_BUMP(HEAP_CHK_ctr);                            \
    Hp = Hp + (bytes);                                  \
    if (Hp > HpLim) { HpAlloc = (bytes); failure; }     \
    TICK_ALLOC_HEAP_NOCTR(bytes);

#define ALLOC_PRIM_WITH_CUSTOM_FAILURE(bytes,failure)           \
    HEAP_CHECK(bytes,failure)                                   \
    TICK_ALLOC_PRIM(SIZEOF_StgHeader,bytes-SIZEOF_StgHeader,0); \
    CCCS_ALLOC(bytes);

#define ALLOC_PRIM_(bytes,fun)                                  \
    ALLOC_PRIM_WITH_CUSTOM_FAILURE(bytes,GC_PRIM(fun));

#define ALLOC_PRIM_P(bytes,fun,arg)                             \
    ALLOC_PRIM_WITH_CUSTOM_FAILURE(bytes,GC_PRIM_P(fun,arg));

#define ALLOC_PRIM_N(bytes,fun,arg)                             \
    ALLOC_PRIM_WITH_CUSTOM_FAILURE(bytes,GC_PRIM_N(fun,arg));

/* CCS_ALLOC wants the size in words, because ccs->mem_alloc is in words */
#define CCCS_ALLOC(__alloc) CCS_ALLOC(BYTES_TO_WDS(__alloc), CCCS)

#define HP_CHK_GEN_TICKY(bytes)                 \
   HP_CHK_GEN(bytes);                           \
   TICK_ALLOC_HEAP_NOCTR(bytes);

#define HP_CHK_P(bytes, fun, arg)               \
   HEAP_CHECK(bytes, GC_PRIM_P(fun,arg))

// TODO I'm not seeing where ALLOC_P_TICKY is used; can it be removed?
//         -NSF March 2013
#define ALLOC_P_TICKY(bytes, fun, arg)          \
   HP_CHK_P(bytes);                             \
   TICK_ALLOC_HEAP_NOCTR(bytes);

#define CHECK_GC()                                                      \
  (bdescr_link(CurrentNursery) == NULL ||                               \
   generation_n_new_large_words(W_[g0]) >= TO_W_(CLong[large_alloc_lim]))

// allocate() allocates from the nursery, so we check to see
// whether the nursery is nearly empty in any function that uses
// allocate() - this includes many of the primops.
//
// HACK alert: the __L__ stuff is here to coax the common-block
// eliminator into commoning up the call stg_gc_noregs() with the same
// code that gets generated by a STK_CHK_GEN() in the same proc.  We
// also need an if (0) { goto __L__; } so that the __L__ label isn't
// optimised away by the control-flow optimiser prior to common-block
// elimination (it will be optimised away later).
//
// This saves some code in gmp-wrappers.cmm where we have lots of
// MAYBE_GC() in the same proc as STK_CHK_GEN().
//
#define MAYBE_GC(retry)                         \
    if (CHECK_GC()) {                           \
        HpAlloc = 0;                            \
        goto __L__;                             \
  __L__:                                        \
        call stg_gc_noregs();                   \
        goto retry;                             \
   }                                            \
   if (0) { goto __L__; }

#define GC_PRIM(fun)                            \
        jump stg_gc_prim(fun);

// Version of GC_PRIM for use in low-level Cmm.  We can call
// stg_gc_prim, because it takes one argument and therefore has a
// platform-independent calling convention (Note [Syntax of .cmm
// files] in CmmParse.y).
#define GC_PRIM_LL(fun)                         \
        R1 = fun;                               \
        jump stg_gc_prim [R1];

// We pass the fun as the second argument, because the arg is
// usually already in the first argument position (R1), so this
// avoids moving it to a different register / stack slot.
#define GC_PRIM_N(fun,arg)                      \
        jump stg_gc_prim_n(arg,fun);

#define GC_PRIM_P(fun,arg)                      \
        jump stg_gc_prim_p(arg,fun);

#define GC_PRIM_P_LL(fun,arg)                   \
        R1 = arg;                               \
        R2 = fun;                               \
        jump stg_gc_prim_p_ll [R1,R2];

#define GC_PRIM_PP(fun,arg1,arg2)               \
        jump stg_gc_prim_pp(arg1,arg2,fun);

#define MAYBE_GC_(fun)                          \
    if (CHECK_GC()) {                           \
        HpAlloc = 0;                            \
        GC_PRIM(fun)                            \
   }

#define MAYBE_GC_N(fun,arg)                     \
    if (CHECK_GC()) {                           \
        HpAlloc = 0;                            \
        GC_PRIM_N(fun,arg)                      \
   }

#define MAYBE_GC_P(fun,arg)                     \
    if (CHECK_GC()) {                           \
        HpAlloc = 0;                            \
        GC_PRIM_P(fun,arg)                      \
   }

#define MAYBE_GC_PP(fun,arg1,arg2)              \
    if (CHECK_GC()) {                           \
        HpAlloc = 0;                            \
        GC_PRIM_PP(fun,arg1,arg2)               \
   }

#define STK_CHK_LL(n, fun)                      \
    TICK_BUMP(STK_CHK_ctr);                     \
    if (Sp - (n) < SpLim) {                     \
        GC_PRIM_LL(fun)                         \
    }

#define STK_CHK_P_LL(n, fun, arg)               \
    TICK_BUMP(STK_CHK_ctr);                     \
    if (Sp - (n) < SpLim) {                     \
        GC_PRIM_P_LL(fun,arg)                   \
    }

#define STK_CHK_PP(n, fun, arg1, arg2)          \
    TICK_BUMP(STK_CHK_ctr);                     \
    if (Sp - (n) < SpLim) {                     \
        GC_PRIM_PP(fun,arg1,arg2)               \
    }

#define STK_CHK_ENTER(n, closure)               \
    TICK_BUMP(STK_CHK_ctr);                     \
    if (Sp - (n) < SpLim) {                     \
        jump __stg_gc_enter_1(closure);         \
    }

// A funky heap check used by AutoApply.cmm

#define HP_CHK_NP_ASSIGN_SP0(size,f)                    \
    HEAP_CHECK(size, Sp(0) = f; jump __stg_gc_enter_1 [R1];)

/* -----------------------------------------------------------------------------
   Closure headers
   -------------------------------------------------------------------------- */

/*
 * This is really ugly, since we don't do the rest of StgHeader this
 * way.  The problem is that values from DerivedConstants.h cannot be
 * dependent on the way (SMP, PROF etc.).  For SIZEOF_StgHeader we get
 * the value from GHC, but it seems like too much trouble to do that
 * for StgThunkHeader.
 */
#define SIZEOF_StgThunkHeader SIZEOF_StgHeader+SIZEOF_StgSMPThunkHeader

#define StgThunk_payload(__ptr__,__ix__) \
    W_[__ptr__+SIZEOF_StgThunkHeader+ WDS(__ix__)]

/* -----------------------------------------------------------------------------
   Closures
   -------------------------------------------------------------------------- */

/* The offset of the payload of an array */
#define BYTE_ARR_CTS(arr)  ((arr) + SIZEOF_StgArrBytes)

/* The number of words allocated in an array payload */
#define BYTE_ARR_WDS(arr) ROUNDUP_BYTES_TO_WDS(StgArrBytes_bytes(arr))

/* Getting/setting the info pointer of a closure */
#define SET_INFO(p,info) StgHeader_info(p) = info
#define GET_INFO(p) StgHeader_info(p)

/* Determine the size of an ordinary closure from its info table */
#define sizeW_fromITBL(itbl) \
  SIZEOF_StgHeader + WDS(%INFO_PTRS(itbl)) + WDS(%INFO_NPTRS(itbl))

/* NB. duplicated from InfoTables.h! */
#define BITMAP_SIZE(bitmap) ((bitmap) & BITMAP_SIZE_MASK)
#define BITMAP_BITS(bitmap) ((bitmap) >> BITMAP_BITS_SHIFT)

/* Debugging macros */
#define LOOKS_LIKE_INFO_PTR(p)                                  \
   ((p) != NULL &&                                              \
    LOOKS_LIKE_INFO_PTR_NOT_NULL(p))

#define LOOKS_LIKE_INFO_PTR_NOT_NULL(p)                         \
   ( (TO_W_(%INFO_TYPE(%STD_INFO(p))) != INVALID_OBJECT) &&     \
     (TO_W_(%INFO_TYPE(%STD_INFO(p))) <  N_CLOSURE_TYPES))

#define LOOKS_LIKE_CLOSURE_PTR(p) (LOOKS_LIKE_INFO_PTR(GET_INFO(UNTAG(p))))

/*
 * The layout of the StgFunInfoExtra part of an info table changes
 * depending on TABLES_NEXT_TO_CODE.  So we define field access
 * macros which use the appropriate version here:
 */
#ifdef TABLES_NEXT_TO_CODE
/*
 * when TABLES_NEXT_TO_CODE, slow_apply is stored as an offset
 * instead of the normal pointer.
 */

#define StgFunInfoExtra_slow_apply(fun_info)    \
        (TO_W_(StgFunInfoExtraRev_slow_apply_offset(fun_info))    \
               + (fun_info) + SIZEOF_StgFunInfoExtraRev + SIZEOF_StgInfoTable)

#define StgFunInfoExtra_fun_type(i)   StgFunInfoExtraRev_fun_type(i)
#define StgFunInfoExtra_arity(i)      StgFunInfoExtraRev_arity(i)
#define StgFunInfoExtra_bitmap(i)     StgFunInfoExtraRev_bitmap(i)
#else
#define StgFunInfoExtra_slow_apply(i) StgFunInfoExtraFwd_slow_apply(i)
#define StgFunInfoExtra_fun_type(i)   StgFunInfoExtraFwd_fun_type(i)
#define StgFunInfoExtra_arity(i)      StgFunInfoExtraFwd_arity(i)
#define StgFunInfoExtra_bitmap(i)     StgFunInfoExtraFwd_bitmap(i)
#endif

#define mutArrCardMask ((1 << MUT_ARR_PTRS_CARD_BITS) - 1)
#define mutArrPtrCardDown(i) ((i) >> MUT_ARR_PTRS_CARD_BITS)
#define mutArrPtrCardUp(i)   (((i) + mutArrCardMask) >> MUT_ARR_PTRS_CARD_BITS)
#define mutArrPtrsCardWords(n) ROUNDUP_BYTES_TO_WDS(mutArrPtrCardUp(n))

#if defined(PROFILING) || (!defined(THREADED_RTS) && defined(DEBUG))
#define OVERWRITING_CLOSURE(c) foreign "C" overwritingClosure(c "ptr")
#define OVERWRITING_CLOSURE_OFS(c,n) \
    foreign "C" overwritingClosureOfs(c "ptr", n)
#else
#define OVERWRITING_CLOSURE(c) /* nothing */
#define OVERWRITING_CLOSURE_OFS(c,n) /* nothing */
#endif

#ifdef THREADED_RTS
#define prim_write_barrier prim %write_barrier()
#else
#define prim_write_barrier /* nothing */
#endif

/* -----------------------------------------------------------------------------
   Ticky macros
   -------------------------------------------------------------------------- */

#ifdef TICKY_TICKY
#define TICK_BUMP_BY(ctr,n) CLong[ctr] = CLong[ctr] + n
#else
#define TICK_BUMP_BY(ctr,n) /* nothing */
#endif

#define TICK_BUMP(ctr)      TICK_BUMP_BY(ctr,1)

#define TICK_ENT_DYN_IND()              TICK_BUMP(ENT_DYN_IND_ctr)
#define TICK_ENT_DYN_THK()              TICK_BUMP(ENT_DYN_THK_ctr)
#define TICK_ENT_VIA_NODE()             TICK_BUMP(ENT_VIA_NODE_ctr)
#define TICK_ENT_STATIC_IND()           TICK_BUMP(ENT_STATIC_IND_ctr)
#define TICK_ENT_PERM_IND()             TICK_BUMP(ENT_PERM_IND_ctr)
#define TICK_ENT_PAP()                  TICK_BUMP(ENT_PAP_ctr)
#define TICK_ENT_AP()                   TICK_BUMP(ENT_AP_ctr)
#define TICK_ENT_AP_STACK()             TICK_BUMP(ENT_AP_STACK_ctr)
#define TICK_ENT_BH()                   TICK_BUMP(ENT_BH_ctr)
#define TICK_ENT_LNE()                  TICK_BUMP(ENT_LNE_ctr)
#define TICK_UNKNOWN_CALL()             TICK_BUMP(UNKNOWN_CALL_ctr)
#define TICK_UPDF_PUSHED()              TICK_BUMP(UPDF_PUSHED_ctr)
#define TICK_CATCHF_PUSHED()            TICK_BUMP(CATCHF_PUSHED_ctr)
#define TICK_UPDF_OMITTED()             TICK_BUMP(UPDF_OMITTED_ctr)
#define TICK_UPD_NEW_IND()              TICK_BUMP(UPD_NEW_IND_ctr)
#define TICK_UPD_NEW_PERM_IND()         TICK_BUMP(UPD_NEW_PERM_IND_ctr)
#define TICK_UPD_OLD_IND()              TICK_BUMP(UPD_OLD_IND_ctr)
#define TICK_UPD_OLD_PERM_IND()         TICK_BUMP(UPD_OLD_PERM_IND_ctr)

#define TICK_SLOW_CALL_FUN_TOO_FEW()    TICK_BUMP(SLOW_CALL_FUN_TOO_FEW_ctr)
#define TICK_SLOW_CALL_FUN_CORRECT()    TICK_BUMP(SLOW_CALL_FUN_CORRECT_ctr)
#define TICK_SLOW_CALL_FUN_TOO_MANY()   TICK_BUMP(SLOW_CALL_FUN_TOO_MANY_ctr)
#define TICK_SLOW_CALL_PAP_TOO_FEW()    TICK_BUMP(SLOW_CALL_PAP_TOO_FEW_ctr)
#define TICK_SLOW_CALL_PAP_CORRECT()    TICK_BUMP(SLOW_CALL_PAP_CORRECT_ctr)
#define TICK_SLOW_CALL_PAP_TOO_MANY()   TICK_BUMP(SLOW_CALL_PAP_TOO_MANY_ctr)

#define TICK_SLOW_CALL_fast_v16()       TICK_BUMP(SLOW_CALL_fast_v16_ctr)
#define TICK_SLOW_CALL_fast_v()         TICK_BUMP(SLOW_CALL_fast_v_ctr)
#define TICK_SLOW_CALL_fast_p()         TICK_BUMP(SLOW_CALL_fast_p_ctr)
#define TICK_SLOW_CALL_fast_pv()        TICK_BUMP(SLOW_CALL_fast_pv_ctr)
#define TICK_SLOW_CALL_fast_pp()        TICK_BUMP(SLOW_CALL_fast_pp_ctr)
#define TICK_SLOW_CALL_fast_ppv()       TICK_BUMP(SLOW_CALL_fast_ppv_ctr)
#define TICK_SLOW_CALL_fast_ppp()       TICK_BUMP(SLOW_CALL_fast_ppp_ctr)
#define TICK_SLOW_CALL_fast_pppv()      TICK_BUMP(SLOW_CALL_fast_pppv_ctr)
#define TICK_SLOW_CALL_fast_pppp()      TICK_BUMP(SLOW_CALL_fast_pppp_ctr)
#define TICK_SLOW_CALL_fast_ppppp()     TICK_BUMP(SLOW_CALL_fast_ppppp_ctr)
#define TICK_SLOW_CALL_fast_pppppp()    TICK_BUMP(SLOW_CALL_fast_pppppp_ctr)
#define TICK_VERY_SLOW_CALL()           TICK_BUMP(VERY_SLOW_CALL_ctr)

/* NOTE: TICK_HISTO_BY and TICK_HISTO
   currently have no effect.
   The old code for it didn't typecheck and I
   just commented it out to get ticky to work.
   - krc 1/2007 */

#define TICK_HISTO_BY(histo,n,i) /* nothing */

#define TICK_HISTO(histo,n) TICK_HISTO_BY(histo,n,1)

/* An unboxed tuple with n components. */
#define TICK_RET_UNBOXED_TUP(n)                 \
  TICK_BUMP(RET_UNBOXED_TUP_ctr++);             \
  TICK_HISTO(RET_UNBOXED_TUP,n)

/*
 * A slow call with n arguments.  In the unevald case, this call has
 * already been counted once, so don't count it again.
 */
#define TICK_SLOW_CALL(n)                       \
  TICK_BUMP(SLOW_CALL_ctr);                     \
  TICK_HISTO(SLOW_CALL,n)

/*
 * This slow call was found to be to an unevaluated function; undo the
 * ticks we did in TICK_SLOW_CALL.
 */
#define TICK_SLOW_CALL_UNEVALD(n)               \
  TICK_BUMP(SLOW_CALL_UNEVALD_ctr);             \
  TICK_BUMP_BY(SLOW_CALL_ctr,-1);               \
  TICK_HISTO_BY(SLOW_CALL,n,-1);

/* Updating a closure with a new CON */
#define TICK_UPD_CON_IN_NEW(n)                  \
  TICK_BUMP(UPD_CON_IN_NEW_ctr);                \
  TICK_HISTO(UPD_CON_IN_NEW,n)

#define TICK_ALLOC_HEAP_NOCTR(bytes)            \
    TICK_BUMP(ALLOC_RTS_ctr);                   \
    TICK_BUMP_BY(ALLOC_RTS_tot,bytes)

/* -----------------------------------------------------------------------------
   Saving and restoring STG registers

   STG registers must be saved around a C call, just in case the STG
   register is mapped to a caller-saves machine register.  Normally we
   don't need to worry about this the code generator has already
   loaded any live STG registers into variables for us, but in
   hand-written low-level Cmm code where we don't know which registers
   are live, we might have to save them all.
   -------------------------------------------------------------------------- */

#define SAVE_STGREGS                            \
    W_ r1, r2, r3,  r4,  r5,  r6,  r7,  r8;     \
    F_ f1, f2, f3, f4, f5, f6;                  \
    D_ d1, d2, d3, d4, d5, d6;                  \
    L_ l1;                                      \
                                                \
    r1 = R1;                                    \
    r2 = R2;                                    \
    r3 = R3;                                    \
    r4 = R4;                                    \
    r5 = R5;                                    \
    r6 = R6;                                    \
    r7 = R7;                                    \
    r8 = R8;                                    \
                                                \
    f1 = F1;                                    \
    f2 = F2;                                    \
    f3 = F3;                                    \
    f4 = F4;                                    \
    f5 = F5;                                    \
    f6 = F6;                                    \
                                                \
    d1 = D1;                                    \
    d2 = D2;                                    \
    d3 = D3;                                    \
    d4 = D4;                                    \
    d5 = D5;                                    \
    d6 = D6;                                    \
                                                \
    l1 = L1;


#define RESTORE_STGREGS                         \
    R1 = r1;                                    \
    R2 = r2;                                    \
    R3 = r3;                                    \
    R4 = r4;                                    \
    R5 = r5;                                    \
    R6 = r6;                                    \
    R7 = r7;                                    \
    R8 = r8;                                    \
                                                \
    F1 = f1;                                    \
    F2 = f2;                                    \
    F3 = f3;                                    \
    F4 = f4;                                    \
    F5 = f5;                                    \
    F6 = f6;                                    \
                                                \
    D1 = d1;                                    \
    D2 = d2;                                    \
    D3 = d3;                                    \
    D4 = d4;                                    \
    D5 = d5;                                    \
    D6 = d6;                                    \
                                                \
    L1 = l1;

/* -----------------------------------------------------------------------------
   Misc junk
   -------------------------------------------------------------------------- */

#define NO_TREC                   stg_NO_TREC_closure
#define END_TSO_QUEUE             stg_END_TSO_QUEUE_closure
#define STM_AWOKEN                stg_STM_AWOKEN_closure
#define END_INVARIANT_CHECK_QUEUE stg_END_INVARIANT_CHECK_QUEUE_closure

#define recordMutableCap(p, gen)                                        \
  W_ __bd;                                                              \
  W_ mut_list;                                                          \
  mut_list = Capability_mut_lists(MyCapability()) + WDS(gen);           \
 __bd = W_[mut_list];                                                   \
  if (bdescr_free(__bd) >= bdescr_start(__bd) + BLOCK_SIZE) {           \
      W_ __new_bd;                                                      \
      ("ptr" __new_bd) = foreign "C" allocBlock_lock();                 \
      bdescr_link(__new_bd) = __bd;                                     \
      __bd = __new_bd;                                                  \
      W_[mut_list] = __bd;                                              \
  }                                                                     \
  W_ free;                                                              \
  free = bdescr_free(__bd);                                             \
  W_[free] = p;                                                         \
  bdescr_free(__bd) = free + WDS(1);

#define recordMutable(p)                                        \
      P_ __p;                                                   \
      W_ __bd;                                                  \
      W_ __gen;                                                 \
      __p = p;                                                  \
      __bd = Bdescr(__p);                                       \
      __gen = TO_W_(bdescr_gen_no(__bd));                       \
      if (__gen > 0) { recordMutableCap(__p, __gen); }

/* -----------------------------------------------------------------------------
   Arrays
   -------------------------------------------------------------------------- */

/* Complete function body for the clone family of (mutable) array ops.
   Defined as a macro to avoid function call overhead or code
   duplication. */
#define cloneArray(info, src, offset, n)                       \
    W_ words, size;                                            \
    gcptr dst, dst_p, src_p;                                   \
                                                               \
    again: MAYBE_GC(again);                                    \
                                                               \
    size = n + mutArrPtrsCardWords(n);                         \
    words = BYTES_TO_WDS(SIZEOF_StgMutArrPtrs) + size;         \
    ("ptr" dst) = ccall allocate(MyCapability() "ptr", words); \
    TICK_ALLOC_PRIM(SIZEOF_StgMutArrPtrs, WDS(size), 0);       \
                                                               \
    SET_HDR(dst, info, CCCS);                                  \
    StgMutArrPtrs_ptrs(dst) = n;                               \
    StgMutArrPtrs_size(dst) = size;                            \
                                                               \
    dst_p = dst + SIZEOF_StgMutArrPtrs;                        \
    src_p = src + SIZEOF_StgMutArrPtrs + WDS(offset);          \
  while:                                                       \
    if (n != 0) {                                              \
        n = n - 1;                                             \
        W_[dst_p] = W_[src_p];                                 \
        dst_p = dst_p + WDS(1);                                \
        src_p = src_p + WDS(1);                                \
        goto while;                                            \
    }                                                          \
                                                               \
    return (dst);

#define copyArray(src, src_off, dst, dst_off, n)                  \
  W_ dst_elems_p, dst_p, src_p, dst_cards_p, bytes;               \
                                                                  \
    if ((n) != 0) {                                               \
        SET_HDR(dst, stg_MUT_ARR_PTRS_DIRTY_info, CCCS);          \
                                                                  \
        dst_elems_p = (dst) + SIZEOF_StgMutArrPtrs;               \
        dst_p = dst_elems_p + WDS(dst_off);                       \
        src_p = (src) + SIZEOF_StgMutArrPtrs + WDS(src_off);      \
        bytes = WDS(n);                                           \
                                                                  \
        prim %memcpy(dst_p, src_p, bytes, SIZEOF_W);              \
                                                                  \
        dst_cards_p = dst_elems_p + WDS(StgMutArrPtrs_ptrs(dst)); \
        setCards(dst_cards_p, dst_off, n);                        \
    }                                                             \
                                                                  \
    return ();

#define copyMutableArray(src, src_off, dst, dst_off, n)           \
  W_ dst_elems_p, dst_p, src_p, dst_cards_p, bytes;               \
                                                                  \
    if ((n) != 0) {                                               \
        SET_HDR(dst, stg_MUT_ARR_PTRS_DIRTY_info, CCCS);          \
                                                                  \
        dst_elems_p = (dst) + SIZEOF_StgMutArrPtrs;               \
        dst_p = dst_elems_p + WDS(dst_off);                       \
        src_p = (src) + SIZEOF_StgMutArrPtrs + WDS(src_off);      \
        bytes = WDS(n);                                           \
                                                                  \
        if ((src) == (dst)) {                                     \
            prim %memmove(dst_p, src_p, bytes, SIZEOF_W);         \
        } else {                                                  \
            prim %memcpy(dst_p, src_p, bytes, SIZEOF_W);          \
        }                                                         \
                                                                  \
        dst_cards_p = dst_elems_p + WDS(StgMutArrPtrs_ptrs(dst)); \
        setCards(dst_cards_p, dst_off, n);                        \
    }                                                             \
                                                                  \
    return ();

/*
 * Set the cards in the cards table pointed to by dst_cards_p for an
 * update to n elements, starting at element dst_off.
 */
#define setCards(dst_cards_p, dst_off, n)                      \
    W_ __start_card, __end_card, __cards;                      \
    __start_card = mutArrPtrCardDown(dst_off);                 \
    __end_card = mutArrPtrCardDown((dst_off) + (n) - 1);       \
    __cards = __end_card - __start_card + 1;                   \
    prim %memset((dst_cards_p) + __start_card, 1, __cards, 1);

/* Complete function body for the clone family of small (mutable)
   array ops. Defined as a macro to avoid function call overhead or
   code duplication. */
#define cloneSmallArray(info, src, offset, n)                  \
    W_ words, size;                                            \
    gcptr dst, dst_p, src_p;                                   \
                                                               \
    again: MAYBE_GC(again);                                    \
                                                               \
    words = BYTES_TO_WDS(SIZEOF_StgSmallMutArrPtrs) + n;       \
    ("ptr" dst) = ccall allocate(MyCapability() "ptr", words); \
    TICK_ALLOC_PRIM(SIZEOF_StgSmallMutArrPtrs, WDS(n), 0);     \
                                                               \
    SET_HDR(dst, info, CCCS);                                  \
    StgSmallMutArrPtrs_ptrs(dst) = n;                          \
                                                               \
    dst_p = dst + SIZEOF_StgSmallMutArrPtrs;                   \
    src_p = src + SIZEOF_StgSmallMutArrPtrs + WDS(offset);     \
  while:                                                       \
    if (n != 0) {                                              \
        n = n - 1;                                             \
        W_[dst_p] = W_[src_p];                                 \
        dst_p = dst_p + WDS(1);                                \
        src_p = src_p + WDS(1);                                \
        goto while;                                            \
    }                                                          \
                                                               \
    return (dst);

#endif /* CMM_H */
{-# START_FILE include/ghc-8.0.2/DerivedConstants.h #-}
/* This file is created automatically.  Do not edit by hand.*/

#define CONTROL_GROUP_CONST_291 291
#define STD_HDR_SIZE 1
#define PROF_HDR_SIZE 2
#define BLOCK_SIZE 4096
#define MBLOCK_SIZE 1048576
#define BLOCKS_PER_MBLOCK 252
#define TICKY_BIN_COUNT 9
#define OFFSET_StgRegTable_rR1 0
#define OFFSET_StgRegTable_rR2 8
#define OFFSET_StgRegTable_rR3 16
#define OFFSET_StgRegTable_rR4 24
#define OFFSET_StgRegTable_rR5 32
#define OFFSET_StgRegTable_rR6 40
#define OFFSET_StgRegTable_rR7 48
#define OFFSET_StgRegTable_rR8 56
#define OFFSET_StgRegTable_rR9 64
#define OFFSET_StgRegTable_rR10 72
#define OFFSET_StgRegTable_rF1 80
#define OFFSET_StgRegTable_rF2 84
#define OFFSET_StgRegTable_rF3 88
#define OFFSET_StgRegTable_rF4 92
#define OFFSET_StgRegTable_rF5 96
#define OFFSET_StgRegTable_rF6 100
#define OFFSET_StgRegTable_rD1 104
#define OFFSET_StgRegTable_rD2 112
#define OFFSET_StgRegTable_rD3 120
#define OFFSET_StgRegTable_rD4 128
#define OFFSET_StgRegTable_rD5 136
#define OFFSET_StgRegTable_rD6 144
#define OFFSET_StgRegTable_rXMM1 152
#define OFFSET_StgRegTable_rXMM2 168
#define OFFSET_StgRegTable_rXMM3 184
#define OFFSET_StgRegTable_rXMM4 200
#define OFFSET_StgRegTable_rXMM5 216
#define OFFSET_StgRegTable_rXMM6 232
#define OFFSET_StgRegTable_rYMM1 248
#define OFFSET_StgRegTable_rYMM2 280
#define OFFSET_StgRegTable_rYMM3 312
#define OFFSET_StgRegTable_rYMM4 344
#define OFFSET_StgRegTable_rYMM5 376
#define OFFSET_StgRegTable_rYMM6 408
#define OFFSET_StgRegTable_rZMM1 440
#define OFFSET_StgRegTable_rZMM2 504
#define OFFSET_StgRegTable_rZMM3 568
#define OFFSET_StgRegTable_rZMM4 632
#define OFFSET_StgRegTable_rZMM5 696
#define OFFSET_StgRegTable_rZMM6 760
#define OFFSET_StgRegTable_rL1 824
#define OFFSET_StgRegTable_rSp 832
#define OFFSET_StgRegTable_rSpLim 840
#define OFFSET_StgRegTable_rHp 848
#define OFFSET_StgRegTable_rHpLim 856
#define OFFSET_StgRegTable_rCCCS 864
#define OFFSET_StgRegTable_rCurrentTSO 872
#define OFFSET_StgRegTable_rCurrentNursery 888
#define OFFSET_StgRegTable_rHpAlloc 904
#define OFFSET_StgRegTable_rRet 912
#define REP_StgRegTable_rRet b64
#define StgRegTable_rRet(__ptr__) REP_StgRegTable_rRet[__ptr__+OFFSET_StgRegTable_rRet]
#define OFFSET_StgRegTable_rNursery 880
#define REP_StgRegTable_rNursery b64
#define StgRegTable_rNursery(__ptr__) REP_StgRegTable_rNursery[__ptr__+OFFSET_StgRegTable_rNursery]
#define OFFSET_stgEagerBlackholeInfo -24
#define OFFSET_stgGCEnter1 -16
#define OFFSET_stgGCFun -8
#define OFFSET_Capability_r 24
#define OFFSET_Capability_lock 1096
#define OFFSET_Capability_no 944
#define REP_Capability_no b32
#define Capability_no(__ptr__) REP_Capability_no[__ptr__+OFFSET_Capability_no]
#define OFFSET_Capability_mut_lists 1016
#define REP_Capability_mut_lists b64
#define Capability_mut_lists(__ptr__) REP_Capability_mut_lists[__ptr__+OFFSET_Capability_mut_lists]
#define OFFSET_Capability_context_switch 1064
#define REP_Capability_context_switch b32
#define Capability_context_switch(__ptr__) REP_Capability_context_switch[__ptr__+OFFSET_Capability_context_switch]
#define OFFSET_Capability_interrupt 1068
#define REP_Capability_interrupt b32
#define Capability_interrupt(__ptr__) REP_Capability_interrupt[__ptr__+OFFSET_Capability_interrupt]
#define OFFSET_Capability_sparks 1192
#define REP_Capability_sparks b64
#define Capability_sparks(__ptr__) REP_Capability_sparks[__ptr__+OFFSET_Capability_sparks]
#define OFFSET_Capability_total_allocated 1072
#define REP_Capability_total_allocated b64
#define Capability_total_allocated(__ptr__) REP_Capability_total_allocated[__ptr__+OFFSET_Capability_total_allocated]
#define OFFSET_Capability_weak_ptr_list_hd 1048
#define REP_Capability_weak_ptr_list_hd b64
#define Capability_weak_ptr_list_hd(__ptr__) REP_Capability_weak_ptr_list_hd[__ptr__+OFFSET_Capability_weak_ptr_list_hd]
#define OFFSET_Capability_weak_ptr_list_tl 1056
#define REP_Capability_weak_ptr_list_tl b64
#define Capability_weak_ptr_list_tl(__ptr__) REP_Capability_weak_ptr_list_tl[__ptr__+OFFSET_Capability_weak_ptr_list_tl]
#define OFFSET_bdescr_start 0
#define REP_bdescr_start b64
#define bdescr_start(__ptr__) REP_bdescr_start[__ptr__+OFFSET_bdescr_start]
#define OFFSET_bdescr_free 8
#define REP_bdescr_free b64
#define bdescr_free(__ptr__) REP_bdescr_free[__ptr__+OFFSET_bdescr_free]
#define OFFSET_bdescr_blocks 48
#define REP_bdescr_blocks b32
#define bdescr_blocks(__ptr__) REP_bdescr_blocks[__ptr__+OFFSET_bdescr_blocks]
#define OFFSET_bdescr_gen_no 40
#define REP_bdescr_gen_no b16
#define bdescr_gen_no(__ptr__) REP_bdescr_gen_no[__ptr__+OFFSET_bdescr_gen_no]
#define OFFSET_bdescr_link 16
#define REP_bdescr_link b64
#define bdescr_link(__ptr__) REP_bdescr_link[__ptr__+OFFSET_bdescr_link]
#define SIZEOF_generation 328
#define OFFSET_generation_n_new_large_words 56
#define REP_generation_n_new_large_words b64
#define generation_n_new_large_words(__ptr__) REP_generation_n_new_large_words[__ptr__+OFFSET_generation_n_new_large_words]
#define OFFSET_generation_weak_ptr_list 80
#define REP_generation_weak_ptr_list b64
#define generation_weak_ptr_list(__ptr__) REP_generation_weak_ptr_list[__ptr__+OFFSET_generation_weak_ptr_list]
#define SIZEOF_CostCentreStack 96
#define OFFSET_CostCentreStack_ccsID 0
#define REP_CostCentreStack_ccsID b64
#define CostCentreStack_ccsID(__ptr__) REP_CostCentreStack_ccsID[__ptr__+OFFSET_CostCentreStack_ccsID]
#define OFFSET_CostCentreStack_mem_alloc 72
#define REP_CostCentreStack_mem_alloc b64
#define CostCentreStack_mem_alloc(__ptr__) REP_CostCentreStack_mem_alloc[__ptr__+OFFSET_CostCentreStack_mem_alloc]
#define OFFSET_CostCentreStack_scc_count 48
#define REP_CostCentreStack_scc_count b64
#define CostCentreStack_scc_count(__ptr__) REP_CostCentreStack_scc_count[__ptr__+OFFSET_CostCentreStack_scc_count]
#define OFFSET_CostCentreStack_prevStack 16
#define REP_CostCentreStack_prevStack b64
#define CostCentreStack_prevStack(__ptr__) REP_CostCentreStack_prevStack[__ptr__+OFFSET_CostCentreStack_prevStack]
#define OFFSET_CostCentre_ccID 0
#define REP_CostCentre_ccID b64
#define CostCentre_ccID(__ptr__) REP_CostCentre_ccID[__ptr__+OFFSET_CostCentre_ccID]
#define OFFSET_CostCentre_link 56
#define REP_CostCentre_link b64
#define CostCentre_link(__ptr__) REP_CostCentre_link[__ptr__+OFFSET_CostCentre_link]
#define OFFSET_StgHeader_info 0
#define REP_StgHeader_info b64
#define StgHeader_info(__ptr__) REP_StgHeader_info[__ptr__+OFFSET_StgHeader_info]
#define OFFSET_StgHeader_ccs 8
#define REP_StgHeader_ccs b64
#define StgHeader_ccs(__ptr__) REP_StgHeader_ccs[__ptr__+OFFSET_StgHeader_ccs]
#define OFFSET_StgHeader_ldvw 16
#define REP_StgHeader_ldvw b64
#define StgHeader_ldvw(__ptr__) REP_StgHeader_ldvw[__ptr__+OFFSET_StgHeader_ldvw]
#define SIZEOF_StgSMPThunkHeader 8
#define OFFSET_StgClosure_payload 0
#define StgClosure_payload(__ptr__,__ix__) W_[__ptr__+SIZEOF_StgHeader+OFFSET_StgClosure_payload + WDS(__ix__)]
#define OFFSET_StgEntCounter_allocs 48
#define REP_StgEntCounter_allocs b64
#define StgEntCounter_allocs(__ptr__) REP_StgEntCounter_allocs[__ptr__+OFFSET_StgEntCounter_allocs]
#define OFFSET_StgEntCounter_allocd 16
#define REP_StgEntCounter_allocd b64
#define StgEntCounter_allocd(__ptr__) REP_StgEntCounter_allocd[__ptr__+OFFSET_StgEntCounter_allocd]
#define OFFSET_StgEntCounter_registeredp 0
#define REP_StgEntCounter_registeredp b64
#define StgEntCounter_registeredp(__ptr__) REP_StgEntCounter_registeredp[__ptr__+OFFSET_StgEntCounter_registeredp]
#define OFFSET_StgEntCounter_link 56
#define REP_StgEntCounter_link b64
#define StgEntCounter_link(__ptr__) REP_StgEntCounter_link[__ptr__+OFFSET_StgEntCounter_link]
#define OFFSET_StgEntCounter_entry_count 40
#define REP_StgEntCounter_entry_count b64
#define StgEntCounter_entry_count(__ptr__) REP_StgEntCounter_entry_count[__ptr__+OFFSET_StgEntCounter_entry_count]
#define SIZEOF_StgUpdateFrame_NoHdr 8
#define SIZEOF_StgUpdateFrame (SIZEOF_StgHeader+8)
#define SIZEOF_StgCatchFrame_NoHdr 16
#define SIZEOF_StgCatchFrame (SIZEOF_StgHeader+16)
#define SIZEOF_StgStopFrame_NoHdr 0
#define SIZEOF_StgStopFrame (SIZEOF_StgHeader+0)
#define SIZEOF_StgMutArrPtrs_NoHdr 16
#define SIZEOF_StgMutArrPtrs (SIZEOF_StgHeader+16)
#define OFFSET_StgMutArrPtrs_ptrs 0
#define REP_StgMutArrPtrs_ptrs b64
#define StgMutArrPtrs_ptrs(__ptr__) REP_StgMutArrPtrs_ptrs[__ptr__+SIZEOF_StgHeader+OFFSET_StgMutArrPtrs_ptrs]
#define OFFSET_StgMutArrPtrs_size 8
#define REP_StgMutArrPtrs_size b64
#define StgMutArrPtrs_size(__ptr__) REP_StgMutArrPtrs_size[__ptr__+SIZEOF_StgHeader+OFFSET_StgMutArrPtrs_size]
#define SIZEOF_StgSmallMutArrPtrs_NoHdr 8
#define SIZEOF_StgSmallMutArrPtrs (SIZEOF_StgHeader+8)
#define OFFSET_StgSmallMutArrPtrs_ptrs 0
#define REP_StgSmallMutArrPtrs_ptrs b64
#define StgSmallMutArrPtrs_ptrs(__ptr__) REP_StgSmallMutArrPtrs_ptrs[__ptr__+SIZEOF_StgHeader+OFFSET_StgSmallMutArrPtrs_ptrs]
#define SIZEOF_StgArrBytes_NoHdr 8
#define SIZEOF_StgArrBytes (SIZEOF_StgHeader+8)
#define OFFSET_StgArrBytes_bytes 0
#define REP_StgArrBytes_bytes b64
#define StgArrBytes_bytes(__ptr__) REP_StgArrBytes_bytes[__ptr__+SIZEOF_StgHeader+OFFSET_StgArrBytes_bytes]
#define OFFSET_StgArrBytes_payload 8
#define StgArrBytes_payload(__ptr__,__ix__) W_[__ptr__+SIZEOF_StgHeader+OFFSET_StgArrBytes_payload + WDS(__ix__)]
#define OFFSET_StgTSO__link 0
#define REP_StgTSO__link b64
#define StgTSO__link(__ptr__) REP_StgTSO__link[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO__link]
#define OFFSET_StgTSO_global_link 8
#define REP_StgTSO_global_link b64
#define StgTSO_global_link(__ptr__) REP_StgTSO_global_link[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_global_link]
#define OFFSET_StgTSO_what_next 24
#define REP_StgTSO_what_next b16
#define StgTSO_what_next(__ptr__) REP_StgTSO_what_next[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_what_next]
#define OFFSET_StgTSO_why_blocked 26
#define REP_StgTSO_why_blocked b16
#define StgTSO_why_blocked(__ptr__) REP_StgTSO_why_blocked[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_why_blocked]
#define OFFSET_StgTSO_block_info 32
#define REP_StgTSO_block_info b64
#define StgTSO_block_info(__ptr__) REP_StgTSO_block_info[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_block_info]
#define OFFSET_StgTSO_blocked_exceptions 80
#define REP_StgTSO_blocked_exceptions b64
#define StgTSO_blocked_exceptions(__ptr__) REP_StgTSO_blocked_exceptions[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_blocked_exceptions]
#define OFFSET_StgTSO_id 40
#define REP_StgTSO_id b32
#define StgTSO_id(__ptr__) REP_StgTSO_id[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_id]
#define OFFSET_StgTSO_cap 64
#define REP_StgTSO_cap b64
#define StgTSO_cap(__ptr__) REP_StgTSO_cap[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_cap]
#define OFFSET_StgTSO_saved_errno 44
#define REP_StgTSO_saved_errno b32
#define StgTSO_saved_errno(__ptr__) REP_StgTSO_saved_errno[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_saved_errno]
#define OFFSET_StgTSO_trec 72
#define REP_StgTSO_trec b64
#define StgTSO_trec(__ptr__) REP_StgTSO_trec[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_trec]
#define OFFSET_StgTSO_flags 28
#define REP_StgTSO_flags b32
#define StgTSO_flags(__ptr__) REP_StgTSO_flags[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_flags]
#define OFFSET_StgTSO_dirty 48
#define REP_StgTSO_dirty b32
#define StgTSO_dirty(__ptr__) REP_StgTSO_dirty[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_dirty]
#define OFFSET_StgTSO_bq 88
#define REP_StgTSO_bq b64
#define StgTSO_bq(__ptr__) REP_StgTSO_bq[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_bq]
#define OFFSET_StgTSO_alloc_limit 96
#define REP_StgTSO_alloc_limit b64
#define StgTSO_alloc_limit(__ptr__) REP_StgTSO_alloc_limit[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_alloc_limit]
#define OFFSET_StgTSO_cccs 112
#define REP_StgTSO_cccs b64
#define StgTSO_cccs(__ptr__) REP_StgTSO_cccs[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_cccs]
#define OFFSET_StgTSO_stackobj 16
#define REP_StgTSO_stackobj b64
#define StgTSO_stackobj(__ptr__) REP_StgTSO_stackobj[__ptr__+SIZEOF_StgHeader+OFFSET_StgTSO_stackobj]
#define OFFSET_StgStack_sp 8
#define REP_StgStack_sp b64
#define StgStack_sp(__ptr__) REP_StgStack_sp[__ptr__+SIZEOF_StgHeader+OFFSET_StgStack_sp]
#define OFFSET_StgStack_stack 16
#define OFFSET_StgStack_stack_size 0
#define REP_StgStack_stack_size b32
#define StgStack_stack_size(__ptr__) REP_StgStack_stack_size[__ptr__+SIZEOF_StgHeader+OFFSET_StgStack_stack_size]
#define OFFSET_StgStack_dirty 4
#define REP_StgStack_dirty b32
#define StgStack_dirty(__ptr__) REP_StgStack_dirty[__ptr__+SIZEOF_StgHeader+OFFSET_StgStack_dirty]
#define SIZEOF_StgTSOProfInfo 8
#define OFFSET_StgUpdateFrame_updatee 0
#define REP_StgUpdateFrame_updatee b64
#define StgUpdateFrame_updatee(__ptr__) REP_StgUpdateFrame_updatee[__ptr__+SIZEOF_StgHeader+OFFSET_StgUpdateFrame_updatee]
#define OFFSET_StgCatchFrame_handler 8
#define REP_StgCatchFrame_handler b64
#define StgCatchFrame_handler(__ptr__) REP_StgCatchFrame_handler[__ptr__+SIZEOF_StgHeader+OFFSET_StgCatchFrame_handler]
#define OFFSET_StgCatchFrame_exceptions_blocked 0
#define REP_StgCatchFrame_exceptions_blocked b64
#define StgCatchFrame_exceptions_blocked(__ptr__) REP_StgCatchFrame_exceptions_blocked[__ptr__+SIZEOF_StgHeader+OFFSET_StgCatchFrame_exceptions_blocked]
#define SIZEOF_StgPAP_NoHdr 16
#define SIZEOF_StgPAP (SIZEOF_StgHeader+16)
#define OFFSET_StgPAP_n_args 4
#define REP_StgPAP_n_args b32
#define StgPAP_n_args(__ptr__) REP_StgPAP_n_args[__ptr__+SIZEOF_StgHeader+OFFSET_StgPAP_n_args]
#define OFFSET_StgPAP_fun 8
#define REP_StgPAP_fun gcptr
#define StgPAP_fun(__ptr__) REP_StgPAP_fun[__ptr__+SIZEOF_StgHeader+OFFSET_StgPAP_fun]
#define OFFSET_StgPAP_arity 0
#define REP_StgPAP_arity b32
#define StgPAP_arity(__ptr__) REP_StgPAP_arity[__ptr__+SIZEOF_StgHeader+OFFSET_StgPAP_arity]
#define OFFSET_StgPAP_payload 16
#define StgPAP_payload(__ptr__,__ix__) W_[__ptr__+SIZEOF_StgHeader+OFFSET_StgPAP_payload + WDS(__ix__)]
#define SIZEOF_StgAP_NoThunkHdr 16
#define SIZEOF_StgAP_NoHdr 24
#define SIZEOF_StgAP (SIZEOF_StgHeader+24)
#define OFFSET_StgAP_n_args 12
#define REP_StgAP_n_args b32
#define StgAP_n_args(__ptr__) REP_StgAP_n_args[__ptr__+SIZEOF_StgHeader+OFFSET_StgAP_n_args]
#define OFFSET_StgAP_fun 16
#define REP_StgAP_fun gcptr
#define StgAP_fun(__ptr__) REP_StgAP_fun[__ptr__+SIZEOF_StgHeader+OFFSET_StgAP_fun]
#define OFFSET_StgAP_payload 24
#define StgAP_payload(__ptr__,__ix__) W_[__ptr__+SIZEOF_StgHeader+OFFSET_StgAP_payload + WDS(__ix__)]
#define SIZEOF_StgAP_STACK_NoThunkHdr 16
#define SIZEOF_StgAP_STACK_NoHdr 24
#define SIZEOF_StgAP_STACK (SIZEOF_StgHeader+24)
#define OFFSET_StgAP_STACK_size 8
#define REP_StgAP_STACK_size b64
#define StgAP_STACK_size(__ptr__) REP_StgAP_STACK_size[__ptr__+SIZEOF_StgHeader+OFFSET_StgAP_STACK_size]
#define OFFSET_StgAP_STACK_fun 16
#define REP_StgAP_STACK_fun gcptr
#define StgAP_STACK_fun(__ptr__) REP_StgAP_STACK_fun[__ptr__+SIZEOF_StgHeader+OFFSET_StgAP_STACK_fun]
#define OFFSET_StgAP_STACK_payload 24
#define StgAP_STACK_payload(__ptr__,__ix__) W_[__ptr__+SIZEOF_StgHeader+OFFSET_StgAP_STACK_payload + WDS(__ix__)]
#define SIZEOF_StgSelector_NoThunkHdr 8
#define SIZEOF_StgSelector_NoHdr 16
#define SIZEOF_StgSelector (SIZEOF_StgHeader+16)
#define OFFSET_StgInd_indirectee 0
#define REP_StgInd_indirectee gcptr
#define StgInd_indirectee(__ptr__) REP_StgInd_indirectee[__ptr__+SIZEOF_StgHeader+OFFSET_StgInd_indirectee]
#define SIZEOF_StgMutVar_NoHdr 8
#define SIZEOF_StgMutVar (SIZEOF_StgHeader+8)
#define OFFSET_StgMutVar_var 0
#define REP_StgMutVar_var b64
#define StgMutVar_var(__ptr__) REP_StgMutVar_var[__ptr__+SIZEOF_StgHeader+OFFSET_StgMutVar_var]
#define SIZEOF_StgAtomicallyFrame_NoHdr 24
#define SIZEOF_StgAtomicallyFrame (SIZEOF_StgHeader+24)
#define OFFSET_StgAtomicallyFrame_code 0
#define REP_StgAtomicallyFrame_code b64
#define StgAtomicallyFrame_code(__ptr__) REP_StgAtomicallyFrame_code[__ptr__+SIZEOF_StgHeader+OFFSET_StgAtomicallyFrame_code]
#define OFFSET_StgAtomicallyFrame_next_invariant_to_check 8
#define REP_StgAtomicallyFrame_next_invariant_to_check b64
#define StgAtomicallyFrame_next_invariant_to_check(__ptr__) REP_StgAtomicallyFrame_next_invariant_to_check[__ptr__+SIZEOF_StgHeader+OFFSET_StgAtomicallyFrame_next_invariant_to_check]
#define OFFSET_StgAtomicallyFrame_result 16
#define REP_StgAtomicallyFrame_result b64
#define StgAtomicallyFrame_result(__ptr__) REP_StgAtomicallyFrame_result[__ptr__+SIZEOF_StgHeader+OFFSET_StgAtomicallyFrame_result]
#define OFFSET_StgInvariantCheckQueue_invariant 0
#define REP_StgInvariantCheckQueue_invariant b64
#define StgInvariantCheckQueue_invariant(__ptr__) REP_StgInvariantCheckQueue_invariant[__ptr__+SIZEOF_StgHeader+OFFSET_StgInvariantCheckQueue_invariant]
#define OFFSET_StgInvariantCheckQueue_my_execution 8
#define REP_StgInvariantCheckQueue_my_execution b64
#define StgInvariantCheckQueue_my_execution(__ptr__) REP_StgInvariantCheckQueue_my_execution[__ptr__+SIZEOF_StgHeader+OFFSET_StgInvariantCheckQueue_my_execution]
#define OFFSET_StgInvariantCheckQueue_next_queue_entry 16
#define REP_StgInvariantCheckQueue_next_queue_entry b64
#define StgInvariantCheckQueue_next_queue_entry(__ptr__) REP_StgInvariantCheckQueue_next_queue_entry[__ptr__+SIZEOF_StgHeader+OFFSET_StgInvariantCheckQueue_next_queue_entry]
#define OFFSET_StgAtomicInvariant_code 0
#define REP_StgAtomicInvariant_code b64
#define StgAtomicInvariant_code(__ptr__) REP_StgAtomicInvariant_code[__ptr__+SIZEOF_StgHeader+OFFSET_StgAtomicInvariant_code]
#define OFFSET_StgTRecHeader_enclosing_trec 0
#define REP_StgTRecHeader_enclosing_trec b64
#define StgTRecHeader_enclosing_trec(__ptr__) REP_StgTRecHeader_enclosing_trec[__ptr__+SIZEOF_StgHeader+OFFSET_StgTRecHeader_enclosing_trec]
#define SIZEOF_StgCatchSTMFrame_NoHdr 16
#define SIZEOF_StgCatchSTMFrame (SIZEOF_StgHeader+16)
#define OFFSET_StgCatchSTMFrame_handler 8
#define REP_StgCatchSTMFrame_handler b64
#define StgCatchSTMFrame_handler(__ptr__) REP_StgCatchSTMFrame_handler[__ptr__+SIZEOF_StgHeader+OFFSET_StgCatchSTMFrame_handler]
#define OFFSET_StgCatchSTMFrame_code 0
#define REP_StgCatchSTMFrame_code b64
#define StgCatchSTMFrame_code(__ptr__) REP_StgCatchSTMFrame_code[__ptr__+SIZEOF_StgHeader+OFFSET_StgCatchSTMFrame_code]
#define SIZEOF_StgCatchRetryFrame_NoHdr 24
#define SIZEOF_StgCatchRetryFrame (SIZEOF_StgHeader+24)
#define OFFSET_StgCatchRetryFrame_running_alt_code 0
#define REP_StgCatchRetryFrame_running_alt_code b64
#define StgCatchRetryFrame_running_alt_code(__ptr__) REP_StgCatchRetryFrame_running_alt_code[__ptr__+SIZEOF_StgHeader+OFFSET_StgCatchRetryFrame_running_alt_code]
#define OFFSET_StgCatchRetryFrame_first_code 8
#define REP_StgCatchRetryFrame_first_code b64
#define StgCatchRetryFrame_first_code(__ptr__) REP_StgCatchRetryFrame_first_code[__ptr__+SIZEOF_StgHeader+OFFSET_StgCatchRetryFrame_first_code]
#define OFFSET_StgCatchRetryFrame_alt_code 16
#define REP_StgCatchRetryFrame_alt_code b64
#define StgCatchRetryFrame_alt_code(__ptr__) REP_StgCatchRetryFrame_alt_code[__ptr__+SIZEOF_StgHeader+OFFSET_StgCatchRetryFrame_alt_code]
#define OFFSET_StgTVarWatchQueue_closure 0
#define REP_StgTVarWatchQueue_closure b64
#define StgTVarWatchQueue_closure(__ptr__) REP_StgTVarWatchQueue_closure[__ptr__+SIZEOF_StgHeader+OFFSET_StgTVarWatchQueue_closure]
#define OFFSET_StgTVarWatchQueue_next_queue_entry 8
#define REP_StgTVarWatchQueue_next_queue_entry b64
#define StgTVarWatchQueue_next_queue_entry(__ptr__) REP_StgTVarWatchQueue_next_queue_entry[__ptr__+SIZEOF_StgHeader+OFFSET_StgTVarWatchQueue_next_queue_entry]
#define OFFSET_StgTVarWatchQueue_prev_queue_entry 16
#define REP_StgTVarWatchQueue_prev_queue_entry b64
#define StgTVarWatchQueue_prev_queue_entry(__ptr__) REP_StgTVarWatchQueue_prev_queue_entry[__ptr__+SIZEOF_StgHeader+OFFSET_StgTVarWatchQueue_prev_queue_entry]
#define SIZEOF_StgTVar_NoHdr 24
#define SIZEOF_StgTVar (SIZEOF_StgHeader+24)
#define OFFSET_StgTVar_current_value 0
#define REP_StgTVar_current_value b64
#define StgTVar_current_value(__ptr__) REP_StgTVar_current_value[__ptr__+SIZEOF_StgHeader+OFFSET_StgTVar_current_value]
#define OFFSET_StgTVar_first_watch_queue_entry 8
#define REP_StgTVar_first_watch_queue_entry b64
#define StgTVar_first_watch_queue_entry(__ptr__) REP_StgTVar_first_watch_queue_entry[__ptr__+SIZEOF_StgHeader+OFFSET_StgTVar_first_watch_queue_entry]
#define OFFSET_StgTVar_num_updates 16
#define REP_StgTVar_num_updates b64
#define StgTVar_num_updates(__ptr__) REP_StgTVar_num_updates[__ptr__+SIZEOF_StgHeader+OFFSET_StgTVar_num_updates]
#define SIZEOF_StgWeak_NoHdr 40
#define SIZEOF_StgWeak (SIZEOF_StgHeader+40)
#define OFFSET_StgWeak_link 32
#define REP_StgWeak_link b64
#define StgWeak_link(__ptr__) REP_StgWeak_link[__ptr__+SIZEOF_StgHeader+OFFSET_StgWeak_link]
#define OFFSET_StgWeak_key 8
#define REP_StgWeak_key b64
#define StgWeak_key(__ptr__) REP_StgWeak_key[__ptr__+SIZEOF_StgHeader+OFFSET_StgWeak_key]
#define OFFSET_StgWeak_value 16
#define REP_StgWeak_value b64
#define StgWeak_value(__ptr__) REP_StgWeak_value[__ptr__+SIZEOF_StgHeader+OFFSET_StgWeak_value]
#define OFFSET_StgWeak_finalizer 24
#define REP_StgWeak_finalizer b64
#define StgWeak_finalizer(__ptr__) REP_StgWeak_finalizer[__ptr__+SIZEOF_StgHeader+OFFSET_StgWeak_finalizer]
#define OFFSET_StgWeak_cfinalizers 0
#define REP_StgWeak_cfinalizers b64
#define StgWeak_cfinalizers(__ptr__) REP_StgWeak_cfinalizers[__ptr__+SIZEOF_StgHeader+OFFSET_StgWeak_cfinalizers]
#define SIZEOF_StgCFinalizerList_NoHdr 40
#define SIZEOF_StgCFinalizerList (SIZEOF_StgHeader+40)
#define OFFSET_StgCFinalizerList_link 0
#define REP_StgCFinalizerList_link b64
#define StgCFinalizerList_link(__ptr__) REP_StgCFinalizerList_link[__ptr__+SIZEOF_StgHeader+OFFSET_StgCFinalizerList_link]
#define OFFSET_StgCFinalizerList_fptr 8
#define REP_StgCFinalizerList_fptr b64
#define StgCFinalizerList_fptr(__ptr__) REP_StgCFinalizerList_fptr[__ptr__+SIZEOF_StgHeader+OFFSET_StgCFinalizerList_fptr]
#define OFFSET_StgCFinalizerList_ptr 16
#define REP_StgCFinalizerList_ptr b64
#define StgCFinalizerList_ptr(__ptr__) REP_StgCFinalizerList_ptr[__ptr__+SIZEOF_StgHeader+OFFSET_StgCFinalizerList_ptr]
#define OFFSET_StgCFinalizerList_eptr 24
#define REP_StgCFinalizerList_eptr b64
#define StgCFinalizerList_eptr(__ptr__) REP_StgCFinalizerList_eptr[__ptr__+SIZEOF_StgHeader+OFFSET_StgCFinalizerList_eptr]
#define OFFSET_StgCFinalizerList_flag 32
#define REP_StgCFinalizerList_flag b64
#define StgCFinalizerList_flag(__ptr__) REP_StgCFinalizerList_flag[__ptr__+SIZEOF_StgHeader+OFFSET_StgCFinalizerList_flag]
#define SIZEOF_StgMVar_NoHdr 24
#define SIZEOF_StgMVar (SIZEOF_StgHeader+24)
#define OFFSET_StgMVar_head 0
#define REP_StgMVar_head b64
#define StgMVar_head(__ptr__) REP_StgMVar_head[__ptr__+SIZEOF_StgHeader+OFFSET_StgMVar_head]
#define OFFSET_StgMVar_tail 8
#define REP_StgMVar_tail b64
#define StgMVar_tail(__ptr__) REP_StgMVar_tail[__ptr__+SIZEOF_StgHeader+OFFSET_StgMVar_tail]
#define OFFSET_StgMVar_value 16
#define REP_StgMVar_value b64
#define StgMVar_value(__ptr__) REP_StgMVar_value[__ptr__+SIZEOF_StgHeader+OFFSET_StgMVar_value]
#define SIZEOF_StgMVarTSOQueue_NoHdr 16
#define SIZEOF_StgMVarTSOQueue (SIZEOF_StgHeader+16)
#define OFFSET_StgMVarTSOQueue_link 0
#define REP_StgMVarTSOQueue_link b64
#define StgMVarTSOQueue_link(__ptr__) REP_StgMVarTSOQueue_link[__ptr__+SIZEOF_StgHeader+OFFSET_StgMVarTSOQueue_link]
#define OFFSET_StgMVarTSOQueue_tso 8
#define REP_StgMVarTSOQueue_tso b64
#define StgMVarTSOQueue_tso(__ptr__) REP_StgMVarTSOQueue_tso[__ptr__+SIZEOF_StgHeader+OFFSET_StgMVarTSOQueue_tso]
#define SIZEOF_StgBCO_NoHdr 32
#define SIZEOF_StgBCO (SIZEOF_StgHeader+32)
#define OFFSET_StgBCO_instrs 0
#define REP_StgBCO_instrs b64
#define StgBCO_instrs(__ptr__) REP_StgBCO_instrs[__ptr__+SIZEOF_StgHeader+OFFSET_StgBCO_instrs]
#define OFFSET_StgBCO_literals 8
#define REP_StgBCO_literals b64
#define StgBCO_literals(__ptr__) REP_StgBCO_literals[__ptr__+SIZEOF_StgHeader+OFFSET_StgBCO_literals]
#define OFFSET_StgBCO_ptrs 16
#define REP_StgBCO_ptrs b64
#define StgBCO_ptrs(__ptr__) REP_StgBCO_ptrs[__ptr__+SIZEOF_StgHeader+OFFSET_StgBCO_ptrs]
#define OFFSET_StgBCO_arity 24
#define REP_StgBCO_arity b32
#define StgBCO_arity(__ptr__) REP_StgBCO_arity[__ptr__+SIZEOF_StgHeader+OFFSET_StgBCO_arity]
#define OFFSET_StgBCO_size 28
#define REP_StgBCO_size b32
#define StgBCO_size(__ptr__) REP_StgBCO_size[__ptr__+SIZEOF_StgHeader+OFFSET_StgBCO_size]
#define OFFSET_StgBCO_bitmap 32
#define StgBCO_bitmap(__ptr__,__ix__) W_[__ptr__+SIZEOF_StgHeader+OFFSET_StgBCO_bitmap + WDS(__ix__)]
#define SIZEOF_StgStableName_NoHdr 8
#define SIZEOF_StgStableName (SIZEOF_StgHeader+8)
#define OFFSET_StgStableName_sn 0
#define REP_StgStableName_sn b64
#define StgStableName_sn(__ptr__) REP_StgStableName_sn[__ptr__+SIZEOF_StgHeader+OFFSET_StgStableName_sn]
#define SIZEOF_StgBlockingQueue_NoHdr 32
#define SIZEOF_StgBlockingQueue (SIZEOF_StgHeader+32)
#define OFFSET_StgBlockingQueue_bh 8
#define REP_StgBlockingQueue_bh b64
#define StgBlockingQueue_bh(__ptr__) REP_StgBlockingQueue_bh[__ptr__+SIZEOF_StgHeader+OFFSET_StgBlockingQueue_bh]
#define OFFSET_StgBlockingQueue_owner 16
#define REP_StgBlockingQueue_owner b64
#define StgBlockingQueue_owner(__ptr__) REP_StgBlockingQueue_owner[__ptr__+SIZEOF_StgHeader+OFFSET_StgBlockingQueue_owner]
#define OFFSET_StgBlockingQueue_queue 24
#define REP_StgBlockingQueue_queue b64
#define StgBlockingQueue_queue(__ptr__) REP_StgBlockingQueue_queue[__ptr__+SIZEOF_StgHeader+OFFSET_StgBlockingQueue_queue]
#define OFFSET_StgBlockingQueue_link 0
#define REP_StgBlockingQueue_link b64
#define StgBlockingQueue_link(__ptr__) REP_StgBlockingQueue_link[__ptr__+SIZEOF_StgHeader+OFFSET_StgBlockingQueue_link]
#define SIZEOF_MessageBlackHole_NoHdr 24
#define SIZEOF_MessageBlackHole (SIZEOF_StgHeader+24)
#define OFFSET_MessageBlackHole_link 0
#define REP_MessageBlackHole_link b64
#define MessageBlackHole_link(__ptr__) REP_MessageBlackHole_link[__ptr__+SIZEOF_StgHeader+OFFSET_MessageBlackHole_link]
#define OFFSET_MessageBlackHole_tso 8
#define REP_MessageBlackHole_tso b64
#define MessageBlackHole_tso(__ptr__) REP_MessageBlackHole_tso[__ptr__+SIZEOF_StgHeader+OFFSET_MessageBlackHole_tso]
#define OFFSET_MessageBlackHole_bh 16
#define REP_MessageBlackHole_bh b64
#define MessageBlackHole_bh(__ptr__) REP_MessageBlackHole_bh[__ptr__+SIZEOF_StgHeader+OFFSET_MessageBlackHole_bh]
#define OFFSET_RtsFlags_ProfFlags_showCCSOnException 280
#define REP_RtsFlags_ProfFlags_showCCSOnException b32
#define RtsFlags_ProfFlags_showCCSOnException(__ptr__) REP_RtsFlags_ProfFlags_showCCSOnException[__ptr__+OFFSET_RtsFlags_ProfFlags_showCCSOnException]
#define OFFSET_RtsFlags_DebugFlags_apply 224
#define REP_RtsFlags_DebugFlags_apply b32
#define RtsFlags_DebugFlags_apply(__ptr__) REP_RtsFlags_DebugFlags_apply[__ptr__+OFFSET_RtsFlags_DebugFlags_apply]
#define OFFSET_RtsFlags_DebugFlags_sanity 208
#define REP_RtsFlags_DebugFlags_sanity b32
#define RtsFlags_DebugFlags_sanity(__ptr__) REP_RtsFlags_DebugFlags_sanity[__ptr__+OFFSET_RtsFlags_DebugFlags_sanity]
#define OFFSET_RtsFlags_DebugFlags_weak 192
#define REP_RtsFlags_DebugFlags_weak b32
#define RtsFlags_DebugFlags_weak(__ptr__) REP_RtsFlags_DebugFlags_weak[__ptr__+OFFSET_RtsFlags_DebugFlags_weak]
#define OFFSET_RtsFlags_GcFlags_initialStkSize 16
#define REP_RtsFlags_GcFlags_initialStkSize b32
#define RtsFlags_GcFlags_initialStkSize(__ptr__) REP_RtsFlags_GcFlags_initialStkSize[__ptr__+OFFSET_RtsFlags_GcFlags_initialStkSize]
#define OFFSET_RtsFlags_MiscFlags_tickInterval 160
#define REP_RtsFlags_MiscFlags_tickInterval b64
#define RtsFlags_MiscFlags_tickInterval(__ptr__) REP_RtsFlags_MiscFlags_tickInterval[__ptr__+OFFSET_RtsFlags_MiscFlags_tickInterval]
#define SIZEOF_StgFunInfoExtraFwd 32
#define OFFSET_StgFunInfoExtraFwd_slow_apply 24
#define REP_StgFunInfoExtraFwd_slow_apply b64
#define StgFunInfoExtraFwd_slow_apply(__ptr__) REP_StgFunInfoExtraFwd_slow_apply[__ptr__+OFFSET_StgFunInfoExtraFwd_slow_apply]
#define OFFSET_StgFunInfoExtraFwd_fun_type 0
#define REP_StgFunInfoExtraFwd_fun_type b32
#define StgFunInfoExtraFwd_fun_type(__ptr__) REP_StgFunInfoExtraFwd_fun_type[__ptr__+OFFSET_StgFunInfoExtraFwd_fun_type]
#define OFFSET_StgFunInfoExtraFwd_arity 4
#define REP_StgFunInfoExtraFwd_arity b32
#define StgFunInfoExtraFwd_arity(__ptr__) REP_StgFunInfoExtraFwd_arity[__ptr__+OFFSET_StgFunInfoExtraFwd_arity]
#define OFFSET_StgFunInfoExtraFwd_bitmap 16
#define REP_StgFunInfoExtraFwd_bitmap b64
#define StgFunInfoExtraFwd_bitmap(__ptr__) REP_StgFunInfoExtraFwd_bitmap[__ptr__+OFFSET_StgFunInfoExtraFwd_bitmap]
#define SIZEOF_StgFunInfoExtraRev 32
#define OFFSET_StgFunInfoExtraRev_slow_apply_offset 0
#define REP_StgFunInfoExtraRev_slow_apply_offset b32
#define StgFunInfoExtraRev_slow_apply_offset(__ptr__) REP_StgFunInfoExtraRev_slow_apply_offset[__ptr__+OFFSET_StgFunInfoExtraRev_slow_apply_offset]
#define OFFSET_StgFunInfoExtraRev_fun_type 24
#define REP_StgFunInfoExtraRev_fun_type b32
#define StgFunInfoExtraRev_fun_type(__ptr__) REP_StgFunInfoExtraRev_fun_type[__ptr__+OFFSET_StgFunInfoExtraRev_fun_type]
#define OFFSET_StgFunInfoExtraRev_arity 28
#define REP_StgFunInfoExtraRev_arity b32
#define StgFunInfoExtraRev_arity(__ptr__) REP_StgFunInfoExtraRev_arity[__ptr__+OFFSET_StgFunInfoExtraRev_arity]
#define OFFSET_StgFunInfoExtraRev_bitmap 8
#define REP_StgFunInfoExtraRev_bitmap b64
#define StgFunInfoExtraRev_bitmap(__ptr__) REP_StgFunInfoExtraRev_bitmap[__ptr__+OFFSET_StgFunInfoExtraRev_bitmap]
#define OFFSET_StgFunInfoExtraRev_bitmap_offset 8
#define REP_StgFunInfoExtraRev_bitmap_offset b32
#define StgFunInfoExtraRev_bitmap_offset(__ptr__) REP_StgFunInfoExtraRev_bitmap_offset[__ptr__+OFFSET_StgFunInfoExtraRev_bitmap_offset]
#define OFFSET_StgLargeBitmap_size 0
#define REP_StgLargeBitmap_size b64
#define StgLargeBitmap_size(__ptr__) REP_StgLargeBitmap_size[__ptr__+OFFSET_StgLargeBitmap_size]
#define OFFSET_StgLargeBitmap_bitmap 8
#define SIZEOF_snEntry 24
#define OFFSET_snEntry_sn_obj 16
#define REP_snEntry_sn_obj b64
#define snEntry_sn_obj(__ptr__) REP_snEntry_sn_obj[__ptr__+OFFSET_snEntry_sn_obj]
#define OFFSET_snEntry_addr 0
#define REP_snEntry_addr b64
#define snEntry_addr(__ptr__) REP_snEntry_addr[__ptr__+OFFSET_snEntry_addr]
#define SIZEOF_spEntry 8
#define OFFSET_spEntry_addr 0
#define REP_spEntry_addr b64
#define spEntry_addr(__ptr__) REP_spEntry_addr[__ptr__+OFFSET_spEntry_addr]
{-# START_FILE include/ghc-8.0.2/ffi.h #-}
/* -----------------------------------------------------------------*-C-*-
   libffi 3.2.1 - Copyright (c) 2011, 2014 Anthony Green
                    - Copyright (c) 1996-2003, 2007, 2008 Red Hat, Inc.

   Permission is hereby granted, free of charge, to any person
   obtaining a copy of this software and associated documentation
   files (the ``Software''), to deal in the Software without
   restriction, including without limitation the rights to use, copy,
   modify, merge, publish, distribute, sublicense, and/or sell copies
   of the Software, and to permit persons to whom the Software is
   furnished to do so, subject to the following conditions:

   The above copyright notice and this permission notice shall be
   included in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   DEALINGS IN THE SOFTWARE.

   ----------------------------------------------------------------------- */

/* -------------------------------------------------------------------
   The basic API is described in the README file.

   The raw API is designed to bypass some of the argument packing
   and unpacking on architectures for which it can be avoided.

   The closure API allows interpreted functions to be packaged up
   inside a C function pointer, so that they can be called as C functions,
   with no understanding on the client side that they are interpreted.
   It can also be used in other cases in which it is necessary to package
   up a user specified parameter and a function pointer as a single
   function pointer.

   The closure API must be implemented in order to get its functionality,
   e.g. for use by gij.  Routines are provided to emulate the raw API
   if the underlying platform doesn't allow faster implementation.

   More details on the raw and cloure API can be found in:

   http://gcc.gnu.org/ml/java/1999-q3/msg00138.html

   and

   http://gcc.gnu.org/ml/java/1999-q3/msg00174.html
   -------------------------------------------------------------------- */

#ifndef LIBFFI_H
#define LIBFFI_H

#ifdef __cplusplus
extern "C" {
#endif

/* Specify which architecture libffi is configured for. */
#ifndef X86_DARWIN
#define X86_DARWIN
#endif

/* ---- System configuration information --------------------------------- */

#include <ffitarget.h>

#ifndef LIBFFI_ASM

#if defined(_MSC_VER) && !defined(__clang__)
#define __attribute__(X)
#endif

#include <stddef.h>
#include <limits.h>

/* LONG_LONG_MAX is not always defined (not if STRICT_ANSI, for example).
   But we can find it either under the correct ANSI name, or under GNU
   C's internal name.  */

#define FFI_64_BIT_MAX 9223372036854775807

#ifdef LONG_LONG_MAX
# define FFI_LONG_LONG_MAX LONG_LONG_MAX
#else
# ifdef LLONG_MAX
#  define FFI_LONG_LONG_MAX LLONG_MAX
#  ifdef _AIX52 /* or newer has C99 LLONG_MAX */
#   undef FFI_64_BIT_MAX
#   define FFI_64_BIT_MAX 9223372036854775807LL
#  endif /* _AIX52 or newer */
# else
#  ifdef __GNUC__
#   define FFI_LONG_LONG_MAX __LONG_LONG_MAX__
#  endif
#  ifdef _AIX /* AIX 5.1 and earlier have LONGLONG_MAX */
#   ifndef __PPC64__
#    if defined (__IBMC__) || defined (__IBMCPP__)
#     define FFI_LONG_LONG_MAX LONGLONG_MAX
#    endif
#   endif /* __PPC64__ */
#   undef  FFI_64_BIT_MAX
#   define FFI_64_BIT_MAX 9223372036854775807LL
#  endif
# endif
#endif

/* The closure code assumes that this works on pointers, i.e. a size_t	*/
/* can hold a pointer.							*/

typedef struct _ffi_type
{
  size_t size;
  unsigned short alignment;
  unsigned short type;
  struct _ffi_type **elements;
} ffi_type;

#ifndef LIBFFI_HIDE_BASIC_TYPES
#if SCHAR_MAX == 127
# define ffi_type_uchar                ffi_type_uint8
# define ffi_type_schar                ffi_type_sint8
#else
 #error "char size not supported"
#endif

#if SHRT_MAX == 32767
# define ffi_type_ushort       ffi_type_uint16
# define ffi_type_sshort       ffi_type_sint16
#elif SHRT_MAX == 2147483647
# define ffi_type_ushort       ffi_type_uint32
# define ffi_type_sshort       ffi_type_sint32
#else
 #error "short size not supported"
#endif

#if INT_MAX == 32767
# define ffi_type_uint         ffi_type_uint16
# define ffi_type_sint         ffi_type_sint16
#elif INT_MAX == 2147483647
# define ffi_type_uint         ffi_type_uint32
# define ffi_type_sint         ffi_type_sint32
#elif INT_MAX == 9223372036854775807
# define ffi_type_uint         ffi_type_uint64
# define ffi_type_sint         ffi_type_sint64
#else
 #error "int size not supported"
#endif

#if LONG_MAX == 2147483647
# if FFI_LONG_LONG_MAX != FFI_64_BIT_MAX
 #error "no 64-bit data type supported"
# endif
#elif LONG_MAX != FFI_64_BIT_MAX
 #error "long size not supported"
#endif

#if LONG_MAX == 2147483647
# define ffi_type_ulong        ffi_type_uint32
# define ffi_type_slong        ffi_type_sint32
#elif LONG_MAX == FFI_64_BIT_MAX
# define ffi_type_ulong        ffi_type_uint64
# define ffi_type_slong        ffi_type_sint64
#else
 #error "long size not supported"
#endif

/* Need minimal decorations for DLLs to works on Windows. */
/* GCC has autoimport and autoexport.  Rely on Libtool to */
/* help MSVC export from a DLL, but always declare data   */
/* to be imported for MSVC clients.  This costs an extra  */
/* indirection for MSVC clients using the static version  */
/* of the library, but don't worry about that.  Besides,  */
/* as a workaround, they can define FFI_BUILDING if they  */
/* *know* they are going to link with the static library. */
#if defined _MSC_VER && !defined FFI_BUILDING
#define FFI_EXTERN extern __declspec(dllimport)
#else
#define FFI_EXTERN extern
#endif

/* These are defined in types.c */
FFI_EXTERN ffi_type ffi_type_void;
FFI_EXTERN ffi_type ffi_type_uint8;
FFI_EXTERN ffi_type ffi_type_sint8;
FFI_EXTERN ffi_type ffi_type_uint16;
FFI_EXTERN ffi_type ffi_type_sint16;
FFI_EXTERN ffi_type ffi_type_uint32;
FFI_EXTERN ffi_type ffi_type_sint32;
FFI_EXTERN ffi_type ffi_type_uint64;
FFI_EXTERN ffi_type ffi_type_sint64;
FFI_EXTERN ffi_type ffi_type_float;
FFI_EXTERN ffi_type ffi_type_double;
FFI_EXTERN ffi_type ffi_type_pointer;

#if 1
FFI_EXTERN ffi_type ffi_type_longdouble;
#else
#define ffi_type_longdouble ffi_type_double
#endif

#ifdef FFI_TARGET_HAS_COMPLEX_TYPE
FFI_EXTERN ffi_type ffi_type_complex_float;
FFI_EXTERN ffi_type ffi_type_complex_double;
#if 1
FFI_EXTERN ffi_type ffi_type_complex_longdouble;
#else
#define ffi_type_complex_longdouble ffi_type_complex_double
#endif
#endif
#endif /* LIBFFI_HIDE_BASIC_TYPES */

typedef enum {
  FFI_OK = 0,
  FFI_BAD_TYPEDEF,
  FFI_BAD_ABI
} ffi_status;

typedef unsigned FFI_TYPE;

typedef struct {
  ffi_abi abi;
  unsigned nargs;
  ffi_type **arg_types;
  ffi_type *rtype;
  unsigned bytes;
  unsigned flags;
#ifdef FFI_EXTRA_CIF_FIELDS
  FFI_EXTRA_CIF_FIELDS;
#endif
} ffi_cif;

#if 0
/* Used to adjust size/alignment of ffi types.  */
void ffi_prep_types (ffi_abi abi);
#endif

/* Used internally, but overridden by some architectures */
ffi_status ffi_prep_cif_core(ffi_cif *cif,
			     ffi_abi abi,
			     unsigned int isvariadic,
			     unsigned int nfixedargs,
			     unsigned int ntotalargs,
			     ffi_type *rtype,
			     ffi_type **atypes);

/* ---- Definitions for the raw API -------------------------------------- */

#ifndef FFI_SIZEOF_ARG
# if LONG_MAX == 2147483647
#  define FFI_SIZEOF_ARG        4
# elif LONG_MAX == FFI_64_BIT_MAX
#  define FFI_SIZEOF_ARG        8
# endif
#endif

#ifndef FFI_SIZEOF_JAVA_RAW
#  define FFI_SIZEOF_JAVA_RAW FFI_SIZEOF_ARG
#endif

typedef union {
  ffi_sarg  sint;
  ffi_arg   uint;
  float	    flt;
  char      data[FFI_SIZEOF_ARG];
  void*     ptr;
} ffi_raw;

#if FFI_SIZEOF_JAVA_RAW == 4 && FFI_SIZEOF_ARG == 8
/* This is a special case for mips64/n32 ABI (and perhaps others) where
   sizeof(void *) is 4 and FFI_SIZEOF_ARG is 8.  */
typedef union {
  signed int	sint;
  unsigned int	uint;
  float		flt;
  char		data[FFI_SIZEOF_JAVA_RAW];
  void*		ptr;
} ffi_java_raw;
#else
typedef ffi_raw ffi_java_raw;
#endif


void ffi_raw_call (ffi_cif *cif,
		   void (*fn)(void),
		   void *rvalue,
		   ffi_raw *avalue);

void ffi_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_raw *raw);
void ffi_raw_to_ptrarray (ffi_cif *cif, ffi_raw *raw, void **args);
size_t ffi_raw_size (ffi_cif *cif);

/* This is analogous to the raw API, except it uses Java parameter	*/
/* packing, even on 64-bit machines.  I.e. on 64-bit machines		*/
/* longs and doubles are followed by an empty 64-bit word.		*/

void ffi_java_raw_call (ffi_cif *cif,
			void (*fn)(void),
			void *rvalue,
			ffi_java_raw *avalue);

void ffi_java_ptrarray_to_raw (ffi_cif *cif, void **args, ffi_java_raw *raw);
void ffi_java_raw_to_ptrarray (ffi_cif *cif, ffi_java_raw *raw, void **args);
size_t ffi_java_raw_size (ffi_cif *cif);

/* ---- Definitions for closures ----------------------------------------- */

#if FFI_CLOSURES

#ifdef _MSC_VER
__declspec(align(8))
#endif
typedef struct {
#if 0
  void *trampoline_table;
  void *trampoline_table_entry;
#else
  char tramp[FFI_TRAMPOLINE_SIZE];
#endif
  ffi_cif   *cif;
  void     (*fun)(ffi_cif*,void*,void**,void*);
  void      *user_data;
#ifdef __GNUC__
} ffi_closure __attribute__((aligned (8)));
#else
} ffi_closure;
# ifdef __sgi
#  pragma pack 0
# endif
#endif

void *ffi_closure_alloc (size_t size, void **code);
void ffi_closure_free (void *);

ffi_status
ffi_prep_closure (ffi_closure*,
		  ffi_cif *,
		  void (*fun)(ffi_cif*,void*,void**,void*),
		  void *user_data);

ffi_status
ffi_prep_closure_loc (ffi_closure*,
		      ffi_cif *,
		      void (*fun)(ffi_cif*,void*,void**,void*),
		      void *user_data,
		      void*codeloc);

#ifdef __sgi
# pragma pack 8
#endif
typedef struct {
#if 0
  void *trampoline_table;
  void *trampoline_table_entry;
#else
  char tramp[FFI_TRAMPOLINE_SIZE];
#endif
  ffi_cif   *cif;

#if !FFI_NATIVE_RAW_API

  /* if this is enabled, then a raw closure has the same layout 
     as a regular closure.  We use this to install an intermediate 
     handler to do the transaltion, void** -> ffi_raw*. */

  void     (*translate_args)(ffi_cif*,void*,void**,void*);
  void      *this_closure;

#endif

  void     (*fun)(ffi_cif*,void*,ffi_raw*,void*);
  void      *user_data;

} ffi_raw_closure;

typedef struct {
#if 0
  void *trampoline_table;
  void *trampoline_table_entry;
#else
  char tramp[FFI_TRAMPOLINE_SIZE];
#endif

  ffi_cif   *cif;

#if !FFI_NATIVE_RAW_API

  /* if this is enabled, then a raw closure has the same layout 
     as a regular closure.  We use this to install an intermediate 
     handler to do the transaltion, void** -> ffi_raw*. */

  void     (*translate_args)(ffi_cif*,void*,void**,void*);
  void      *this_closure;

#endif

  void     (*fun)(ffi_cif*,void*,ffi_java_raw*,void*);
  void      *user_data;

} ffi_java_raw_closure;

ffi_status
ffi_prep_raw_closure (ffi_raw_closure*,
		      ffi_cif *cif,
		      void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
		      void *user_data);

ffi_status
ffi_prep_raw_closure_loc (ffi_raw_closure*,
			  ffi_cif *cif,
			  void (*fun)(ffi_cif*,void*,ffi_raw*,void*),
			  void *user_data,
			  void *codeloc);

ffi_status
ffi_prep_java_raw_closure (ffi_java_raw_closure*,
		           ffi_cif *cif,
		           void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),
		           void *user_data);

ffi_status
ffi_prep_java_raw_closure_loc (ffi_java_raw_closure*,
			       ffi_cif *cif,
			       void (*fun)(ffi_cif*,void*,ffi_java_raw*,void*),
			       void *user_data,
			       void *codeloc);

#endif /* FFI_CLOSURES */

/* ---- Public interface definition -------------------------------------- */

ffi_status ffi_prep_cif(ffi_cif *cif,
			ffi_abi abi,
			unsigned int nargs,
			ffi_type *rtype,
			ffi_type **atypes);

ffi_status ffi_prep_cif_var(ffi_cif *cif,
			    ffi_abi abi,
			    unsigned int nfixedargs,
			    unsigned int ntotalargs,
			    ffi_type *rtype,
			    ffi_type **atypes);

void ffi_call(ffi_cif *cif,
	      void (*fn)(void),
	      void *rvalue,
	      void **avalue);

/* Useful for eliminating compiler warnings */
#define FFI_FN(f) ((void (*)(void))f)

/* ---- Definitions shared with assembly code ---------------------------- */

#endif

/* If these change, update src/mips/ffitarget.h. */
#define FFI_TYPE_VOID       0    
#define FFI_TYPE_INT        1
#define FFI_TYPE_FLOAT      2    
#define FFI_TYPE_DOUBLE     3
#if 1
#define FFI_TYPE_LONGDOUBLE 4
#else
#define FFI_TYPE_LONGDOUBLE FFI_TYPE_DOUBLE
#endif
#define FFI_TYPE_UINT8      5   
#define FFI_TYPE_SINT8      6
#define FFI_TYPE_UINT16     7 
#define FFI_TYPE_SINT16     8
#define FFI_TYPE_UINT32     9
#define FFI_TYPE_SINT32     10
#define FFI_TYPE_UINT64     11
#define FFI_TYPE_SINT64     12
#define FFI_TYPE_STRUCT     13
#define FFI_TYPE_POINTER    14
#define FFI_TYPE_COMPLEX    15

/* This should always refer to the last type code (for sanity checks) */
#define FFI_TYPE_LAST       FFI_TYPE_COMPLEX

#ifdef __cplusplus
}
#endif

#endif
{-# START_FILE include/ghc-8.0.2/ffitarget.h #-}
/* -----------------------------------------------------------------*-C-*-
   ffitarget.h - Copyright (c) 2012, 2014  Anthony Green
                 Copyright (c) 1996-2003, 2010  Red Hat, Inc.
                 Copyright (C) 2008  Free Software Foundation, Inc.

   Target configuration macros for x86 and x86-64.

   Permission is hereby granted, free of charge, to any person obtaining
   a copy of this software and associated documentation files (the
   ``Software''), to deal in the Software without restriction, including
   without limitation the rights to use, copy, modify, merge, publish,
   distribute, sublicense, and/or sell copies of the Software, and to
   permit persons to whom the Software is furnished to do so, subject to
   the following conditions:

   The above copyright notice and this permission notice shall be included
   in all copies or substantial portions of the Software.

   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
   DEALINGS IN THE SOFTWARE.

   ----------------------------------------------------------------------- */

#ifndef LIBFFI_TARGET_H
#define LIBFFI_TARGET_H

#ifndef LIBFFI_H
#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
#endif

/* ---- System specific configurations ----------------------------------- */

/* For code common to all platforms on x86 and x86_64. */
#define X86_ANY

#if defined (X86_64) && defined (__i386__)
#undef X86_64
#define X86
#endif

#ifdef X86_WIN64
#define FFI_SIZEOF_ARG 8
#define USE_BUILTIN_FFS 0 /* not yet implemented in mingw-64 */
#endif

#define FFI_TARGET_SPECIFIC_STACK_SPACE_ALLOCATION
#define FFI_TARGET_HAS_COMPLEX_TYPE

/* ---- Generic type definitions ----------------------------------------- */

#ifndef LIBFFI_ASM
#ifdef X86_WIN64
#ifdef _MSC_VER
typedef unsigned __int64       ffi_arg;
typedef __int64                ffi_sarg;
#else
typedef unsigned long long     ffi_arg;
typedef long long              ffi_sarg;
#endif
#else
#if defined __x86_64__ && defined __ILP32__
#define FFI_SIZEOF_ARG 8
#define FFI_SIZEOF_JAVA_RAW  4
typedef unsigned long long     ffi_arg;
typedef long long              ffi_sarg;
#else
typedef unsigned long          ffi_arg;
typedef signed long            ffi_sarg;
#endif
#endif

typedef enum ffi_abi {
  FFI_FIRST_ABI = 0,

  /* ---- Intel x86 Win32 ---------- */
#ifdef X86_WIN32
  FFI_SYSV,
  FFI_STDCALL,
  FFI_THISCALL,
  FFI_FASTCALL,
  FFI_MS_CDECL,
  FFI_PASCAL,
  FFI_REGISTER,
  FFI_LAST_ABI,
#ifdef _MSC_VER
  FFI_DEFAULT_ABI = FFI_MS_CDECL
#else
  FFI_DEFAULT_ABI = FFI_SYSV
#endif

#elif defined(X86_WIN64)
  FFI_WIN64,
  FFI_LAST_ABI,
  FFI_DEFAULT_ABI = FFI_WIN64

#else
  /* ---- Intel x86 and AMD x86-64 - */
  FFI_SYSV,
  FFI_UNIX64,   /* Unix variants all use the same ABI for x86-64  */
  FFI_THISCALL,
  FFI_FASTCALL,
  FFI_STDCALL,
  FFI_PASCAL,
  FFI_REGISTER,
  FFI_LAST_ABI,
#if defined(__i386__) || defined(__i386)
  FFI_DEFAULT_ABI = FFI_SYSV
#else
  FFI_DEFAULT_ABI = FFI_UNIX64
#endif
#endif
} ffi_abi;
#endif

/* ---- Definitions for closures ----------------------------------------- */

#define FFI_CLOSURES 1
#define FFI_TYPE_SMALL_STRUCT_1B (FFI_TYPE_LAST + 1)
#define FFI_TYPE_SMALL_STRUCT_2B (FFI_TYPE_LAST + 2)
#define FFI_TYPE_SMALL_STRUCT_4B (FFI_TYPE_LAST + 3)
#define FFI_TYPE_MS_STRUCT       (FFI_TYPE_LAST + 4)

#if defined (X86_64) || (defined (__x86_64__) && defined (X86_DARWIN))
#define FFI_TRAMPOLINE_SIZE 24
#define FFI_NATIVE_RAW_API 0
#else
#ifdef X86_WIN32
#define FFI_TRAMPOLINE_SIZE 52
#else
#ifdef X86_WIN64
#define FFI_TRAMPOLINE_SIZE 29
#define FFI_NATIVE_RAW_API 0
#define FFI_NO_RAW_API 1
#else
#define FFI_TRAMPOLINE_SIZE 10
#endif
#endif
#ifndef X86_WIN64
#define FFI_NATIVE_RAW_API 1  /* x86 has native raw api support */
#endif
#endif

#endif

{-# START_FILE include/ghc-8.0.2/ghcautoconf.h #-}
#ifndef __GHCAUTOCONF_H__
#define __GHCAUTOCONF_H__
/* mk/config.h.  Generated from config.h.in by configure.  */
/* mk/config.h.in.  Generated from configure.ac by autoheader.  */

/* Define if building universal (internal helper macro) */
/* #undef AC_APPLE_UNIVERSAL_BUILD */

/* The alignment of a `char'. */
#define ALIGNMENT_CHAR 1

/* The alignment of a `double'. */
#define ALIGNMENT_DOUBLE 8

/* The alignment of a `float'. */
#define ALIGNMENT_FLOAT 4

/* The alignment of a `int'. */
#define ALIGNMENT_INT 4

/* The alignment of a `long'. */
#define ALIGNMENT_LONG 8

/* The alignment of a `long long'. */
#define ALIGNMENT_LONG_LONG 8

/* The alignment of a `short'. */
#define ALIGNMENT_SHORT 2

/* The alignment of a `unsigned char'. */
#define ALIGNMENT_UNSIGNED_CHAR 1

/* The alignment of a `unsigned int'. */
#define ALIGNMENT_UNSIGNED_INT 4

/* The alignment of a `unsigned long'. */
#define ALIGNMENT_UNSIGNED_LONG 8

/* The alignment of a `unsigned long long'. */
#define ALIGNMENT_UNSIGNED_LONG_LONG 8

/* The alignment of a `unsigned short'. */
#define ALIGNMENT_UNSIGNED_SHORT 2

/* The alignment of a `void *'. */
#define ALIGNMENT_VOID_P 8

/* Define to 1 if __thread is supported */
#define CC_SUPPORTS_TLS 1

/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
   systems. This function is required for `alloca.c' support on those systems.
   */
/* #undef CRAY_STACKSEG_END */

/* Define to 1 if using `alloca.c'. */
/* #undef C_ALLOCA */

/* Define to 1 if your processor stores words of floats with the most
   significant byte first */
/* #undef FLOAT_WORDS_BIGENDIAN */

/* Has visibility hidden */
#define HAS_VISIBILITY_HIDDEN 1

/* Define to 1 if you have `alloca', as a function or macro. */
#define HAVE_ALLOCA 1

/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
   */
#define HAVE_ALLOCA_H 1

/* Define to 1 if you have the <bfd.h> header file. */
/* #undef HAVE_BFD_H */

/* Define to 1 if you have the `clock_gettime' function. */
/* #undef HAVE_CLOCK_GETTIME */

/* Define to 1 if you have the `ctime_r' function. */
#define HAVE_CTIME_R 1

/* Define to 1 if you have the <ctype.h> header file. */
#define HAVE_CTYPE_H 1

/* Define to 1 if you have the declaration of `ctime_r', and to 0 if you
   don't. */
#define HAVE_DECL_CTIME_R 1

/* Define to 1 if you have the declaration of `MADV_DONTNEED', and to 0 if you
   don't. */
/* #undef HAVE_DECL_MADV_DONTNEED */

/* Define to 1 if you have the declaration of `MADV_FREE', and to 0 if you
   don't. */
/* #undef HAVE_DECL_MADV_FREE */

/* Define to 1 if you have the declaration of `MAP_NORESERVE', and to 0 if you
   don't. */
/* #undef HAVE_DECL_MAP_NORESERVE */

/* Define to 1 if you have the <dirent.h> header file. */
#define HAVE_DIRENT_H 1

/* Define to 1 if you have the <dlfcn.h> header file. */
#define HAVE_DLFCN_H 1

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define to 1 if you have the `eventfd' function. */
/* #undef HAVE_EVENTFD */

/* Define to 1 if you have the <fcntl.h> header file. */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the <ffi.h> header file. */
/* #undef HAVE_FFI_H */

/* Define to 1 if you have the `fork' function. */
#define HAVE_FORK 1

/* Define to 1 if you have the `getclock' function. */
/* #undef HAVE_GETCLOCK */

/* Define to 1 if you have the `GetModuleFileName' function. */
/* #undef HAVE_GETMODULEFILENAME */

/* Define to 1 if you have the `getrusage' function. */
#define HAVE_GETRUSAGE 1

/* Define to 1 if you have the `gettimeofday' function. */
#define HAVE_GETTIMEOFDAY 1

/* Define to 1 if you have the <grp.h> header file. */
#define HAVE_GRP_H 1

/* Define to 1 if you have the <inttypes.h> header file. */
#define HAVE_INTTYPES_H 1

/* Define to 1 if you have the `bfd' library (-lbfd). */
/* #undef HAVE_LIBBFD */

/* Define to 1 if you have the `dl' library (-ldl). */
#define HAVE_LIBDL 1

/* Define to 1 if you have libffi. */
/* #undef HAVE_LIBFFI */

/* Define to 1 if you have the `iberty' library (-liberty). */
/* #undef HAVE_LIBIBERTY */

/* Define to 1 if you need to link with libm */
#define HAVE_LIBM 1

/* Define to 1 if you have the `pthread' library (-lpthread). */
#define HAVE_LIBPTHREAD 1

/* Define to 1 if you have the `rt' library (-lrt). */
/* #undef HAVE_LIBRT */

/* Define to 1 if you have the <limits.h> header file. */
#define HAVE_LIMITS_H 1

/* Define to 1 if you have the <locale.h> header file. */
#define HAVE_LOCALE_H 1

/* Define to 1 if the system has the type `long long'. */
#define HAVE_LONG_LONG 1

/* Define to 1 if you have the <memory.h> header file. */
#define HAVE_MEMORY_H 1

/* Define to 1 if you have the mingwex library. */
/* #undef HAVE_MINGWEX */

/* Define to 1 if you have the <nlist.h> header file. */
#define HAVE_NLIST_H 1

/* Define to 1 if we have printf$LDBLStub (Apple Mac OS >= 10.4, PPC). */
#define HAVE_PRINTF_LDBLSTUB 0

/* Define to 1 if you have the <pthread.h> header file. */
#define HAVE_PTHREAD_H 1

/* Define to 1 if you have the glibc version of pthread_setname_np */
/* #undef HAVE_PTHREAD_SETNAME_NP */

/* Define to 1 if you have the <pwd.h> header file. */
#define HAVE_PWD_H 1

/* Define to 1 if you have the <sched.h> header file. */
#define HAVE_SCHED_H 1

/* Define to 1 if you have the `sched_setaffinity' function. */
/* #undef HAVE_SCHED_SETAFFINITY */

/* Define to 1 if you have the `setitimer' function. */
#define HAVE_SETITIMER 1

/* Define to 1 if you have the `setlocale' function. */
#define HAVE_SETLOCALE 1

/* Define to 1 if you have the `siginterrupt' function. */
#define HAVE_SIGINTERRUPT 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define to 1 if you have the <stdint.h> header file. */
#define HAVE_STDINT_H 1

/* Define to 1 if you have the <stdlib.h> header file. */
#define HAVE_STDLIB_H 1

/* Define to 1 if you have the <strings.h> header file. */
#define HAVE_STRINGS_H 1

/* Define to 1 if you have the <string.h> header file. */
#define HAVE_STRING_H 1

/* Define to 1 if Apple-style dead-stripping is supported. */
#define HAVE_SUBSECTIONS_VIA_SYMBOLS 1

/* Define to 1 if you have the `sysconf' function. */
#define HAVE_SYSCONF 1

/* Define to 1 if you have the <sys/cpuset.h> header file. */
/* #undef HAVE_SYS_CPUSET_H */

/* Define to 1 if you have the <sys/eventfd.h> header file. */
/* #undef HAVE_SYS_EVENTFD_H */

/* Define to 1 if you have the <sys/mman.h> header file. */
#define HAVE_SYS_MMAN_H 1

/* Define to 1 if you have the <sys/param.h> header file. */
#define HAVE_SYS_PARAM_H 1

/* Define to 1 if you have the <sys/resource.h> header file. */
#define HAVE_SYS_RESOURCE_H 1

/* Define to 1 if you have the <sys/select.h> header file. */
#define HAVE_SYS_SELECT_H 1

/* Define to 1 if you have the <sys/stat.h> header file. */
#define HAVE_SYS_STAT_H 1

/* Define to 1 if you have the <sys/timeb.h> header file. */
#define HAVE_SYS_TIMEB_H 1

/* Define to 1 if you have the <sys/timers.h> header file. */
/* #undef HAVE_SYS_TIMERS_H */

/* Define to 1 if you have the <sys/times.h> header file. */
#define HAVE_SYS_TIMES_H 1

/* Define to 1 if you have the <sys/time.h> header file. */
#define HAVE_SYS_TIME_H 1

/* Define to 1 if you have the <sys/types.h> header file. */
#define HAVE_SYS_TYPES_H 1

/* Define to 1 if you have the <sys/utsname.h> header file. */
#define HAVE_SYS_UTSNAME_H 1

/* Define to 1 if you have the <sys/wait.h> header file. */
#define HAVE_SYS_WAIT_H 1

/* Define to 1 if you have the <termios.h> header file. */
#define HAVE_TERMIOS_H 1

/* Define to 1 if you have the `timer_settime' function. */
/* #undef HAVE_TIMER_SETTIME */

/* Define to 1 if you have the `times' function. */
#define HAVE_TIMES 1

/* Define to 1 if you have the <time.h> header file. */
#define HAVE_TIME_H 1

/* Define to 1 if you have the <unistd.h> header file. */
#define HAVE_UNISTD_H 1

/* Define to 1 if you have the <utime.h> header file. */
#define HAVE_UTIME_H 1

/* Define to 1 if you have the `vfork' function. */
#define HAVE_VFORK 1

/* Define to 1 if you have the <vfork.h> header file. */
/* #undef HAVE_VFORK_H */

/* Define to 1 if you have the <windows.h> header file. */
/* #undef HAVE_WINDOWS_H */

/* Define to 1 if you have the `WinExec' function. */
/* #undef HAVE_WINEXEC */

/* Define to 1 if you have the <winsock.h> header file. */
/* #undef HAVE_WINSOCK_H */

/* Define to 1 if `fork' works. */
#define HAVE_WORKING_FORK 1

/* Define to 1 if `vfork' works. */
#define HAVE_WORKING_VFORK 1

/* Define to 1 if C symbols have a leading underscore added by the compiler.
   */
#define LEADING_UNDERSCORE 1

/* Define to the address where bug reports for this package should be sent. */
/* #undef PACKAGE_BUGREPORT */

/* Define to the full name of this package. */
/* #undef PACKAGE_NAME */

/* Define to the full name and version of this package. */
/* #undef PACKAGE_STRING */

/* Define to the one symbol short name of this package. */
/* #undef PACKAGE_TARNAME */

/* Define to the home page for this package. */
/* #undef PACKAGE_URL */

/* Define to the version of this package. */
/* #undef PACKAGE_VERSION */

/* The size of `char', as computed by sizeof. */
#define SIZEOF_CHAR 1

/* The size of `double', as computed by sizeof. */
#define SIZEOF_DOUBLE 8

/* The size of `float', as computed by sizeof. */
#define SIZEOF_FLOAT 4

/* The size of `int', as computed by sizeof. */
#define SIZEOF_INT 4

/* The size of `long', as computed by sizeof. */
#define SIZEOF_LONG 8

/* The size of `long long', as computed by sizeof. */
#define SIZEOF_LONG_LONG 8

/* The size of `short', as computed by sizeof. */
#define SIZEOF_SHORT 2

/* The size of `unsigned char', as computed by sizeof. */
#define SIZEOF_UNSIGNED_CHAR 1

/* The size of `unsigned int', as computed by sizeof. */
#define SIZEOF_UNSIGNED_INT 4

/* The size of `unsigned long', as computed by sizeof. */
#define SIZEOF_UNSIGNED_LONG 8

/* The size of `unsigned long long', as computed by sizeof. */
#define SIZEOF_UNSIGNED_LONG_LONG 8

/* The size of `unsigned short', as computed by sizeof. */
#define SIZEOF_UNSIGNED_SHORT 2

/* The size of `void *', as computed by sizeof. */
#define SIZEOF_VOID_P 8

/* If using the C implementation of alloca, define if you know the
   direction of stack growth for your system; otherwise it will be
   automatically deduced at runtime.
	STACK_DIRECTION > 0 => grows toward higher addresses
	STACK_DIRECTION < 0 => grows toward lower addresses
	STACK_DIRECTION = 0 => direction of growth unknown */
/* #undef STACK_DIRECTION */

/* Define to 1 if you have the ANSI C header files. */
#define STDC_HEADERS 1

/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
#define TIME_WITH_SYS_TIME 1

/* Enable single heap address space support */
#define USE_LARGE_ADDRESS_SPACE 1

/* Enable extensions on AIX 3, Interix.  */
#ifndef _ALL_SOURCE
# define _ALL_SOURCE 1
#endif
/* Enable GNU extensions on systems that have them.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE 1
#endif
/* Enable threading extensions on Solaris.  */
#ifndef _POSIX_PTHREAD_SEMANTICS
# define _POSIX_PTHREAD_SEMANTICS 1
#endif
/* Enable extensions on HP NonStop.  */
#ifndef _TANDEM_SOURCE
# define _TANDEM_SOURCE 1
#endif
/* Enable general extensions on Solaris.  */
#ifndef __EXTENSIONS__
# define __EXTENSIONS__ 1
#endif


/* Define to 1 if we can use timer_create(CLOCK_REALTIME,...) */
/* #undef USE_TIMER_CREATE */

/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
   significant byte first (like Motorola and SPARC, unlike Intel). */
#if defined AC_APPLE_UNIVERSAL_BUILD
# if defined __BIG_ENDIAN__
#  define WORDS_BIGENDIAN 1
# endif
#else
# ifndef WORDS_BIGENDIAN
/* #  undef WORDS_BIGENDIAN */
# endif
#endif

/* Enable large inode numbers on Mac OS X 10.5.  */
#ifndef _DARWIN_USE_64_BIT_INODE
# define _DARWIN_USE_64_BIT_INODE 1
#endif

/* Number of bits in a file offset, on hosts where this is settable. */
/* #undef _FILE_OFFSET_BITS */

/* Define for large files, on AIX-style hosts. */
/* #undef _LARGE_FILES */

/* Define to 1 if on MINIX. */
/* #undef _MINIX */

/* Define to 2 if the system does not provide POSIX.1 features except with
   this defined. */
/* #undef _POSIX_1_SOURCE */

/* Define to 1 if you need to in order for `stat' and other things to work. */
/* #undef _POSIX_SOURCE */

/* ARM pre v6 */
/* #undef arm_HOST_ARCH_PRE_ARMv6 */

/* ARM pre v7 */
/* #undef arm_HOST_ARCH_PRE_ARMv7 */

/* Define to empty if `const' does not conform to ANSI C. */
/* #undef const */

/* Define to `int' if <sys/types.h> does not define. */
/* #undef pid_t */

/* The supported LLVM version number */
#define sUPPORTED_LLVM_VERSION (3,7)

/* Define to `unsigned int' if <sys/types.h> does not define. */
/* #undef size_t */

/* Define as `fork' if `vfork' does not work. */
/* #undef vfork */

#define TABLES_NEXT_TO_CODE 1
#endif /* __GHCAUTOCONF_H__ */
{-# START_FILE include/ghc-8.0.2/ghcconfig.h #-}
#ifndef __GHCCONFIG_H__
#define __GHCCONFIG_H__

#include "ghcautoconf.h"
#include "ghcplatform.h"

#endif
{-# START_FILE include/ghc-8.0.2/ghcplatform.h #-}
#ifndef __GHCPLATFORM_H__
#define __GHCPLATFORM_H__

#define BuildPlatform_TYPE  x86_64_apple_darwin
#define HostPlatform_TYPE   x86_64_apple_darwin

#define x86_64_apple_darwin_BUILD  1
#define x86_64_apple_darwin_HOST  1

#define x86_64_BUILD_ARCH  1
#define x86_64_HOST_ARCH  1
#define BUILD_ARCH  "x86_64"
#define HOST_ARCH  "x86_64"

#define darwin_BUILD_OS  1
#define darwin_HOST_OS  1
#define BUILD_OS  "darwin"
#define HOST_OS  "darwin"

#define apple_BUILD_VENDOR  1
#define apple_HOST_VENDOR  1
#define BUILD_VENDOR  "apple"
#define HOST_VENDOR  "apple"

/* These TARGET macros are for backwards compatibility... DO NOT USE! */
#define TargetPlatform_TYPE x86_64_apple_darwin
#define x86_64_apple_darwin_TARGET  1
#define x86_64_TARGET_ARCH  1
#define TARGET_ARCH  "x86_64"
#define darwin_TARGET_OS  1
#define TARGET_OS  "darwin"
#define apple_TARGET_VENDOR  1

#endif /* __GHCPLATFORM_H__ */
{-# START_FILE include/ghc-8.0.2/ghcversion.h #-}
#ifndef __GHCVERSION_H__
#define __GHCVERSION_H__

#ifndef __GLASGOW_HASKELL__
# define __GLASGOW_HASKELL__ 800
#endif

#define __GLASGOW_HASKELL_PATCHLEVEL1__ 2

#define MIN_VERSION_GLASGOW_HASKELL(ma,mi,pl1,pl2) (\
   ((ma)*100+(mi)) <  __GLASGOW_HASKELL__ || \
   ((ma)*100+(mi)) == __GLASGOW_HASKELL__    \
          && (pl1) <  __GLASGOW_HASKELL_PATCHLEVEL1__ || \
   ((ma)*100+(mi)) == __GLASGOW_HASKELL__    \
          && (pl1) == __GLASGOW_HASKELL_PATCHLEVEL1__ \
          && (pl2) <= __GLASGOW_HASKELL_PATCHLEVEL2__ )

#endif /* __GHCVERSION_H__ */
{-# START_FILE include/ghc-8.0.2/HsFFI.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2000
 *
 * A mapping for Haskell types to C types, including the corresponding bounds.
 * Intended to be used in conjuction with the FFI.
 *
 * WARNING: Keep this file and StgTypes.h in synch!
 *
 * ---------------------------------------------------------------------------*/

#ifndef HSFFI_H
#define HSFFI_H

#ifdef __cplusplus
extern "C" {
#endif

/* get types from GHC's runtime system */
#include "ghcconfig.h"
#include "stg/Types.h"

/* get limits for integral types */
#if defined HAVE_STDINT_H && !defined USE_INTTYPES_H_FOR_RTS_PROBES_D
/* ISO C 99 says:
 * "C++ implementations should define these macros only when
 * __STDC_LIMIT_MACROS is defined before <stdint.h> is included."
 */
#define __STDC_LIMIT_MACROS
#include <stdint.h>
#elif defined(HAVE_INTTYPES_H)
#include <inttypes.h>
#else
/* second best guess (e.g. on Solaris) */
#include <limits.h>
#endif

#ifdef INT8_MIN
#define __INT8_MIN              INT8_MIN
#define __INT16_MIN             INT16_MIN
#define __INT32_MIN             INT32_MIN
#define __INT64_MIN             INT64_MIN
#define __INT8_MAX              INT8_MAX
#define __INT16_MAX             INT16_MAX
#define __INT32_MAX             INT32_MAX
#define __INT64_MAX             INT64_MAX
#define __UINT8_MAX             UINT8_MAX
#define __UINT16_MAX            UINT16_MAX
#define __UINT32_MAX            UINT32_MAX
#define __UINT64_MAX            UINT64_MAX
#else
/* if we had no luck, let's do it for ourselves (assuming 64bit long longs) */
#define __INT8_MIN              (-128)
#define __INT16_MIN             (-32767-1)
#define __INT32_MIN             (-2147483647-1)
#define __INT64_MIN             (-9223372036854775807LL-1)
#define __INT8_MAX              (127)
#define __INT16_MAX             (32767)
#define __INT32_MAX             (2147483647)
#define __INT64_MAX             (9223372036854775807LL)
#define __UINT8_MAX             (255U)
#define __UINT16_MAX            (65535U)
#define __UINT32_MAX            (4294967295U)
#define __UINT64_MAX            (18446744073709551615ULL)
#endif

/* get limits for floating point types */
#include <float.h>

typedef StgChar                 HsChar;
typedef StgInt                  HsInt;
typedef StgInt8                 HsInt8;
typedef StgInt16                HsInt16;
typedef StgInt32                HsInt32;
typedef StgInt64                HsInt64;
typedef StgWord                 HsWord;
typedef StgWord8                HsWord8;
typedef StgWord16               HsWord16;
typedef StgWord32               HsWord32;
typedef StgWord64               HsWord64;
typedef StgFloat                HsFloat;
typedef StgDouble               HsDouble;
typedef StgInt                  HsBool;
typedef void*                   HsPtr;          /* this should better match StgAddr */
typedef void                    (*HsFunPtr)(void); /* this should better match StgAddr */
typedef void*                   HsStablePtr;

/* this should correspond to the type of StgChar in StgTypes.h */
#define HS_CHAR_MIN             0
#define HS_CHAR_MAX             0x10FFFF

/* is it true or not?  */
#define HS_BOOL_FALSE           0
#define HS_BOOL_TRUE            1

#define HS_BOOL_MIN             HS_BOOL_FALSE
#define HS_BOOL_MAX             HS_BOOL_TRUE

/* this mirrors the distinction of cases in StgTypes.h */
#if   SIZEOF_VOID_P == 8
#define HS_INT_MIN              __INT64_MIN
#define HS_INT_MAX              __INT64_MAX
#define HS_WORD_MAX             __UINT64_MAX
#elif SIZEOF_VOID_P == 4
#define HS_INT_MIN              __INT32_MIN
#define HS_INT_MAX              __INT32_MAX
#define HS_WORD_MAX             __UINT32_MAX
#else
#error GHC untested on this architecture: sizeof(void *) != 4 or 8
#endif

#define HS_INT8_MIN             __INT8_MIN
#define HS_INT8_MAX             __INT8_MAX
#define HS_INT16_MIN            __INT16_MIN
#define HS_INT16_MAX            __INT16_MAX
#define HS_INT32_MIN            __INT32_MIN
#define HS_INT32_MAX            __INT32_MAX
#define HS_INT64_MIN            __INT64_MIN
#define HS_INT64_MAX            __INT64_MAX
#define HS_WORD8_MAX            __UINT8_MAX
#define HS_WORD16_MAX           __UINT16_MAX
#define HS_WORD32_MAX           __UINT32_MAX
#define HS_WORD64_MAX           __UINT64_MAX

#define HS_FLOAT_RADIX          FLT_RADIX
#define HS_FLOAT_ROUNDS         FLT_ROUNDS
#define HS_FLOAT_EPSILON        FLT_EPSILON
#define HS_FLOAT_DIG            FLT_DIG
#define HS_FLOAT_MANT_DIG       FLT_MANT_DIG
#define HS_FLOAT_MIN            FLT_MIN
#define HS_FLOAT_MIN_EXP        FLT_MIN_EXP
#define HS_FLOAT_MIN_10_EXP     FLT_MIN_10_EXP
#define HS_FLOAT_MAX            FLT_MAX
#define HS_FLOAT_MAX_EXP        FLT_MAX_EXP
#define HS_FLOAT_MAX_10_EXP     FLT_MAX_10_EXP

#define HS_DOUBLE_RADIX         DBL_RADIX
#define HS_DOUBLE_ROUNDS        DBL_ROUNDS
#define HS_DOUBLE_EPSILON       DBL_EPSILON
#define HS_DOUBLE_DIG           DBL_DIG
#define HS_DOUBLE_MANT_DIG      DBL_MANT_DIG
#define HS_DOUBLE_MIN           DBL_MIN
#define HS_DOUBLE_MIN_EXP       DBL_MIN_EXP
#define HS_DOUBLE_MIN_10_EXP    DBL_MIN_10_EXP
#define HS_DOUBLE_MAX           DBL_MAX
#define HS_DOUBLE_MAX_EXP       DBL_MAX_EXP
#define HS_DOUBLE_MAX_10_EXP    DBL_MAX_10_EXP

extern void hs_init     (int *argc, char **argv[]);
extern void hs_exit     (void);
extern void hs_set_argv (int argc, char *argv[]);
extern void hs_add_root (void (*init_root)(void));
extern void hs_thread_done (void);

extern void hs_perform_gc (void);

extern void hs_lock_stable_tables (void);
extern void hs_unlock_stable_tables (void);
extern void hs_free_stable_ptr_unsafe (HsStablePtr sp);

extern void hs_free_stable_ptr (HsStablePtr sp);
extern void hs_free_fun_ptr    (HsFunPtr fp);

extern StgPtr hs_spt_lookup(StgWord64 key[2]);
extern int hs_spt_keys(StgPtr keys[], int szKeys);
extern int hs_spt_key_count (void);

/* -------------------------------------------------------------------------- */

#ifdef __cplusplus
}
#endif

#endif /* HSFFI_H */
{-# START_FILE include/ghc-8.0.2/MachDeps.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The University of Glasgow 2002
 * 
 * Definitions that characterise machine specific properties of basic
 * types (C & Haskell).
 *
 * NB: Keep in sync with HsFFI.h and StgTypes.h.
 * NB: THIS FILE IS INCLUDED IN HASKELL SOURCE!
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef MACHDEPS_H
#define MACHDEPS_H

/* Sizes of C types come from here... */
#include "ghcautoconf.h"

/* Sizes of Haskell types follow.  These sizes correspond to:
 *   - the number of bytes in the primitive type (eg. Int#)
 *   - the number of bytes in the external representation (eg. HsInt)
 *   - the scale offset used by writeFooOffAddr#
 *
 * In the heap, the type may take up more space: eg. SIZEOF_INT8 == 1,
 * but it takes up SIZEOF_HSWORD (4 or 8) bytes in the heap.
 */

/* First, check some assumptions.. */
#if SIZEOF_CHAR != 1
#error GHC untested on this architecture: sizeof(char) != 1
#endif

#if SIZEOF_SHORT != 2
#error GHC untested on this architecture: sizeof(short) != 2
#endif

#if SIZEOF_UNSIGNED_INT != 4
#error GHC untested on this architecture: sizeof(unsigned int) != 4
#endif

#define SIZEOF_HSCHAR           SIZEOF_WORD32
#define ALIGNMENT_HSCHAR        ALIGNMENT_WORD32

#define SIZEOF_HSINT            SIZEOF_VOID_P
#define ALIGNMENT_HSINT         ALIGNMENT_VOID_P

#define SIZEOF_HSWORD           SIZEOF_VOID_P
#define ALIGNMENT_HSWORD        ALIGNMENT_VOID_P

#define SIZEOF_HSDOUBLE         SIZEOF_DOUBLE
#define ALIGNMENT_HSDOUBLE      ALIGNMENT_DOUBLE

#define SIZEOF_HSFLOAT          SIZEOF_FLOAT
#define ALIGNMENT_HSFLOAT       ALIGNMENT_FLOAT

#define SIZEOF_HSPTR            SIZEOF_VOID_P
#define ALIGNMENT_HSPTR         ALIGNMENT_VOID_P

#define SIZEOF_HSFUNPTR         SIZEOF_VOID_P
#define ALIGNMENT_HSFUNPTR      ALIGNMENT_VOID_P

#define SIZEOF_HSSTABLEPTR      SIZEOF_VOID_P
#define ALIGNMENT_HSSTABLEPTR   ALIGNMENT_VOID_P

#define SIZEOF_INT8             SIZEOF_CHAR
#define ALIGNMENT_INT8          ALIGNMENT_CHAR

#define SIZEOF_WORD8            SIZEOF_UNSIGNED_CHAR
#define ALIGNMENT_WORD8         ALIGNMENT_UNSIGNED_CHAR

#define SIZEOF_INT16            SIZEOF_SHORT
#define ALIGNMENT_INT16         ALIGNMENT_SHORT

#define SIZEOF_WORD16           SIZEOF_UNSIGNED_SHORT
#define ALIGNMENT_WORD16        ALIGNMENT_UNSIGNED_SHORT

#define SIZEOF_INT32            SIZEOF_INT
#define ALIGNMENT_INT32         ALIGNMENT_INT

#define SIZEOF_WORD32           SIZEOF_UNSIGNED_INT
#define ALIGNMENT_WORD32        ALIGNMENT_UNSIGNED_INT

#if SIZEOF_LONG == 8
#define SIZEOF_INT64            SIZEOF_LONG
#define ALIGNMENT_INT64         ALIGNMENT_LONG
#define SIZEOF_WORD64           SIZEOF_UNSIGNED_LONG
#define ALIGNMENT_WORD64        ALIGNMENT_UNSIGNED_LONG
#elif HAVE_LONG_LONG && SIZEOF_LONG_LONG == 8
#define SIZEOF_INT64            SIZEOF_LONG_LONG
#define ALIGNMENT_INT64         ALIGNMENT_LONG_LONG
#define SIZEOF_WORD64           SIZEOF_UNSIGNED_LONG_LONG
#define ALIGNMENT_WORD64        ALIGNMENT_UNSIGNED_LONG_LONG
#else
#error Cannot find a 64bit type.
#endif

#ifndef WORD_SIZE_IN_BITS
#if SIZEOF_HSWORD == 4
#define WORD_SIZE_IN_BITS       32
#define WORD_SIZE_IN_BITS_FLOAT 32.0
#else 
#define WORD_SIZE_IN_BITS       64
#define WORD_SIZE_IN_BITS_FLOAT 64.0
#endif
#endif

#ifndef TAG_BITS
#if SIZEOF_HSWORD == 4
#define TAG_BITS                2
#else 
#define TAG_BITS                3
#endif
#endif

#define TAG_MASK ((1 << TAG_BITS) - 1)

#endif /* MACHDEPS_H */
{-# START_FILE include/ghc-8.0.2/rts/Adjustor.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * Adjustor API
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_ADJUSTOR_H
#define RTS_ADJUSTOR_H

/* Creating and destroying an adjustor thunk */
void* createAdjustor (int cconv, 
                      StgStablePtr hptr,
                      StgFunPtr wptr,
                      char *typeString);

void freeHaskellFunctionPtr (void* ptr);

#endif /* RTS_ADJUSTOR_H */
{-# START_FILE include/ghc-8.0.2/rts/BlockSignals.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * RTS signal handling 
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_BLOCKSIGNALS_H
#define RTS_BLOCKSIGNALS_H

/* Used by runProcess() in the process package
 */

/*
 * Function: blockUserSignals()
 *
 * Temporarily block the delivery of further console events. Needed to
 * avoid race conditions when GCing the queue of outstanding handlers or
 * when emptying the queue by running the handlers.
 * 
 */
void blockUserSignals(void);

/*
 * Function: unblockUserSignals()
 *
 * The inverse of blockUserSignals(); re-enable the deliver of console events.
 */
void unblockUserSignals(void);

#endif /* RTS_BLOCKSIGNALS_H */
{-# START_FILE include/ghc-8.0.2/rts/Bytecodes.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * Bytecode definitions.
 *
 * ---------------------------------------------------------------------------*/

/* --------------------------------------------------------------------------
 * Instructions
 *
 * Notes:
 * o CASEFAIL is generated by the compiler whenever it tests an "irrefutable"
 *   pattern which fails.  If we don't see too many of these, we could
 *   optimise out the redundant test.
 * ------------------------------------------------------------------------*/

/* NOTE:

   THIS FILE IS INCLUDED IN HASKELL SOURCES (ghc/compiler/ghci/ByteCodeGen.lhs).
   DO NOT PUT C-SPECIFIC STUFF IN HERE!

   I hope that's clear :-)
*/

#define bci_STKCHECK  			1
#define bci_PUSH_L    			2
#define bci_PUSH_LL   			3
#define bci_PUSH_LLL  			4
#define bci_PUSH_G    			5
#define bci_PUSH_ALTS  			6
#define bci_PUSH_ALTS_P			7
#define bci_PUSH_ALTS_N			8 
#define bci_PUSH_ALTS_F			9 
#define bci_PUSH_ALTS_D			10
#define bci_PUSH_ALTS_L			11
#define bci_PUSH_ALTS_V			12
#define bci_PUSH_UBX  			13
#define bci_PUSH_APPLY_N		14
#define bci_PUSH_APPLY_F		15
#define bci_PUSH_APPLY_D		16
#define bci_PUSH_APPLY_L		17
#define bci_PUSH_APPLY_V		18
#define bci_PUSH_APPLY_P		19
#define bci_PUSH_APPLY_PP		20
#define bci_PUSH_APPLY_PPP		21
#define bci_PUSH_APPLY_PPPP		22
#define bci_PUSH_APPLY_PPPPP		23
#define bci_PUSH_APPLY_PPPPPP		24
/* #define bci_PUSH_APPLY_PPPPPPP		25 */
#define bci_SLIDE     			26
#define bci_ALLOC_AP   			27
#define bci_ALLOC_AP_NOUPD		28
#define bci_ALLOC_PAP  			29
#define bci_MKAP      			30
#define bci_MKPAP      			31
#define bci_UNPACK    			32
#define bci_PACK      			33
#define bci_TESTLT_I   			34
#define bci_TESTEQ_I  			35
#define bci_TESTLT_F  			36
#define bci_TESTEQ_F  			37
#define bci_TESTLT_D  			38
#define bci_TESTEQ_D  			39
#define bci_TESTLT_P  			40
#define bci_TESTEQ_P  			41
#define bci_CASEFAIL  			42
#define bci_JMP       			43
#define bci_CCALL     			44
#define bci_SWIZZLE   			45
#define bci_ENTER     			46
#define bci_RETURN    			47
#define bci_RETURN_P 			48
#define bci_RETURN_N 			49
#define bci_RETURN_F 			50
#define bci_RETURN_D 			51
#define bci_RETURN_L 			52
#define bci_RETURN_V 			53
#define bci_BRK_FUN			54
#define bci_TESTLT_W   			55
#define bci_TESTEQ_W  			56
/* If you need to go past 255 then you will run into the flags */

/* If you need to go below 0x0100 then you will run into the instructions */
#define bci_FLAG_LARGE_ARGS     0x8000

/* If a BCO definitely requires less than this many words of stack,
   don't include an explicit STKCHECK insn in it.  The interpreter
   will check for this many words of stack before running each BCO,
   rendering an explicit check unnecessary in the majority of
   cases. */
#define INTERP_STACK_CHECK_THRESH  50

/*-------------------------------------------------------------------------*/
{-# START_FILE include/ghc-8.0.2/rts/Config.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * Rts settings.
 *
 * NOTE: assumes #include "ghcconfig.h"
 * 
 * NB: THIS FILE IS INCLUDED IN NON-C CODE AND DATA!  #defines only please.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_CONFIG_H
#define RTS_CONFIG_H

#if defined(TICKY_TICKY) && defined(THREADED_RTS)
#error TICKY_TICKY is incompatible with THREADED_RTS
#endif

/*
 * Whether the runtime system will use libbfd for debugging purposes.
 */
#if defined(DEBUG) && defined(HAVE_BFD_H) && defined(HAVE_LIBBFD) && !defined(_WIN32)
#define USING_LIBBFD 1
#endif

/* DEBUG implies TRACING and TICKY_TICKY
 */
#if defined(DEBUG)
#define TRACING
#define TICKY_TICKY
#endif

/* -----------------------------------------------------------------------------
   Signals - supported on non-PAR versions of the runtime.  See RtsSignals.h.
   -------------------------------------------------------------------------- */

#define RTS_USER_SIGNALS 1

/* Profile spin locks */

#define PROF_SPIN

#endif /* RTS_CONFIG_H */
{-# START_FILE include/ghc-8.0.2/rts/Constants.h #-}
/* ----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * Constants
 *
 * NOTE: this information is used by both the compiler and the RTS.
 * Some of it is tweakable, and some of it must be kept up to date
 * with various other parts of the system.
 *
 * Constants which are derived automatically from other definitions in
 * the system (eg. structure sizes) are generated into the file
 * DerivedConstants.h by a C program (mkDerivedConstantsHdr).
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_CONSTANTS_H
#define RTS_CONSTANTS_H

/* -----------------------------------------------------------------------------
   Minimum closure sizes

   This is the minimum number of words in the payload of a
   heap-allocated closure, so that the closure has enough room to be
   overwritten with a forwarding pointer during garbage collection.
   -------------------------------------------------------------------------- */

#define MIN_PAYLOAD_SIZE 1

/* -----------------------------------------------------------------------------
   Constants to do with specialised closure types.
   -------------------------------------------------------------------------- */

/* We have some pre-compiled selector thunks defined in rts/StgStdThunks.hc.
 * This constant defines the highest selectee index that we can replace with a
 * reference to the pre-compiled code.
 */

#define MAX_SPEC_SELECTEE_SIZE 15

/* Vector-apply thunks.  These thunks just push their free variables
 * on the stack and enter the first one.  They're a bit like PAPs, but
 * don't have a dynamic size.  We've pre-compiled a few to save
 * space.
 */

#define MAX_SPEC_AP_SIZE       7

/* Specialised FUN/THUNK/CONSTR closure types */

#define MAX_SPEC_THUNK_SIZE    2
#define MAX_SPEC_FUN_SIZE      2
#define MAX_SPEC_CONSTR_SIZE   2

/* Range of built-in table of static small int-like and char-like closures.
 *
 *   NB. This corresponds with the number of actual INTLIKE/CHARLIKE
 *   closures defined in rts/StgMiscClosures.cmm.
 */
#define MAX_INTLIKE             16
#define MIN_INTLIKE             (-16)

#define MAX_CHARLIKE            255
#define MIN_CHARLIKE            0

/* Each byte in the card table for an StgMutaArrPtrs covers
 * (1<<MUT_ARR_PTRS_CARD_BITS) elements in the array.  To find a good
 * value for this, I used the benchmarks nofib/gc/hash,
 * nofib/gc/graph, and nofib/gc/gc_bench.
 */
#define MUT_ARR_PTRS_CARD_BITS 7

/* -----------------------------------------------------------------------------
   STG Registers.

   Note that in MachRegs.h we define how many of these registers are
   *real* machine registers, and not just offsets in the Register Table.
   -------------------------------------------------------------------------- */

#define MAX_VANILLA_REG 10
#define MAX_FLOAT_REG   6
#define MAX_DOUBLE_REG  6
#define MAX_LONG_REG    1
#define MAX_XMM_REG     6

/* -----------------------------------------------------------------------------
   Semi-Tagging constants

   Old Comments about this stuff:

   Tags for indirection nodes and ``other'' (probably unevaluated) nodes;
   normal-form values of algebraic data types will have tags 0, 1, ...

   @INFO_IND_TAG@ is different from @INFO_OTHER_TAG@ just so we can count
   how often we bang into indirection nodes; that's all.  (WDP 95/11)

   ToDo: find out if we need any of this.
   -------------------------------------------------------------------------- */

#define INFO_OTHER_TAG          (-1)
#define INFO_IND_TAG            (-2)
#define INFO_FIRST_TAG          0

/* -----------------------------------------------------------------------------
   How much C stack to reserve for local temporaries when in the STG
   world.  Used in StgCRun.c.
   -------------------------------------------------------------------------- */

#define RESERVED_C_STACK_BYTES (2048 * SIZEOF_LONG)

/* -----------------------------------------------------------------------------
   How much Haskell stack space to reserve for the saving of registers
   etc. in the case of a stack/heap overflow.

   This must be large enough to accommodate the largest stack frame
   pushed in one of the heap check fragments in HeapStackCheck.hc
   (ie. currently the generic heap checks - 3 words for StgRetDyn,
   18 words for the saved registers, see StgMacros.h).
   -------------------------------------------------------------------------- */

#define RESERVED_STACK_WORDS 21

/* -----------------------------------------------------------------------------
   The limit on the size of the stack check performed when we enter an
   AP_STACK, in words.  See raiseAsync() and bug #1466.
   -------------------------------------------------------------------------- */

#define AP_STACK_SPLIM 1024

/* -----------------------------------------------------------------------------
   Storage manager constants
   -------------------------------------------------------------------------- */

/* The size of a block (2^BLOCK_SHIFT bytes) */
#define BLOCK_SHIFT  12

/* The size of a megablock (2^MBLOCK_SHIFT bytes) */
#define MBLOCK_SHIFT   20

/* -----------------------------------------------------------------------------
   Bitmap/size fields (used in info tables)
   -------------------------------------------------------------------------- */

/* In a 32-bit bitmap field, we use 5 bits for the size, and 27 bits
 * for the bitmap.  If the bitmap requires more than 27 bits, then we
 * store it in a separate array, and leave a pointer in the bitmap
 * field.  On a 64-bit machine, the sizes are extended accordingly.
 */
#if SIZEOF_VOID_P == 4
#define BITMAP_SIZE_MASK     0x1f
#define BITMAP_BITS_SHIFT    5
#elif SIZEOF_VOID_P == 8
#define BITMAP_SIZE_MASK     0x3f
#define BITMAP_BITS_SHIFT    6
#else
#error unknown SIZEOF_VOID_P
#endif

/* -----------------------------------------------------------------------------
   Lag/Drag/Void constants
   -------------------------------------------------------------------------- */

/*
  An LDV word is divided into 3 parts: state bits (LDV_STATE_MASK), creation
  time bits (LDV_CREATE_MASK), and last use time bits (LDV_LAST_MASK).
 */
#if SIZEOF_VOID_P == 8
#define LDV_SHIFT               30
#define LDV_STATE_MASK          0x1000000000000000
#define LDV_CREATE_MASK         0x0FFFFFFFC0000000
#define LDV_LAST_MASK           0x000000003FFFFFFF
#define LDV_STATE_CREATE        0x0000000000000000
#define LDV_STATE_USE           0x1000000000000000
#else
#define LDV_SHIFT               15
#define LDV_STATE_MASK          0x40000000
#define LDV_CREATE_MASK         0x3FFF8000
#define LDV_LAST_MASK           0x00007FFF
#define LDV_STATE_CREATE        0x00000000
#define LDV_STATE_USE           0x40000000
#endif /* SIZEOF_VOID_P */

/* -----------------------------------------------------------------------------
   TSO related constants
   -------------------------------------------------------------------------- */

/*
 * Constants for the what_next field of a TSO, which indicates how it
 * is to be run.
 */
#define ThreadRunGHC    1       /* return to address on top of stack */
#define ThreadInterpret 2       /* interpret this thread */
#define ThreadKilled    3       /* thread has died, don't run it */
#define ThreadComplete  4       /* thread has finished */

/*
 * Constants for the why_blocked field of a TSO
 * NB. keep these in sync with GHC/Conc.lhs: threadStatus
 */
#define NotBlocked          0
#define BlockedOnMVar       1
#define BlockedOnMVarRead   14 /* TODO: renumber me, see #9003 */
#define BlockedOnBlackHole  2
#define BlockedOnRead       3
#define BlockedOnWrite      4
#define BlockedOnDelay      5
#define BlockedOnSTM        6

/* Win32 only: */
#define BlockedOnDoProc     7

/* Only relevant for PAR: */
  /* blocked on a remote closure represented by a Global Address: */
#define BlockedOnGA         8
  /* same as above but without sending a Fetch message */
#define BlockedOnGA_NoSend  9
/* Only relevant for THREADED_RTS: */
#define BlockedOnCCall      10
#define BlockedOnCCall_Interruptible 11
   /* same as above but permit killing the worker thread */

/* Involved in a message sent to tso->msg_cap */
#define BlockedOnMsgThrowTo 12

/* The thread is not on any run queues, but can be woken up
   by tryWakeupThread() */
#define ThreadMigrating     13

/* WARNING WARNING top number is BlockedOnMVarRead 14, not 13!! */

/*
 * These constants are returned to the scheduler by a thread that has
 * stopped for one reason or another.  See typedef StgThreadReturnCode
 * in TSO.h.
 */
#define HeapOverflow   1                /* might also be StackOverflow */
#define StackOverflow  2
#define ThreadYielding 3
#define ThreadBlocked  4
#define ThreadFinished 5

/*
 * Flags for the tso->flags field.
 */

/*
 * TSO_LOCKED is set when a TSO is locked to a particular Capability.
 */
#define TSO_LOCKED  2

/*
 * TSO_BLOCKEX: the TSO is blocking exceptions
 *
 * TSO_INTERRUPTIBLE: the TSO can be interrupted if it blocks
 * interruptibly (eg. with BlockedOnMVar).
 *
 * TSO_STOPPED_ON_BREAKPOINT: the thread is currently stopped in a breakpoint
 */
#define TSO_BLOCKEX       4
#define TSO_INTERRUPTIBLE 8
#define TSO_STOPPED_ON_BREAKPOINT 16

/*
 * Used by the sanity checker to check whether TSOs are on the correct
 * mutable list.
 */
#define TSO_MARKED 64

/*
 * Used to communicate between stackSqueeze() and
 * threadStackOverflow() that a thread's stack was squeezed and the
 * stack may not need to be expanded.
 */
#define TSO_SQUEEZED 128

/*
 * Enables the AllocationLimitExceeded exception when the thread's
 * allocation limit goes negative.
 */
#define TSO_ALLOC_LIMIT 256

/*
 * The number of times we spin in a spin lock before yielding (see
 * #3758).  To tune this value, use the benchmark in #3758: run the
 * server with -N2 and the client both on a dual-core.  Also make sure
 * that the chosen value doesn't slow down any of the parallel
 * benchmarks in nofib/parallel.
 */
#define SPIN_COUNT 1000

/* -----------------------------------------------------------------------------
   Spare workers per Capability in the threaded RTS

   No more than MAX_SPARE_WORKERS will be kept in the thread pool
   associated with each Capability.
   -------------------------------------------------------------------------- */

#define MAX_SPARE_WORKERS 6

#endif /* RTS_CONSTANTS_H */
{-# START_FILE include/ghc-8.0.2/rts/EventLogFormat.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2008-2009
 *
 * Event log format
 * 
 * The log format is designed to be extensible: old tools should be
 * able to parse (but not necessarily understand all of) new versions
 * of the format, and new tools will be able to understand old log
 * files.
 * 
 * Each event has a specific format.  If you add new events, give them
 * new numbers: we never re-use old event numbers.
 *
 * - The format is endian-independent: all values are represented in 
 *    bigendian order.
 *
 * - The format is extensible:
 *
 *    - The header describes each event type and its length.  Tools
 *      that don't recognise a particular event type can skip those events.
 *
 *    - There is room for extra information in the event type
 *      specification, which can be ignored by older tools.
 *
 *    - Events can have extra information added, but existing fields
 *      cannot be changed.  Tools should ignore extra fields at the
 *      end of the event record.
 *
 *    - Old event type ids are never re-used; just take a new identifier.
 *
 *
 * The format
 * ----------
 *
 * log : EVENT_HEADER_BEGIN
 *       EventType*
 *       EVENT_HEADER_END
 *       EVENT_DATA_BEGIN
 *       Event*
 *       EVENT_DATA_END
 *
 * EventType :
 *       EVENT_ET_BEGIN
 *       Word16         -- unique identifier for this event
 *       Int16          -- >=0  size of the event in bytes (minus the header)
 *                      -- -1   variable size
 *       Word32         -- length of the next field in bytes
 *       Word8*         -- string describing the event
 *       Word32         -- length of the next field in bytes
 *       Word8*         -- extra info (for future extensions)
 *       EVENT_ET_END
 *
 * Event : 
 *       Word16         -- event_type
 *       Word64         -- time (nanosecs)
 *       [Word16]       -- length of the rest (for variable-sized events only)
 *       ... extra event-specific info ...
 *
 *
 * To add a new event
 * ------------------
 *
 *  - In this file:
 *    - give it a new number, add a new #define EVENT_XXX below
 *  - In EventLog.c
 *    - add it to the EventDesc array
 *    - emit the event type in initEventLogging()
 *    - emit the new event in postEvent_()
 *    - generate the event itself by calling postEvent() somewhere
 *  - In the Haskell code to parse the event log file:
 *    - add types and code to read the new event
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_EVENTLOGFORMAT_H
#define RTS_EVENTLOGFORMAT_H

/*
 * Markers for begin/end of the Header.
 */
#define EVENT_HEADER_BEGIN    0x68647262 /* 'h' 'd' 'r' 'b' */
#define EVENT_HEADER_END      0x68647265 /* 'h' 'd' 'r' 'e' */

#define EVENT_DATA_BEGIN      0x64617462 /* 'd' 'a' 't' 'b' */
#define EVENT_DATA_END        0xffff

/*
 * Markers for begin/end of the list of Event Types in the Header.
 * Header, Event Type, Begin = hetb
 * Header, Event Type, End = hete
 */
#define EVENT_HET_BEGIN       0x68657462 /* 'h' 'e' 't' 'b' */
#define EVENT_HET_END         0x68657465 /* 'h' 'e' 't' 'e' */

#define EVENT_ET_BEGIN        0x65746200 /* 'e' 't' 'b' 0 */
#define EVENT_ET_END          0x65746500 /* 'e' 't' 'e' 0 */

/*
 * Types of event
 */
#define EVENT_CREATE_THREAD        0 /* (thread)               */
#define EVENT_RUN_THREAD           1 /* (thread)               */
#define EVENT_STOP_THREAD          2 /* (thread, status, blockinfo) */
#define EVENT_THREAD_RUNNABLE      3 /* (thread)               */
#define EVENT_MIGRATE_THREAD       4 /* (thread, new_cap)      */
/* 5, 6, 7 deprecated */
#define EVENT_THREAD_WAKEUP        8 /* (thread, other_cap)    */
#define EVENT_GC_START             9 /* ()                     */
#define EVENT_GC_END              10 /* ()                     */
#define EVENT_REQUEST_SEQ_GC      11 /* ()                     */
#define EVENT_REQUEST_PAR_GC      12 /* ()                     */
/* 13, 14 deprecated */
#define EVENT_CREATE_SPARK_THREAD 15 /* (spark_thread)         */
#define EVENT_LOG_MSG             16 /* (message ...)          */
/* 17 deprecated */
#define EVENT_BLOCK_MARKER        18 /* (size, end_time, capability) */
#define EVENT_USER_MSG            19 /* (message ...)          */
#define EVENT_GC_IDLE             20 /* () */
#define EVENT_GC_WORK             21 /* () */
#define EVENT_GC_DONE             22 /* () */
/* 23, 24 used by eden */
#define EVENT_CAPSET_CREATE       25 /* (capset, capset_type)  */
#define EVENT_CAPSET_DELETE       26 /* (capset)               */
#define EVENT_CAPSET_ASSIGN_CAP   27 /* (capset, cap)          */
#define EVENT_CAPSET_REMOVE_CAP   28 /* (capset, cap)          */
/* the RTS identifier is in the form of "GHC-version rts_way"  */
#define EVENT_RTS_IDENTIFIER      29 /* (capset, name_version_string) */
/* the vectors in these events are null separated strings             */
#define EVENT_PROGRAM_ARGS        30 /* (capset, commandline_vector)  */
#define EVENT_PROGRAM_ENV         31 /* (capset, environment_vector)  */
#define EVENT_OSPROCESS_PID       32 /* (capset, pid)          */
#define EVENT_OSPROCESS_PPID      33 /* (capset, parent_pid)   */
#define EVENT_SPARK_COUNTERS      34 /* (crt,dud,ovf,cnv,gcd,fiz,rem) */
#define EVENT_SPARK_CREATE        35 /* ()                     */
#define EVENT_SPARK_DUD           36 /* ()                     */
#define EVENT_SPARK_OVERFLOW      37 /* ()                     */
#define EVENT_SPARK_RUN           38 /* ()                     */
#define EVENT_SPARK_STEAL         39 /* (victim_cap)           */
#define EVENT_SPARK_FIZZLE        40 /* ()                     */
#define EVENT_SPARK_GC            41 /* ()                     */
#define EVENT_INTERN_STRING       42 /* (string, id) {not used by ghc} */
#define EVENT_WALL_CLOCK_TIME     43 /* (capset, unix_epoch_seconds, nanoseconds) */
#define EVENT_THREAD_LABEL        44 /* (thread, name_string)  */
#define EVENT_CAP_CREATE          45 /* (cap)                  */
#define EVENT_CAP_DELETE          46 /* (cap)                  */
#define EVENT_CAP_DISABLE         47 /* (cap)                  */
#define EVENT_CAP_ENABLE          48 /* (cap)                  */
#define EVENT_HEAP_ALLOCATED      49 /* (heap_capset, alloc_bytes) */
#define EVENT_HEAP_SIZE           50 /* (heap_capset, size_bytes) */
#define EVENT_HEAP_LIVE           51 /* (heap_capset, live_bytes) */
#define EVENT_HEAP_INFO_GHC       52 /* (heap_capset, n_generations,
                                         max_heap_size, alloc_area_size,
                                         mblock_size, block_size) */
#define EVENT_GC_STATS_GHC        53 /* (heap_capset, generation,
                                         copied_bytes, slop_bytes, frag_bytes,
                                         par_n_threads,
                                         par_max_copied, par_tot_copied) */
#define EVENT_GC_GLOBAL_SYNC      54 /* ()                     */
#define EVENT_TASK_CREATE         55 /* (taskID, cap, tid)       */
#define EVENT_TASK_MIGRATE        56 /* (taskID, cap, new_cap)   */
#define EVENT_TASK_DELETE         57 /* (taskID)                 */
#define EVENT_USER_MARKER         58 /* (marker_name) */
#define EVENT_HACK_BUG_T9003      59 /* Hack: see trac #9003 */

/* Range 59 - 59 is available for new GHC and common events. */

/* Range 60 - 80 is used by eden for parallel tracing
 * see http://www.mathematik.uni-marburg.de/~eden/
 */

/* Range 100 - 139 is reserved for Mercury. */

/* Range 140 - 159 is reserved for Perf events. */

/*
 * The highest event code +1 that ghc itself emits. Note that some event
 * ranges higher than this are reserved but not currently emitted by ghc.
 * This must match the size of the EventDesc[] array in EventLog.c
 */
#define NUM_GHC_EVENT_TAGS        60

#if 0  /* DEPRECATED EVENTS: */
/* we don't actually need to record the thread, it's implicit */
#define EVENT_RUN_SPARK            5 /* (thread)               */
#define EVENT_STEAL_SPARK          6 /* (thread, victim_cap)   */
/* shutdown replaced by EVENT_CAP_DELETE */
#define EVENT_SHUTDOWN             7 /* ()                     */
/* ghc changed how it handles sparks so these are no longer applicable */
#define EVENT_CREATE_SPARK        13 /* (cap, thread) */
#define EVENT_SPARK_TO_THREAD     14 /* (cap, thread, spark_thread) */
#define EVENT_STARTUP             17 /* (num_capabilities)     */
/* these are used by eden but are replaced by new alternatives for ghc */
#define EVENT_VERSION             23 /* (version_string) */
#define EVENT_PROGRAM_INVOCATION  24 /* (commandline_string) */
#endif

/*
 * Status values for EVENT_STOP_THREAD
 *
 * 1-5 are the StgRun return values (from includes/Constants.h):
 *
 * #define HeapOverflow   1
 * #define StackOverflow  2
 * #define ThreadYielding 3
 * #define ThreadBlocked  4
 * #define ThreadFinished 5
 * #define ForeignCall                  6
 * #define BlockedOnMVar                7
 * #define BlockedOnBlackHole           8
 * #define BlockedOnRead                9
 * #define BlockedOnWrite               10
 * #define BlockedOnDelay               11
 * #define BlockedOnSTM                 12
 * #define BlockedOnDoProc              13
 * #define BlockedOnCCall               -- not used (see ForeignCall)
 * #define BlockedOnCCall_NoUnblockExc  -- not used (see ForeignCall)
 * #define BlockedOnMsgThrowTo          16
 */
#define THREAD_SUSPENDED_FOREIGN_CALL 6

/*
 * Capset type values for EVENT_CAPSET_CREATE
 */
#define CAPSET_TYPE_CUSTOM      1  /* reserved for end-user applications */
#define CAPSET_TYPE_OSPROCESS   2  /* caps belong to the same OS process */
#define CAPSET_TYPE_CLOCKDOMAIN 3  /* caps share a local clock/time      */

#ifndef EVENTLOG_CONSTANTS_ONLY

typedef StgWord16 EventTypeNum;
typedef StgWord64 EventTimestamp; /* in nanoseconds */
typedef StgWord32 EventThreadID;
typedef StgWord16 EventCapNo;
typedef StgWord16 EventPayloadSize; /* variable-size events */
typedef StgWord16 EventThreadStatus; /* status for EVENT_STOP_THREAD */
typedef StgWord32 EventCapsetID;
typedef StgWord16 EventCapsetType;   /* types for EVENT_CAPSET_CREATE */
typedef StgWord64 EventTaskId;         /* for EVENT_TASK_* */
typedef StgWord64 EventKernelThreadId; /* for EVENT_TASK_CREATE */

#endif

#endif /* RTS_EVENTLOGFORMAT_H */
{-# START_FILE include/ghc-8.0.2/rts/FileLock.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2007-2009
 *
 * File locking support as required by Haskell
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_FILELOCK_H
#define RTS_FILELOCK_H

#include "Stg.h"

int  lockFile(int fd, StgWord64 dev, StgWord64 ino, int for_writing);
int  unlockFile(int fd);

#endif /* RTS_FILELOCK_H */
{-# START_FILE include/ghc-8.0.2/rts/Flags.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * Datatypes that holds the command-line flag settings.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_FLAGS_H
#define RTS_FLAGS_H

#include <stdio.h>

/* For defaults, see the @initRtsFlagsDefaults@ routine. */

/* Note [Synchronization of flags and base APIs]
 *
 * We provide accessors to RTS flags in base. (GHC.RTS module)
 * The API should be updated whenever RTS flags are modified.
 */

/* See Note [Synchronization of flags and base APIs] */
typedef struct _GC_FLAGS {
    FILE   *statsFile;
    nat	    giveStats;
#define NO_GC_STATS	 0
#define COLLECT_GC_STATS 1
#define ONELINE_GC_STATS 2
#define SUMMARY_GC_STATS 3
#define VERBOSE_GC_STATS 4

    nat     maxStkSize;         /* in *words* */
    nat     initialStkSize;     /* in *words* */
    nat     stkChunkSize;       /* in *words* */
    nat     stkChunkBufferSize; /* in *words* */

    nat	    maxHeapSize;        /* in *blocks* */
    nat     minAllocAreaSize;   /* in *blocks* */
    nat     nurseryChunkSize;   /* in *blocks* */
    nat     minOldGenSize;      /* in *blocks* */
    nat     heapSizeSuggestion; /* in *blocks* */
    rtsBool heapSizeSuggestionAuto;
    double  oldGenFactor;
    double  pcFreeHeap;

    nat     generations;
    nat     steps;
    rtsBool squeezeUpdFrames;

    rtsBool compact;		/* True <=> "compact all the time" */
    double  compactThreshold;

    rtsBool sweep;		/* use "mostly mark-sweep" instead of copying
                                 * for the oldest generation */
    rtsBool ringBell;
    rtsBool frontpanel;

    Time    idleGCDelayTime;    /* units: TIME_RESOLUTION */
    rtsBool doIdleGC;

    StgWord heapBase;           /* address to ask the OS for memory */

    StgWord allocLimitGrace;    /* units: *blocks*
                                 * After an AllocationLimitExceeded
                                 * exception has been raised, how much
                                 * extra space is given to the thread
                                 * to handle the exception before we
                                 * raise it again.
                                 */
} GC_FLAGS;

/* See Note [Synchronization of flags and base APIs] */
typedef struct _DEBUG_FLAGS {
    /* flags to control debugging output & extra checking in various subsystems */
    rtsBool scheduler;      /* 's' */
    rtsBool interpreter;    /* 'i' */
    rtsBool weak;           /* 'w' */
    rtsBool gccafs;         /* 'G' */
    rtsBool gc;             /* 'g' */
    rtsBool block_alloc;    /* 'b' */
    rtsBool sanity;         /* 'S'   warning: might be expensive! */
    rtsBool stable;         /* 't' */
    rtsBool prof;           /* 'p' */
    rtsBool linker;         /* 'l'   the object linker */
    rtsBool apply;          /* 'a' */
    rtsBool stm;            /* 'm' */
    rtsBool squeeze;        /* 'z'  stack squeezing & lazy blackholing */
    rtsBool hpc; 	    /* 'c' coverage */
    rtsBool sparks; 	    /* 'r' */
} DEBUG_FLAGS;

/* See Note [Synchronization of flags and base APIs] */
typedef struct _COST_CENTRE_FLAGS {
    nat	    doCostCentres;
# define COST_CENTRES_NONE      0
# define COST_CENTRES_SUMMARY	1
# define COST_CENTRES_VERBOSE	2 /* incl. serial time profile */
# define COST_CENTRES_ALL	3
# define COST_CENTRES_XML       4

    int	    profilerTicks;   /* derived */
    int	    msecsPerTick;    /* derived */
} COST_CENTRE_FLAGS;

/* See Note [Synchronization of flags and base APIs] */
typedef struct _PROFILING_FLAGS {
    nat	doHeapProfile;
# define NO_HEAP_PROFILING	0	/* N.B. Used as indexes into arrays */
# define HEAP_BY_CCS		1
# define HEAP_BY_MOD		2
# define HEAP_BY_DESCR		4
# define HEAP_BY_TYPE		5
# define HEAP_BY_RETAINER       6
# define HEAP_BY_LDV            7

# define HEAP_BY_CLOSURE_TYPE   8

    Time                heapProfileInterval; /* time between samples */
    nat                 heapProfileIntervalTicks; /* ticks between samples (derived) */
    rtsBool             includeTSOs;


    rtsBool		showCCSOnException;

    nat                 maxRetainerSetSize;

    nat                 ccsLength;

    const char*         modSelector;
    const char*         descrSelector;
    const char*         typeSelector;
    const char*         ccSelector;
    const char*         ccsSelector;
    const char*         retainerSelector;
    const char*         bioSelector;

} PROFILING_FLAGS;

#define TRACE_NONE      0
#define TRACE_EVENTLOG  1
#define TRACE_STDERR    2

/* See Note [Synchronization of flags and base APIs] */
typedef struct _TRACE_FLAGS {
    int tracing;
    rtsBool timestamp;      /* show timestamp in stderr output */
    rtsBool scheduler;      /* trace scheduler events */
    rtsBool gc;             /* trace GC events */
    rtsBool sparks_sampled; /* trace spark events by a sampled method */
    rtsBool sparks_full;    /* trace spark events 100% accurately */
    rtsBool user;           /* trace user events (emitted from Haskell code) */
} TRACE_FLAGS;

/* See Note [Synchronization of flags and base APIs] */
typedef struct _CONCURRENT_FLAGS {
    Time ctxtSwitchTime;         /* units: TIME_RESOLUTION */
    int ctxtSwitchTicks;         /* derived */
} CONCURRENT_FLAGS;

/*
 * The tickInterval is the time interval between "ticks", ie.
 * timer signals (see Timer.{c,h}).  It is the frequency at
 * which we sample CCCS for profiling.
 *
 * It is changed by the +RTS -V<secs> flag.
 */
#define DEFAULT_TICK_INTERVAL USToTime(10000)

/* See Note [Synchronization of flags and base APIs] */
typedef struct _MISC_FLAGS {
    Time    tickInterval;        /* units: TIME_RESOLUTION */
    rtsBool install_signal_handlers;
    rtsBool machineReadable;
    StgWord linkerMemBase;       /* address to ask the OS for memory
                                  * for the linker, NULL ==> off */
} MISC_FLAGS;

#ifdef THREADED_RTS
/* See Note [Synchronization of flags and base APIs] */
typedef struct _PAR_FLAGS {
  nat            nNodes;         /* number of threads to run simultaneously */
  rtsBool        migrate;        /* migrate threads between capabilities */
  nat            maxLocalSparks;
  rtsBool        parGcEnabled;   /* enable parallel GC */
  nat            parGcGen;       /* do parallel GC in this generation
                                  * and higher only */
  rtsBool        parGcLoadBalancingEnabled; 
                                 /* enable load-balancing in the
                                  * parallel GC */
  nat            parGcLoadBalancingGen;
                                 /* do load-balancing in this
                                  * generation and higher only */

  nat            parGcNoSyncWithIdle;
                                 /* if a Capability has been idle for
                                  * this many GCs, do not try to wake
                                  * it up when doing a
                                  * non-load-balancing parallel GC.
                                  * (zero disables) */

  nat            parGcThreads;
                                 /* Use this many threads for parallel
                                  * GC (default: use all nNodes). */

  rtsBool        setAffinity;    /* force thread affinity with CPUs */
} PAR_FLAGS;
#endif /* THREADED_RTS */

/* See Note [Synchronization of flags and base APIs] */
typedef struct _TICKY_FLAGS {
    rtsBool showTickyStats;
    FILE   *tickyFile;
} TICKY_FLAGS;

/* Put them together: */

/* See Note [Synchronization of flags and base APIs] */
typedef struct _RTS_FLAGS {
    /* The first portion of RTS_FLAGS is invariant. */
    GC_FLAGS	      GcFlags;
    CONCURRENT_FLAGS  ConcFlags;
    MISC_FLAGS        MiscFlags;
    DEBUG_FLAGS	      DebugFlags;
    COST_CENTRE_FLAGS CcFlags;
    PROFILING_FLAGS   ProfFlags;
    TRACE_FLAGS       TraceFlags;
    TICKY_FLAGS	      TickyFlags;

#if defined(THREADED_RTS)
    PAR_FLAGS	      ParFlags;
#endif
} RTS_FLAGS;

#ifdef COMPILING_RTS_MAIN
extern DLLIMPORT RTS_FLAGS RtsFlags;
#elif IN_STG_CODE
/* Hack because the C code generator can't generate '&label'. */
extern RTS_FLAGS RtsFlags[];
#else
extern RTS_FLAGS RtsFlags;
#endif

/*
 * The printf formats are here, so we are less likely to make
 * overly-long filenames (with disastrous results).  No more than 128
 * chars, please!  
 */

#define STATS_FILENAME_MAXLEN	128

#define GR_FILENAME_FMT		"%0.124s.gr"
#define GR_FILENAME_FMT_GUM	"%0.120s.%03d.%s"
#define HP_FILENAME_FMT		"%0.124s.hp"
#define LIFE_FILENAME_FMT	"%0.122s.life"
#define PROF_FILENAME_FMT	"%0.122s.prof"
#define PROF_FILENAME_FMT_GUM	"%0.118s.%03d.prof"
#define QP_FILENAME_FMT		"%0.124s.qp"
#define STAT_FILENAME_FMT	"%0.122s.stat"
#define TICKY_FILENAME_FMT	"%0.121s.ticky"
#define TIME_FILENAME_FMT	"%0.122s.time"
#define TIME_FILENAME_FMT_GUM	"%0.118s.%03d.time"

/* an "int" so as to match normal "argc" */
/* Now defined in Stg.h (lib/std/cbits need these too.)
extern int     prog_argc;
extern char  **prog_argv;
*/
extern int      rts_argc;  /* ditto */
extern char   **rts_argv;

#endif	/* RTS_FLAGS_H */
{-# START_FILE include/ghc-8.0.2/rts/GetTime.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1995-2009
 *
 * Interface to the RTS time
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_GETTIME_H
#define RTS_GETTIME_H

StgWord64 getMonotonicNSec (void);

#endif /* RTS_GETTIME_H */
{-# START_FILE include/ghc-8.0.2/rts/Globals.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2006-2009
 *
 * The RTS stores some "global" values on behalf of libraries, so that
 * some libraries can ensure that certain top-level things are shared
 * even when multiple versions of the library are loaded.  e.g. see
 * Data.Typeable and GHC.Conc.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_GLOBALS_H
#define RTS_GLOBALS_H

StgStablePtr getOrSetGHCConcSignalSignalHandlerStore(StgStablePtr value);
StgStablePtr getOrSetGHCConcWindowsPendingDelaysStore(StgStablePtr ptr);
StgStablePtr getOrSetGHCConcWindowsIOManagerThreadStore(StgStablePtr ptr);
StgStablePtr getOrSetGHCConcWindowsProddingStore(StgStablePtr ptr);
StgStablePtr getOrSetSystemEventThreadEventManagerStore(StgStablePtr ptr);
StgStablePtr getOrSetSystemEventThreadIOManagerThreadStore(StgStablePtr ptr);
StgStablePtr getOrSetSystemTimerThreadEventManagerStore(StgStablePtr ptr);
StgStablePtr getOrSetSystemTimerThreadIOManagerThreadStore(StgStablePtr ptr);
StgStablePtr getOrSetLibHSghcFastStringTable(StgStablePtr ptr);

#endif /* RTS_GLOBALS_H */
{-# START_FILE include/ghc-8.0.2/rts/Hpc.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2008-2009
 *
 * Haskell Program Coverage
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_HPC_H
#define RTS_HPC_H

// Simple linked list of modules
typedef struct _HpcModuleInfo {
  char *modName;                // name of module
  StgWord32 tickCount;          // number of ticks
  StgWord32 hashNo;             // Hash number for this module's mix info
  StgWord64 *tixArr;            // tix Array; local for this module
  rtsBool from_file;            // data was read from the .tix file
  struct _HpcModuleInfo *next;
} HpcModuleInfo;

void hs_hpc_module (char *modName,
                    StgWord32 modCount,
                    StgWord32 modHashNo,
                    StgWord64 *tixArr);

HpcModuleInfo * hs_hpc_rootModule (void);

void startupHpc(void);
void exitHpc(void);

#endif /* RTS_HPC_H */
{-# START_FILE include/ghc-8.0.2/rts/IOManager.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * IO Manager functionality in the RTS
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_IOMANAGER_H
#define RTS_IOMANAGER_H

#if defined(mingw32_HOST_OS)

int  rts_InstallConsoleEvent ( int action, StgStablePtr *handler );
void rts_ConsoleHandlerDone  ( int ev );
extern StgInt console_handler;

void *   getIOManagerEvent  (void);
HsWord32 readIOManagerEvent (void);
void     sendIOManagerEvent (HsWord32 event);

#else

void     setIOManagerControlFd   (nat cap_no, int fd);
void     setTimerManagerControlFd(int fd);
void     setIOManagerWakeupFd   (int fd);

#endif

//
// Communicating with the IO manager thread (see GHC.Conc).
// Posix implementation in posix/Signals.c
// Win32 implementation in win32/ThrIOManager.c
//
void ioManagerWakeup (void);
#if defined(THREADED_RTS)
void ioManagerDie (void);
void ioManagerStart (void);
#endif

#endif /* RTS_IOMANAGER_H */
{-# START_FILE include/ghc-8.0.2/rts/Libdw.h #-}
/* ---------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2014-2015
 *
 * Producing DWARF-based stacktraces with libdw.
 *
 * --------------------------------------------------------------------------*/

#include "Rts.h"

#ifndef RTS_LIBDW_H
#define RTS_LIBDW_H

// Chunk capacity
// This is rather arbitrary
#define BACKTRACE_CHUNK_SZ 256

/*
 * Note [Chunked stack representation]
 * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 *
 * Consider the stack,
 *     main                   calls                        (bottom of stack)
 *       func1                which in turn calls
 *         func2              which calls
 *          func3             which calls
 *            func4           which calls
 *              func5         which calls
 *                func6       which calls
 *                  func7     which requests a backtrace   (top of stack)
 *
 * This would produce the Backtrace (using a smaller chunk size of three for
 * illustrative purposes),
 *
 * Backtrace     /----> Chunk         /----> Chunk         /----> Chunk
 * last --------/       next --------/       next --------/       next
 * n_frames=8           n_frames=2           n_frames=3           n_frames=3
 *                      ~~~~~~~~~~           ~~~~~~~~~~           ~~~~~~~~~~
 *                      func1                func4                func7
 *                      main                 func3                func6
 *                                           func2                func5
 *
 */

/* A chunk of code addresses from an execution stack
 *
 * The first address in this list corresponds to the stack frame
 * nearest to the "top" of the stack.
 */
typedef struct BacktraceChunk_ {
    StgWord n_frames;                      // number of frames in this chunk
    struct BacktraceChunk_ *next;          // the chunk following this one
    StgPtr frames[BACKTRACE_CHUNK_SZ];     // the code addresses from the
                                           // frames
} __attribute__((packed)) BacktraceChunk;

/* A chunked list of code addresses from an execution stack
 *
 * This structure is optimized for append operations since we append O(stack
 * depth) times yet typically only traverse the stack trace once. Consequently,
 * the "top" stack frame (that is, the one where we started unwinding) can be
 * found in the last chunk. Yes, this is a bit inconsistent with the ordering
 * within a chunk. See Note [Chunked stack representation] for a depiction.
 */
typedef struct Backtrace_ {
    StgWord n_frames;        // Total number of frames in the backtrace
    BacktraceChunk *last;    // The first chunk of frames (corresponding to the
                             // bottom of the stack)
} Backtrace;

/* Various information describing the location of an address */
typedef struct Location_ {
    const char *object_file;
    const char *function;

    // lineno and colno are only valid if source_file /= NULL
    const char *source_file;
    StgWord32 lineno;
    StgWord32 colno;
} __attribute__((packed)) Location;

struct LibdwSession_;
typedef struct LibdwSession_ LibdwSession;

/* Free a backtrace */
void backtraceFree(Backtrace *bt);

/* Request a backtrace of the current stack state.
 * May return NULL if a backtrace can't be acquired. */
Backtrace *libdwGetBacktrace(LibdwSession *session);

/* Lookup Location information for the given address.
 * Returns 0 if successful, 1 if address could not be found. */
int libdwLookupLocation(LibdwSession *session, Location *loc, StgPtr pc);

#endif /* RTS_LIBDW_H */
{-# START_FILE include/ghc-8.0.2/rts/LibdwPool.h #-}
/* ---------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2015-2016
 *
 * A pool of libdw sessions
 *
 * --------------------------------------------------------------------------*/

#ifndef RTS_LIBDW_POOL_H
#define RTS_LIBDW_POOL_H

/* Claim a session from the pool */
LibdwSession *libdwPoolTake(void);

/* Return a session to the pool */
void libdwPoolRelease(LibdwSession *sess);

/* Free any sessions in the pool forcing a reload of any loaded debug
 * information */
void libdwPoolClear(void);

#endif /* RTS_LIBDW_POOL_H */
{-# START_FILE include/ghc-8.0.2/rts/Linker.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2009
 *
 * RTS Object Linker
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_LINKER_H
#define RTS_LINKER_H

#if defined(mingw32_HOST_OS)
typedef wchar_t pathchar;
#define PATH_FMT "ls"
#else
typedef char    pathchar;
#define PATH_FMT "s"
#endif

/* Initialize the object linker. Equivalent to initLinker_(1). */
void initLinker (void);

/* Initialize the object linker.
 * The retain_cafs argument is:
 *
 *   non-zero => Retain CAFs unconditionally in linked Haskell code.
 *               Note that this prevents any code from being unloaded.
 *               It should not be necessary unless you are GHCi or
 *               hs-plugins, which needs to be able call any function
 *               in the compiled code.
 *
 *   zero     => Do not retain CAFs.  Everything reachable from foreign
 *               exports will be retained, due to the StablePtrs
 *               created by the module initialisation code.  unloadObj
 *               frees these StablePtrs, which will allow the CAFs to
 *               be GC'd and the code to be removed.
 */
void initLinker_ (int retain_cafs);

/* insert a symbol in the hash table */
HsInt insertSymbol(pathchar* obj_name, char* key, void* data);

/* lookup a symbol in the hash table */
void *lookupSymbol( char *lbl );

/* delete an object from the pool */
HsInt unloadObj( pathchar *path );

/* purge an object's symbols from the symbol table, but don't unload it */
HsInt purgeObj( pathchar *path );

/* add an obj (populate the global symbol table, but don't resolve yet) */
HsInt loadObj( pathchar *path );

/* add an arch (populate the global symbol table, but don't resolve yet) */
HsInt loadArchive( pathchar *path );

/* resolve all the currently unlinked objects in memory */
HsInt resolveObjs( void );

/* load a dynamic library */
const char *addDLL( pathchar* dll_name );

/* add a path to the library search path */
HsPtr addLibrarySearchPath(pathchar* dll_path);

/* removes a directory from the search path,
   path must have been added using addLibrarySearchPath */
HsBool removeLibrarySearchPath(HsPtr dll_path_index);

/* give a warning about missing Windows patches that would make
   the linker work better */
void warnMissingKBLibraryPaths( void );

/* -----------------------------------------------------------------------------
* Searches the system directories to determine if there is a system DLL that
* satisfies the given name. This prevent GHCi from linking against a static
* library if a DLL is available.
*/
pathchar* findSystemLibrary(pathchar* dll_name);

/* called by the initialization code for a module, not a user API */
StgStablePtr foreignExportStablePtr (StgPtr p);

#endif /* RTS_LINKER_H */
{-# START_FILE include/ghc-8.0.2/rts/Main.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2009
 *
 * Entry point for standalone Haskell programs.
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTSMAIN_H
#define RTSMAIN_H

/* -----------------------------------------------------------------------------
 * The entry point for Haskell programs that use a Haskell main function
 * -------------------------------------------------------------------------- */

int hs_main (int argc, char *argv[],     // program args
             StgClosure *main_closure,   // closure for Main.main
             RtsConfig rts_config)       // RTS configuration
   GNUC3_ATTRIBUTE(__noreturn__);

#endif /* RTSMAIN_H */
{-# START_FILE include/ghc-8.0.2/rts/Messages.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * Message API for use inside the RTS.  All messages generated by the
 * RTS should go through one of the functions declared here, and we
 * also provide hooks so that messages from the RTS can be redirected
 * as appropriate.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_MESSAGES_H
#define RTS_MESSAGES_H

#include <stdarg.h>

#if defined(mingw32_HOST_OS)
/* On Win64, if we say "printf" then gcc thinks we are going to use
   MS format specifiers like %I64d rather than %llu */
#define PRINTF gnu_printf
#else
/* However, on OS X, "gnu_printf" isn't recognised */
#define PRINTF printf
#endif

/* -----------------------------------------------------------------------------
 * Message generation
 * -------------------------------------------------------------------------- */

/*
 * A fatal internal error: this is for errors that probably indicate
 * bugs in the RTS or compiler.  We normally output bug reporting
 * instructions along with the error message.
 *
 * barf() invokes (*fatalInternalErrorFn)().  This function is not
 * expected to return.
 */
void barf(const char *s, ...)
   GNUC3_ATTRIBUTE(__noreturn__);

void vbarf(const char *s, va_list ap)
   GNUC3_ATTRIBUTE(__noreturn__);

// declared in Rts.h:
// extern void _assertFail(const char *filename, unsigned int linenum)
//    GNUC3_ATTRIBUTE(__noreturn__);

/*
 * An error condition which is caused by and/or can be corrected by
 * the user.
 *
 * errorBelch() invokes (*errorMsgFn)().
 */
void errorBelch(const char *s, ...)
   GNUC3_ATTRIBUTE(format (PRINTF, 1, 2));

void verrorBelch(const char *s, va_list ap);

/*
 * An error condition which is caused by and/or can be corrected by
 * the user, and which has an associated error condition reported
 * by the system (in errno on Unix, and GetLastError() on Windows).
 * The system error message is appended to the message generated
 * from the supplied format string.
 *
 * sysErrorBelch() invokes (*sysErrorMsgFn)().
 */
void sysErrorBelch(const char *s, ...)
   GNUC3_ATTRIBUTE(format (PRINTF, 1, 2));

void vsysErrorBelch(const char *s, va_list ap);

/*
 * A debugging message.  Debugging messages are generated either as a
 * virtue of having DEBUG turned on, or by being explicitly selected
 * via RTS options (eg. +RTS -Ds).
 *
 * debugBelch() invokes (*debugMsgFn)().
 */
void debugBelch(const char *s, ...)
   GNUC3_ATTRIBUTE(format (PRINTF, 1, 2));

void vdebugBelch(const char *s, va_list ap);


/* Hooks for redirecting message generation: */

typedef void RtsMsgFunction(const char *, va_list);

extern RtsMsgFunction *fatalInternalErrorFn;
extern RtsMsgFunction *debugMsgFn;
extern RtsMsgFunction *errorMsgFn;

/* Default stdio implementation of the message hooks: */

extern RtsMsgFunction rtsFatalInternalErrorFn;
extern RtsMsgFunction rtsDebugMsgFn;
extern RtsMsgFunction rtsErrorMsgFn;
extern RtsMsgFunction rtsSysErrorMsgFn;

#endif /* RTS_MESSAGES_H */
{-# START_FILE include/ghc-8.0.2/rts/OSThreads.h #-}
/* ---------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2001-2009
 *
 * Accessing OS threads functionality in a (mostly) OS-independent
 * manner.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * --------------------------------------------------------------------------*/

#ifndef RTS_OSTHREADS_H
#define RTS_OSTHREADS_H

#if defined(THREADED_RTS) /* to near the end */

#if defined(HAVE_PTHREAD_H) && !defined(mingw32_HOST_OS)

#if CMINUSMINUS

#define ACQUIRE_LOCK(mutex) foreign "C" pthread_mutex_lock(mutex)
#define RELEASE_LOCK(mutex) foreign "C" pthread_mutex_unlock(mutex)
#define ASSERT_LOCK_HELD(mutex) /* nothing */

#else

#include <pthread.h>
#include <errno.h>

typedef pthread_cond_t  Condition;
typedef pthread_mutex_t Mutex;
typedef pthread_t       OSThreadId;
typedef pthread_key_t   ThreadLocalKey;

#define OSThreadProcAttr /* nothing */

#define INIT_COND_VAR       PTHREAD_COND_INITIALIZER

#ifdef LOCK_DEBUG
#define LOCK_DEBUG_BELCH(what, mutex) \
  debugBelch("%s(0x%p) %s %d\n", what, mutex, __FILE__, __LINE__)
#else
#define LOCK_DEBUG_BELCH(what, mutex) /* nothing */
#endif

/* Always check the result of lock and unlock. */
#define ACQUIRE_LOCK(mutex) \
  LOCK_DEBUG_BELCH("ACQUIRE_LOCK", mutex); \
  if (pthread_mutex_lock(mutex) == EDEADLK) { \
    barf("multiple ACQUIRE_LOCK: %s %d", __FILE__,__LINE__); \
  }

// Returns zero if the lock was acquired.
EXTERN_INLINE int TRY_ACQUIRE_LOCK(pthread_mutex_t *mutex);
EXTERN_INLINE int TRY_ACQUIRE_LOCK(pthread_mutex_t *mutex)
{
    LOCK_DEBUG_BELCH("TRY_ACQUIRE_LOCK", mutex);
    return pthread_mutex_trylock(mutex);
}

#define RELEASE_LOCK(mutex) \
  LOCK_DEBUG_BELCH("RELEASE_LOCK", mutex); \
  if (pthread_mutex_unlock(mutex) != 0) { \
    barf("RELEASE_LOCK: I do not own this lock: %s %d", __FILE__,__LINE__); \
  }

// Note: this assertion calls pthread_mutex_lock() on a mutex that
// is already held by the calling thread.  The mutex should therefore
// have been created with PTHREAD_MUTEX_ERRORCHECK, otherwise this
// assertion will hang.  We always initialise mutexes with
// PTHREAD_MUTEX_ERRORCHECK when DEBUG is on (see rts/posix/OSThreads.h).
#define ASSERT_LOCK_HELD(mutex) ASSERT(pthread_mutex_lock(mutex) == EDEADLK)

#endif // CMINUSMINUS

# elif defined(HAVE_WINDOWS_H)

#if CMINUSMINUS

/* We jump through a hoop here to get a CCall EnterCriticalSection
   and LeaveCriticalSection, as that's what C-- wants. */

#define ACQUIRE_LOCK(mutex) foreign "stdcall" EnterCriticalSection(mutex)
#define RELEASE_LOCK(mutex) foreign "stdcall" LeaveCriticalSection(mutex)
#define ASSERT_LOCK_HELD(mutex) /* nothing */

#else

#include <windows.h>

typedef HANDLE Condition;
typedef DWORD OSThreadId;
// don't be tempted to use HANDLE as the OSThreadId: there can be
// many HANDLES to a given thread, so comparison would not work.
typedef DWORD ThreadLocalKey;

#define OSThreadProcAttr __stdcall

#define INIT_COND_VAR  0

// We have a choice for implementing Mutexes on Windows.  Standard
// Mutexes are kernel objects that require kernel calls to
// acquire/release, whereas CriticalSections are spin-locks that block
// in the kernel after spinning for a configurable number of times.
// CriticalSections are *much* faster, so we use those.  The Mutex
// implementation is left here for posterity.
#define USE_CRITICAL_SECTIONS 1

#if USE_CRITICAL_SECTIONS

typedef CRITICAL_SECTION Mutex;

#ifdef LOCK_DEBUG

#define ACQUIRE_LOCK(mutex) \
  debugBelch("ACQUIRE_LOCK(0x%p) %s %d\n", mutex,__FILE__,__LINE__); \
  EnterCriticalSection(mutex)
#define RELEASE_LOCK(mutex) \
  debugBelch("RELEASE_LOCK(0x%p) %s %d\n", mutex,__FILE__,__LINE__); \
  LeaveCriticalSection(mutex)
#define ASSERT_LOCK_HELD(mutex) /* nothing */

#else

#define ACQUIRE_LOCK(mutex)      EnterCriticalSection(mutex)
#define TRY_ACQUIRE_LOCK(mutex)  (TryEnterCriticalSection(mutex) == 0)
#define RELEASE_LOCK(mutex)      LeaveCriticalSection(mutex)

// I don't know how to do this.  TryEnterCriticalSection() doesn't do
// the right thing.
#define ASSERT_LOCK_HELD(mutex) /* nothing */

#endif

#else

typedef HANDLE Mutex;

// casting to (Mutex *) here required due to use in .cmm files where
// the argument has (void *) type.
#define ACQUIRE_LOCK(mutex)                                     \
    if (WaitForSingleObject(*((Mutex *)mutex),INFINITE) == WAIT_FAILED) { \
        barf("WaitForSingleObject: %d", GetLastError());        \
    }

#define RELEASE_LOCK(mutex)                             \
    if (ReleaseMutex(*((Mutex *)mutex)) == 0) {         \
        barf("ReleaseMutex: %d", GetLastError());       \
    }

#define ASSERT_LOCK_HELD(mutex) /* nothing */
#endif

#endif // CMINUSMINUS

# else
#  error "Threads not supported"
# endif


#ifndef CMINUSMINUS
//
// General thread operations
//
extern OSThreadId osThreadId      ( void );
extern void shutdownThread        ( void )   GNUC3_ATTRIBUTE(__noreturn__);
extern void yieldThread           ( void );

typedef void OSThreadProcAttr OSThreadProc(void *);

extern int  createOSThread        ( OSThreadId* tid, char *name,
                                    OSThreadProc *startProc, void *param);
extern rtsBool osThreadIsAlive    ( OSThreadId id );
extern void interruptOSThread (OSThreadId id);

//
// Condition Variables
//
extern void initCondition         ( Condition* pCond );
extern void closeCondition        ( Condition* pCond );
extern rtsBool broadcastCondition ( Condition* pCond );
extern rtsBool signalCondition    ( Condition* pCond );
extern rtsBool waitCondition      ( Condition* pCond, Mutex* pMut );

//
// Mutexes
//
extern void initMutex             ( Mutex* pMut );
extern void closeMutex            ( Mutex* pMut );

//
// Thread-local storage
//
void  newThreadLocalKey (ThreadLocalKey *key);
void *getThreadLocalVar (ThreadLocalKey *key);
void  setThreadLocalVar (ThreadLocalKey *key, void *value);
void  freeThreadLocalKey (ThreadLocalKey *key);

// Processors and affinity
void setThreadAffinity     (nat n, nat m);
#endif // !CMINUSMINUS

#else

#define ACQUIRE_LOCK(l)
#define RELEASE_LOCK(l)
#define ASSERT_LOCK_HELD(l)

#endif /* defined(THREADED_RTS) */

#ifndef CMINUSMINUS
//
// Support for forkOS (defined regardless of THREADED_RTS, but does
// nothing when !THREADED_RTS).
//
int forkOS_createThread ( HsStablePtr entry );

//
// Returns the number of processor cores in the machine
//
nat getNumberOfProcessors (void);

//
// Support for getting at the kernel thread Id for tracing/profiling.
//
// This stuff is optional and only used for tracing/profiling purposes, to
// match up thread ids recorded by other tools. For example, on Linux and OSX
// the pthread_t type is not the same as the kernel thread id, and system
// profiling tools like Linux perf, and OSX's DTrace use the kernel thread Id.
// So if we want to match up RTS tasks with kernel threads recorded by these
// tools then we need to know the kernel thread Id, and this must be a separate
// type from the OSThreadId.
//
// If the feature cannot be supported on an OS, it is OK to always return 0.
// In particular it would almost certaily be meaningless on systems not using
// a 1:1 threading model.

// We use a common serialisable representation on all OSs
// This is ok for Windows, OSX and Linux.
typedef StgWord64 KernelThreadId;

// Get the current kernel thread id
KernelThreadId kernelThreadId (void);

#endif /* CMINUSMINUS */

#endif /* RTS_OSTHREADS_H */
{-# START_FILE include/ghc-8.0.2/rts/Parallel.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * Parallelism-related functionality
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_PARALLEL_H
#define RTS_PARALLEL_H

StgInt newSpark (StgRegTable *reg, StgClosure *p);

#endif /* RTS_PARALLEL_H */
{-# START_FILE include/ghc-8.0.2/rts/PrimFloat.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * Primitive floating-point operations
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_PRIMFLOAT_H
#define RTS_PRIMFLOAT_H

StgDouble __int_encodeDouble (I_ j, I_ e);
StgFloat  __int_encodeFloat (I_ j, I_ e);
StgDouble __word_encodeDouble (W_ j, I_ e);
StgFloat  __word_encodeFloat (W_ j, I_ e);

#endif /* RTS_PRIMFLOAT_H */
{-# START_FILE include/ghc-8.0.2/rts/prof/CCS.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2009-2012
 *
 * Macros for profiling operations in STG code
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_PROF_CCS_H
#define RTS_PROF_CCS_H

/* -----------------------------------------------------------------------------
 * Data Structures
 * ---------------------------------------------------------------------------*/
/*
 * Note [struct alignment]
 * NB. be careful to avoid unwanted padding between fields, by
 * putting the 8-byte fields on an 8-byte boundary.  Padding can
 * vary between C compilers, and we don't take into account any
 * possible padding when generating CCS and CC decls in the code
 * generator (compiler/codeGen/StgCmmProf.hs).
 */

typedef struct CostCentre_ {
    StgInt ccID;              // Unique Id, allocated by the RTS

    char * label;
    char * module;
    char * srcloc;

    // used for accumulating costs at the end of the run...
    StgWord64 mem_alloc;      // align 8 (Note [struct alignment])
    StgWord   time_ticks;

    StgInt is_caf;            // non-zero for a CAF cost centre

    struct CostCentre_ *link;
} CostCentre;

typedef struct CostCentreStack_ {
    StgInt ccsID;               // unique ID, allocated by the RTS

    CostCentre *cc;             // Cost centre at the top of the stack

    struct CostCentreStack_ *prevStack;   // parent
    struct IndexTable_      *indexTable;  // children
    struct CostCentreStack_ *root;        // root of stack
    StgWord    depth;           // number of items in the stack

    StgWord64  scc_count;       // Count of times this CCS is entered
                                // align 8 (Note [struct alignment])

    StgWord    selected;        // is this CCS shown in the heap
                                // profile? (zero if excluded via -hc
                                // -hm etc.)

    StgWord    time_ticks;      // number of time ticks accumulated by
                                // this CCS

    StgWord64  mem_alloc;       // mem allocated by this CCS
                                // align 8 (Note [struct alignment])

    StgWord64  inherited_alloc; // sum of mem_alloc over all children
                                // (calculated at the end)
                                // align 8 (Note [struct alignment])

    StgWord    inherited_ticks; // sum of time_ticks over all children
                                // (calculated at the end)
} CostCentreStack;


/* -----------------------------------------------------------------------------
 * Start and stop the profiling timer.  These can be called from
 * Haskell to restrict the profile to portion(s) of the execution.
 * See the module GHC.Profiling.
 * ---------------------------------------------------------------------------*/

void stopProfTimer      ( void );
void startProfTimer     ( void );

/* -----------------------------------------------------------------------------
 * The rest is PROFILING only...
 * ---------------------------------------------------------------------------*/

#if defined(PROFILING)

/* -----------------------------------------------------------------------------
 * Constants
 * ---------------------------------------------------------------------------*/

#define EMPTY_STACK NULL
#define EMPTY_TABLE NULL

/* Constants used to set is_caf flag on CostCentres */
#define CC_IS_CAF      'c'            /* 'c'  => *is* a CAF cc           */
#define CC_NOT_CAF     0

/* -----------------------------------------------------------------------------
 * Data Structures
 * ---------------------------------------------------------------------------*/

// IndexTable is the list of children of a CCS. (Alternatively it is a
// cache of the results of pushing onto a CCS, so that the second and
// subsequent times we push a certain CC on a CCS we get the same
// result).

typedef struct IndexTable_ {
    CostCentre *cc;
    CostCentreStack *ccs;
    struct IndexTable_ *next;
    nat back_edge;
} IndexTable;


/* -----------------------------------------------------------------------------
   Pre-defined cost centres and cost centre stacks
   -------------------------------------------------------------------------- */

#if IN_STG_CODE

extern StgWord CC_MAIN[];
extern StgWord CCS_MAIN[];      // Top CCS

extern StgWord CC_SYSTEM[];
extern StgWord CCS_SYSTEM[];    // RTS costs

extern StgWord CC_GC[];
extern StgWord CCS_GC[];         // Garbage collector costs

extern StgWord CC_OVERHEAD[];
extern StgWord CCS_OVERHEAD[];   // Profiling overhead

extern StgWord CC_DONT_CARE[];
extern StgWord CCS_DONT_CARE[];  // CCS attached to static constructors

#else

extern CostCentre      CC_MAIN[];
extern CostCentreStack CCS_MAIN[];      // Top CCS

extern CostCentre      CC_SYSTEM[];
extern CostCentreStack CCS_SYSTEM[];    // RTS costs

extern CostCentre      CC_GC[];
extern CostCentreStack CCS_GC[];         // Garbage collector costs

extern CostCentre      CC_OVERHEAD[];
extern CostCentreStack CCS_OVERHEAD[];   // Profiling overhead

extern CostCentre      CC_DONT_CARE[];
extern CostCentreStack CCS_DONT_CARE[];  // shouldn't ever get set

extern CostCentre      CC_PINNED[];
extern CostCentreStack CCS_PINNED[];     // pinned memory

extern CostCentre      CC_IDLE[];
extern CostCentreStack CCS_IDLE[];       // capability is idle

#endif /* IN_STG_CODE */

extern unsigned int RTS_VAR(CC_ID);     // global ids
extern unsigned int RTS_VAR(CCS_ID);

extern unsigned int RTS_VAR(era);

/* -----------------------------------------------------------------------------
 * Functions
 * ---------------------------------------------------------------------------*/

CostCentreStack * pushCostCentre (CostCentreStack *, CostCentre *);
void              enterFunCCS    (StgRegTable *reg, CostCentreStack *);
CostCentre *mkCostCentre (char *label, char *module, char *srcloc);

/* -----------------------------------------------------------------------------
   Registering CCs and CCSs

   Registering a CC or CCS consists of
     - assigning it a unique ID
     - linking it onto the list of registered CCs/CCSs

   Cost centres are registered at startup by a C constructor function
   generated by the compiler in the _stub.c file for each module.  The
   macros below are invoked by that C code to register CCs and CCSs.
 -------------------------------------------------------------------------- */

extern CostCentre * RTS_VAR(CC_LIST);               // registered CC list
extern CostCentreStack * RTS_VAR(CCS_LIST);         // registered CCS list

#define REGISTER_CC(cc)                                 \
        do {                                            \
        if ((cc)->link == (CostCentre *)0) {            \
            (cc)->link = CC_LIST;                       \
            CC_LIST = (cc);                             \
            (cc)->ccID = CC_ID++;                       \
        }} while(0)

#define REGISTER_CCS(ccs)                               \
        do {                                            \
        if ((ccs)->prevStack == (CostCentreStack *)0) { \
          (ccs)->prevStack = CCS_LIST;                  \
          CCS_LIST = (ccs);                             \
          (ccs)->ccsID = CCS_ID++;                      \
        }} while(0)

/* -----------------------------------------------------------------------------
 * Declaring Cost Centres & Cost Centre Stacks.
 * -------------------------------------------------------------------------- */

# define CC_DECLARE(cc_ident,name,mod,loc,caf,is_local)  \
     is_local CostCentre cc_ident[1]                     \
       = {{ .ccID       = 0,                             \
            .label      = name,                          \
            .module     = mod,                           \
            .srcloc     = loc,                           \
            .time_ticks = 0,                             \
            .mem_alloc  = 0,                             \
            .link       = 0,                             \
            .is_caf     = caf                            \
         }};

# define CCS_DECLARE(ccs_ident,cc_ident,is_local)        \
     is_local CostCentreStack ccs_ident[1]               \
       = {{ .ccsID               = 0,                    \
            .cc                  = cc_ident,             \
            .prevStack           = NULL,                 \
            .indexTable          = NULL,                 \
            .root                = NULL,                 \
            .depth               = 0,                    \
            .selected            = 0,                    \
            .scc_count           = 0,                    \
            .time_ticks          = 0,                    \
            .mem_alloc           = 0,                    \
            .inherited_ticks     = 0,                    \
            .inherited_alloc     = 0                     \
       }};

/* -----------------------------------------------------------------------------
 * Time / Allocation Macros
 * ---------------------------------------------------------------------------*/

/* eliminate profiling overhead from allocation costs */
#define CCS_ALLOC(ccs, size) (ccs)->mem_alloc += ((size)-sizeofW(StgProfHeader))
#define ENTER_CCS_THUNK(cap,p) cap->r.rCCCS = p->header.prof.ccs

#else /* !PROFILING */

#define CCS_ALLOC(ccs, amount) doNothing()
#define ENTER_CCS_THUNK(cap,p) doNothing()

#endif /* PROFILING */

#endif /* RTS_PROF_CCS_H */
{-# START_FILE include/ghc-8.0.2/rts/prof/LDV.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The University of Glasgow, 2009
 *
 * Lag/Drag/Void profiling.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_PROF_LDV_H
#define RTS_PROF_LDV_H

#ifdef PROFILING

/* retrieves the LDV word from closure c */
#define LDVW(c)                 (((StgClosure *)(c))->header.prof.hp.ldvw)

/*
 * Stores the creation time for closure c.
 * This macro is called at the very moment of closure creation.
 *
 * NOTE: this initializes LDVW(c) to zero, which ensures that there
 * is no conflict between retainer profiling and LDV profiling,
 * because retainer profiling also expects LDVW(c) to be initialised
 * to zero.
 */

#ifdef CMINUSMINUS

#else

#define LDV_RECORD_CREATE(c)   \
  LDVW((c)) = ((StgWord)RTS_DEREF(era) << LDV_SHIFT) | LDV_STATE_CREATE

#endif

#else  /* !PROFILING */

#define LDV_RECORD_CREATE(c)   /* nothing */

#endif /* PROFILING */

#endif /* STGLDVPROF_H */
{-# START_FILE include/ghc-8.0.2/rts/Signals.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * RTS signal handling 
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_SIGNALS_H
#define RTS_SIGNALS_H

/* NB. #included in Haskell code, no prototypes in here. */

/* arguments to stg_sig_install() */
#define STG_SIG_DFL   (-1)
#define STG_SIG_IGN   (-2)
#define STG_SIG_ERR   (-3)
#define STG_SIG_HAN   (-4)
#define STG_SIG_RST   (-5)

#endif /* RTS_SIGNALS_H */
{-# START_FILE include/ghc-8.0.2/rts/SpinLock.h #-}
/* ----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2006-2009
 *
 * Spin locks
 *
 * These are simple spin-only locks as opposed to Mutexes which
 * probably spin for a while before blocking in the kernel.  We use
 * these when we are sure that all our threads are actively running on
 * a CPU, eg. in the GC.
 *
 * TODO: measure whether we really need these, or whether Mutexes
 * would do (and be a bit safer if a CPU becomes loaded).
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_SPINLOCK_H
#define RTS_SPINLOCK_H
 
#if defined(THREADED_RTS)

#if defined(PROF_SPIN)
typedef struct SpinLock_
{
    StgWord   lock;
    StgWord64 spin; // DEBUG version counts how much it spins
} SpinLock;
#else
typedef StgWord SpinLock;
#endif

#if defined(PROF_SPIN)

// PROF_SPIN enables counting the number of times we spin on a lock

// acquire spin lock
INLINE_HEADER void ACQUIRE_SPIN_LOCK(SpinLock * p)
{
    StgWord32 r = 0;
    nat i;
    do {
        for (i = 0; i < SPIN_COUNT; i++) {
            r = cas((StgVolatilePtr)&(p->lock), 1, 0);
            if (r != 0) return;
            p->spin++;
            busy_wait_nop();
        }
        yieldThread();
    } while (1);
}

// release spin lock
INLINE_HEADER void RELEASE_SPIN_LOCK(SpinLock * p)
{
    write_barrier();
    p->lock = 1;
}

// initialise spin lock
INLINE_HEADER void initSpinLock(SpinLock * p)
{
    write_barrier();
    p->lock = 1;
    p->spin = 0;
}

#else

// acquire spin lock
INLINE_HEADER void ACQUIRE_SPIN_LOCK(SpinLock * p)
{
    StgWord32 r = 0;
    nat i;
    do {
        for (i = 0; i < SPIN_COUNT; i++) {
            r = cas((StgVolatilePtr)p, 1, 0);
            if (r != 0) return;
            busy_wait_nop();
        }
        yieldThread();
    } while (1);
}

// release spin lock
INLINE_HEADER void RELEASE_SPIN_LOCK(SpinLock * p)
{
    write_barrier();
    (*p) = 1;
}

// init spin lock
INLINE_HEADER void initSpinLock(SpinLock * p)
{
    write_barrier();
    (*p) = 1;
}

#endif /* PROF_SPIN */

#else /* !THREADED_RTS */

// Using macros here means we don't have to ensure the argument is in scope
#define ACQUIRE_SPIN_LOCK(p) /* nothing */
#define RELEASE_SPIN_LOCK(p) /* nothing */

INLINE_HEADER void initSpinLock(void * p STG_UNUSED)
{ /* nothing */ }

#endif /* THREADED_RTS */

#endif /* RTS_SPINLOCK_H */

{-# START_FILE include/ghc-8.0.2/rts/Stable.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * Stable Pointers
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_STABLE_H
#define RTS_STABLE_H

EXTERN_INLINE StgPtr deRefStablePtr (StgStablePtr stable_ptr);
StgStablePtr getStablePtr  (StgPtr p);

/* -----------------------------------------------------------------------------
   PRIVATE from here.
   -------------------------------------------------------------------------- */

typedef struct {
    StgPtr  addr;                       /* Haskell object, free list, or NULL */
    StgPtr  old;                        /* old Haskell object, used during GC */
    StgClosure *sn_obj;         /* the StableName object (or NULL) */
} snEntry;

typedef struct {
    StgPtr addr;
} spEntry;

extern DLL_IMPORT_RTS snEntry *stable_name_table;
extern DLL_IMPORT_RTS spEntry *stable_ptr_table;

EXTERN_INLINE
StgPtr deRefStablePtr(StgStablePtr sp)
{
    return stable_ptr_table[(StgWord)sp].addr;
}

#endif /* RTS_STABLE_H */
{-# START_FILE include/ghc-8.0.2/rts/StaticPtrTable.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2008-2009
 *
 * Initialization of the Static Pointer Table
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_STATICPTRTABLE_H
#define RTS_STATICPTRTABLE_H

/** Inserts an entry in the Static Pointer Table.
 *
 * The key is a fingerprint computed from the static pointer and the spe_closure
 * is a pointer to the closure defining the table entry.
 *
 * A stable pointer to the closure is made to prevent it from being garbage
 * collected while the entry exists on the table.
 *
 * This function is called from the code generated by
 * compiler/deSugar/StaticPtrTable.sptInitCode
 *
 * */
void hs_spt_insert (StgWord64 key[2],void* spe_closure);

/** Removes an entry from the Static Pointer Table.
 *
 * This function is called from the code generated by
 * compiler/deSugar/StaticPtrTable.sptInitCode
 *
 * */
void hs_spt_remove (StgWord64 key[2]);

#endif /* RTS_STATICPTRTABLE_H */
{-# START_FILE include/ghc-8.0.2/rts/storage/Block.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-1999
 *
 * Block structure for the storage manager
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_STORAGE_BLOCK_H
#define RTS_STORAGE_BLOCK_H

#include "ghcconfig.h"

/* The actual block and megablock-size constants are defined in
 * includes/Constants.h, all constants here are derived from these.
 */

/* Block related constants (BLOCK_SHIFT is defined in Constants.h) */

#if SIZEOF_LONG == SIZEOF_VOID_P
#define UNIT 1UL
#elif SIZEOF_LONG_LONG == SIZEOF_VOID_P
#define UNIT 1ULL
#else
#error "Size of pointer is suspicious."
#endif

#ifdef CMINUSMINUS
#define BLOCK_SIZE   (1<<BLOCK_SHIFT)
#else
#define BLOCK_SIZE   (UNIT<<BLOCK_SHIFT)
// Note [integer overflow]
#endif

#define BLOCK_SIZE_W (BLOCK_SIZE/sizeof(W_))
#define BLOCK_MASK   (BLOCK_SIZE-1)

#define BLOCK_ROUND_UP(p)   (((W_)(p)+BLOCK_SIZE-1) & ~BLOCK_MASK)
#define BLOCK_ROUND_DOWN(p) ((void *) ((W_)(p) & ~BLOCK_MASK))

/* Megablock related constants (MBLOCK_SHIFT is defined in Constants.h) */

#ifdef CMINUSMINUS
#define MBLOCK_SIZE    (1<<MBLOCK_SHIFT)
#else
#define MBLOCK_SIZE    (UNIT<<MBLOCK_SHIFT)
// Note [integer overflow]
#endif

#define MBLOCK_SIZE_W  (MBLOCK_SIZE/sizeof(W_))
#define MBLOCK_MASK    (MBLOCK_SIZE-1)

#define MBLOCK_ROUND_UP(p)   ((void *)(((W_)(p)+MBLOCK_SIZE-1) & ~MBLOCK_MASK))
#define MBLOCK_ROUND_DOWN(p) ((void *)((W_)(p) & ~MBLOCK_MASK ))

/* The largest size an object can be before we give it a block of its
 * own and treat it as an immovable object during GC, expressed as a
 * fraction of BLOCK_SIZE.
 */
#define LARGE_OBJECT_THRESHOLD ((nat)(BLOCK_SIZE * 8 / 10))

/*
 * Note [integer overflow]
 *
 * The UL suffix in BLOCK_SIZE and MBLOCK_SIZE promotes the expression
 * to an unsigned long, which means that expressions involving these
 * will be promoted to unsigned long, which makes integer overflow
 * less likely.  Historically, integer overflow in expressions like
 *    (n * BLOCK_SIZE)
 * where n is int or unsigned int, have caused obscure segfaults in
 * programs that use large amounts of memory (e.g. #7762, #5086).
 */

/* -----------------------------------------------------------------------------
 * Block descriptor.  This structure *must* be the right length, so we
 * can do pointer arithmetic on pointers to it.
 */

/* The block descriptor is 64 bytes on a 64-bit machine, and 32-bytes
 * on a 32-bit machine.
 */

// Note: fields marked with [READ ONLY] must not be modified by the
// client of the block allocator API.  All other fields can be
// freely modified.

#ifndef CMINUSMINUS
typedef struct bdescr_ {

    StgPtr start;              // [READ ONLY] start addr of memory

    StgPtr free;               // first free byte of memory.
                               // NB. during use this value should lie
                               // between start and start + blocks *
                               // BLOCK_SIZE.  Values outside this
                               // range are reserved for use by the
                               // block allocator.  In particular, the
                               // value (StgPtr)(-1) is used to
                               // indicate that a block is unallocated.

    struct bdescr_ *link;      // used for chaining blocks together

    union {
        struct bdescr_ *back;  // used (occasionally) for doubly-linked lists
        StgWord *bitmap;       // bitmap for marking GC
        StgPtr  scan;          // scan pointer for copying GC
    } u;

    struct generation_ *gen;   // generation

    StgWord16 gen_no;          // gen->no, cached
    StgWord16 dest_no;         // number of destination generation
    StgWord16 _pad1;

    StgWord16 flags;           // block flags, see below

    StgWord32 blocks;          // [READ ONLY] no. of blocks in a group
                               // (if group head, 0 otherwise)

#if SIZEOF_VOID_P == 8
    StgWord32 _padding[3];
#else
    StgWord32 _padding[0];
#endif
} bdescr;
#endif

#if SIZEOF_VOID_P == 8
#define BDESCR_SIZE  0x40
#define BDESCR_MASK  0x3f
#define BDESCR_SHIFT 6
#else
#define BDESCR_SIZE  0x20
#define BDESCR_MASK  0x1f
#define BDESCR_SHIFT 5
#endif

/* Block contains objects evacuated during this GC */
#define BF_EVACUATED 1
/* Block is a large object */
#define BF_LARGE     2
/* Block is pinned */
#define BF_PINNED    4
/* Block is to be marked, not copied */
#define BF_MARKED    8
/* Block is free, and on the free list  (TODO: is this used?) */
#define BF_FREE      16
/* Block is executable */
#define BF_EXEC      32
/* Block contains only a small amount of live data */
#define BF_FRAGMENTED 64
/* we know about this block (for finding leaks) */
#define BF_KNOWN     128
/* Block was swept in the last generation */
#define BF_SWEPT     256

/* Finding the block descriptor for a given block -------------------------- */

#ifdef CMINUSMINUS

#define Bdescr(p) \
    ((((p) &  MBLOCK_MASK & ~BLOCK_MASK) >> (BLOCK_SHIFT-BDESCR_SHIFT)) \
     | ((p) & ~MBLOCK_MASK))

#else

EXTERN_INLINE bdescr *Bdescr(StgPtr p);
EXTERN_INLINE bdescr *Bdescr(StgPtr p)
{
  return (bdescr *)
    ((((W_)p &  MBLOCK_MASK & ~BLOCK_MASK) >> (BLOCK_SHIFT-BDESCR_SHIFT))
     | ((W_)p & ~MBLOCK_MASK)
     );
}

#endif

/* Useful Macros ------------------------------------------------------------ */

/* Offset of first real data block in a megablock */

#define FIRST_BLOCK_OFF \
   ((W_)BLOCK_ROUND_UP(BDESCR_SIZE * (MBLOCK_SIZE / BLOCK_SIZE)))

/* First data block in a given megablock */

#define FIRST_BLOCK(m) ((void *)(FIRST_BLOCK_OFF + (W_)(m)))

/* Last data block in a given megablock */

#define LAST_BLOCK(m)  ((void *)(MBLOCK_SIZE-BLOCK_SIZE + (W_)(m)))

/* First real block descriptor in a megablock */

#define FIRST_BDESCR(m) \
   ((bdescr *)((FIRST_BLOCK_OFF>>(BLOCK_SHIFT-BDESCR_SHIFT)) + (W_)(m)))

/* Last real block descriptor in a megablock */

#define LAST_BDESCR(m) \
  ((bdescr *)(((MBLOCK_SIZE-BLOCK_SIZE)>>(BLOCK_SHIFT-BDESCR_SHIFT)) + (W_)(m)))

/* Number of usable blocks in a megablock */

#ifndef CMINUSMINUS // already defined in DerivedConstants.h
#define BLOCKS_PER_MBLOCK ((MBLOCK_SIZE - FIRST_BLOCK_OFF) / BLOCK_SIZE)
#endif

/* How many blocks in this megablock group */

#define MBLOCK_GROUP_BLOCKS(n) \
   (BLOCKS_PER_MBLOCK + (n-1) * (MBLOCK_SIZE / BLOCK_SIZE))

/* Compute the required size of a megablock group */

#define BLOCKS_TO_MBLOCKS(n) \
   (1 + (W_)MBLOCK_ROUND_UP((n-BLOCKS_PER_MBLOCK) * BLOCK_SIZE) / MBLOCK_SIZE)


#ifndef CMINUSMINUS
/* to the end... */

/* Double-linked block lists: --------------------------------------------- */

INLINE_HEADER void
dbl_link_onto(bdescr *bd, bdescr **list)
{
  bd->link = *list;
  bd->u.back = NULL;
  if (*list) {
    (*list)->u.back = bd; /* double-link the list */
  }
  *list = bd;
}

INLINE_HEADER void
dbl_link_remove(bdescr *bd, bdescr **list)
{
    if (bd->u.back) {
        bd->u.back->link = bd->link;
    } else {
        *list = bd->link;
    }
    if (bd->link) {
        bd->link->u.back = bd->u.back;
    }
}

INLINE_HEADER void
dbl_link_insert_after(bdescr *bd, bdescr *after)
{
    bd->link = after->link;
    bd->u.back = after;
    if (after->link) {
        after->link->u.back = bd;
    }
    after->link = bd;
}

INLINE_HEADER void
dbl_link_replace(bdescr *new_, bdescr *old, bdescr **list)
{
    new_->link = old->link;
    new_->u.back = old->u.back;
    if (old->link) {
        old->link->u.back = new_;
    }
    if (old->u.back) {
        old->u.back->link = new_;
    } else {
        *list = new_;
    }
}

/* Initialisation ---------------------------------------------------------- */

extern void initBlockAllocator(void);

/* Allocation -------------------------------------------------------------- */

bdescr *allocGroup(W_ n);
bdescr *allocBlock(void);

// versions that take the storage manager lock for you:
bdescr *allocGroup_lock(W_ n);
bdescr *allocBlock_lock(void);

/* De-Allocation ----------------------------------------------------------- */

void freeGroup(bdescr *p);
void freeChain(bdescr *p);

// versions that take the storage manager lock for you:
void freeGroup_lock(bdescr *p);
void freeChain_lock(bdescr *p);

bdescr * splitBlockGroup (bdescr *bd, nat blocks);

/* Round a value to megablocks --------------------------------------------- */

// We want to allocate an object around a given size, round it up or
// down to the nearest size that will fit in an mblock group.
INLINE_HEADER StgWord
round_to_mblocks(StgWord words)
{
    if (words > BLOCKS_PER_MBLOCK * BLOCK_SIZE_W) {
        // first, ignore the gap at the beginning of the first mblock by
        // adding it to the total words.  Then we can pretend we're
        // dealing in a uniform unit of megablocks.
        words += FIRST_BLOCK_OFF/sizeof(W_);

        if ((words % MBLOCK_SIZE_W) < (MBLOCK_SIZE_W / 2)) {
            words = (words / MBLOCK_SIZE_W) * MBLOCK_SIZE_W;
        } else {
            words = ((words / MBLOCK_SIZE_W) + 1) * MBLOCK_SIZE_W;
        }

        words -= FIRST_BLOCK_OFF/sizeof(W_);
    }
    return words;
}

INLINE_HEADER StgWord
round_up_to_mblocks(StgWord words)
{
    words += FIRST_BLOCK_OFF/sizeof(W_);
    words = ((words / MBLOCK_SIZE_W) + 1) * MBLOCK_SIZE_W;
    words -= FIRST_BLOCK_OFF/sizeof(W_);
    return words;
}

#endif /* !CMINUSMINUS */
#endif /* RTS_STORAGE_BLOCK_H */
{-# START_FILE include/ghc-8.0.2/rts/storage/ClosureMacros.h #-}
/* ----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2012
 *
 * Macros for building and manipulating closures
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_STORAGE_CLOSUREMACROS_H
#define RTS_STORAGE_CLOSUREMACROS_H

/* -----------------------------------------------------------------------------
   Info tables are slammed up against the entry code, and the label
   for the info table is at the *end* of the table itself.  This
   inline function adjusts an info pointer to point to the beginning
   of the table, so we can use standard C structure indexing on it.

   Note: this works for SRT info tables as long as you don't want to
   access the SRT, since they are laid out the same with the SRT
   pointer as the first word in the table.

   NOTES ABOUT MANGLED C VS. MINI-INTERPRETER:

   A couple of definitions:

       "info pointer"    The first word of the closure.  Might point
                         to either the end or the beginning of the
                         info table, depending on whether we're using
                         the mini interpreter or not.  GET_INFO(c)
                         retrieves the info pointer of a closure.

       "info table"      The info table structure associated with a
                         closure.  This is always a pointer to the
                         beginning of the structure, so we can
                         use standard C structure indexing to pull out
                         the fields.  get_itbl(c) returns a pointer to
                         the info table for closure c.

   An address of the form xxxx_info points to the end of the info
   table or the beginning of the info table depending on whether we're
   mangling or not respectively.  So,

         c->header.info = xxx_info

   makes absolute sense, whether mangling or not.

   -------------------------------------------------------------------------- */

INLINE_HEADER void SET_INFO(StgClosure *c, const StgInfoTable *info) {
    c->header.info = info;
}
INLINE_HEADER const StgInfoTable *GET_INFO(StgClosure *c) {
    return c->header.info;
}

#define GET_ENTRY(c)  (ENTRY_CODE(GET_INFO(c)))

#ifdef TABLES_NEXT_TO_CODE
EXTERN_INLINE StgInfoTable *INFO_PTR_TO_STRUCT(const StgInfoTable *info);
EXTERN_INLINE StgInfoTable *INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgInfoTable *)info - 1;}
EXTERN_INLINE StgRetInfoTable *RET_INFO_PTR_TO_STRUCT(const StgInfoTable *info);
EXTERN_INLINE StgRetInfoTable *RET_INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgRetInfoTable *)info - 1;}
INLINE_HEADER StgFunInfoTable *FUN_INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgFunInfoTable *)info - 1;}
INLINE_HEADER StgThunkInfoTable *THUNK_INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgThunkInfoTable *)info - 1;}
INLINE_HEADER StgConInfoTable *CON_INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgConInfoTable *)info - 1;}
INLINE_HEADER StgFunInfoTable *itbl_to_fun_itbl(const StgInfoTable *i) {return (StgFunInfoTable *)(i + 1) - 1;}
INLINE_HEADER StgRetInfoTable *itbl_to_ret_itbl(const StgInfoTable *i) {return (StgRetInfoTable *)(i + 1) - 1;}
INLINE_HEADER StgThunkInfoTable *itbl_to_thunk_itbl(const StgInfoTable *i) {return (StgThunkInfoTable *)(i + 1) - 1;}
INLINE_HEADER StgConInfoTable *itbl_to_con_itbl(const StgInfoTable *i) {return (StgConInfoTable *)(i + 1) - 1;}
#else
EXTERN_INLINE StgInfoTable *INFO_PTR_TO_STRUCT(const StgInfoTable *info);
EXTERN_INLINE StgInfoTable *INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgInfoTable *)info;}
EXTERN_INLINE StgRetInfoTable *RET_INFO_PTR_TO_STRUCT(const StgInfoTable *info);
EXTERN_INLINE StgRetInfoTable *RET_INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgRetInfoTable *)info;}
INLINE_HEADER StgFunInfoTable *FUN_INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgFunInfoTable *)info;}
INLINE_HEADER StgThunkInfoTable *THUNK_INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgThunkInfoTable *)info;}
INLINE_HEADER StgConInfoTable *CON_INFO_PTR_TO_STRUCT(const StgInfoTable *info) {return (StgConInfoTable *)info;}
INLINE_HEADER StgFunInfoTable *itbl_to_fun_itbl(const StgInfoTable *i) {return (StgFunInfoTable *)i;}
INLINE_HEADER StgRetInfoTable *itbl_to_ret_itbl(const StgInfoTable *i) {return (StgRetInfoTable *)i;}
INLINE_HEADER StgThunkInfoTable *itbl_to_thunk_itbl(const StgInfoTable *i) {return (StgThunkInfoTable *)i;}
INLINE_HEADER StgConInfoTable *itbl_to_con_itbl(const StgInfoTable *i) {return (StgConInfoTable *)i;}
#endif

EXTERN_INLINE StgInfoTable *get_itbl(const StgClosure *c);
EXTERN_INLINE StgInfoTable *get_itbl(const StgClosure *c) {return INFO_PTR_TO_STRUCT(c->header.info);}

EXTERN_INLINE StgRetInfoTable *get_ret_itbl(const StgClosure *c);
EXTERN_INLINE StgRetInfoTable *get_ret_itbl(const StgClosure *c) {return RET_INFO_PTR_TO_STRUCT(c->header.info);}

INLINE_HEADER StgFunInfoTable *get_fun_itbl(const StgClosure *c) {return FUN_INFO_PTR_TO_STRUCT(c->header.info);}

INLINE_HEADER StgThunkInfoTable *get_thunk_itbl(const StgClosure *c) {return THUNK_INFO_PTR_TO_STRUCT(c->header.info);}

INLINE_HEADER StgConInfoTable *get_con_itbl(const StgClosure *c) {return CON_INFO_PTR_TO_STRUCT((c)->header.info);}

INLINE_HEADER StgHalfWord GET_TAG(const StgClosure *con) {
    return get_itbl(con)->srt_bitmap;
}

/* -----------------------------------------------------------------------------
   Macros for building closures
   -------------------------------------------------------------------------- */

#ifdef PROFILING
#ifdef DEBUG_RETAINER
/*
  For the sake of debugging, we take the safest way for the moment. Actually, this
  is useful to check the sanity of heap before beginning retainer profiling.
  flip is defined in RetainerProfile.c, and declared as extern in RetainerProfile.h.
  Note: change those functions building Haskell objects from C datatypes, i.e.,
  all rts_mk???() functions in RtsAPI.c, as well.
 */
#define SET_PROF_HDR(c,ccs_)            \
        ((c)->header.prof.ccs = ccs_, (c)->header.prof.hp.rs = (retainerSet *)((StgWord)NULL | flip))
#else
/*
  For retainer profiling only: we do not have to set (c)->header.prof.hp.rs to
  NULL | flip (flip is defined in RetainerProfile.c) because even when flip
  is 1, rs is invalid and will be initialized to NULL | flip later when
  the closure *c is visited.
 */
/*
#define SET_PROF_HDR(c,ccs_)            \
        ((c)->header.prof.ccs = ccs_, (c)->header.prof.hp.rs = NULL)
 */
/*
  The following macro works for both retainer profiling and LDV profiling:
  for retainer profiling, ldvTime remains 0, so rs fields are initialized to 0.
  See the invariants on ldvTime.
 */
#define SET_PROF_HDR(c,ccs_)            \
        ((c)->header.prof.ccs = ccs_,   \
        LDV_RECORD_CREATE((c)))
#endif /* DEBUG_RETAINER */
#else
#define SET_PROF_HDR(c,ccs)
#endif

#define SET_HDR(c,_info,ccs)                            \
   {                                                    \
        (c)->header.info = _info;                       \
        SET_PROF_HDR((StgClosure *)(c),ccs);            \
   }

#define SET_ARR_HDR(c,info,costCentreStack,n_bytes)     \
   SET_HDR(c,info,costCentreStack);                     \
   (c)->bytes = n_bytes;

// Use when changing a closure from one kind to another
#define OVERWRITE_INFO(c, new_info)                             \
    OVERWRITING_CLOSURE((StgClosure *)(c));                     \
    SET_INFO((StgClosure *)(c), (new_info));                    \
    LDV_RECORD_CREATE(c);

/* -----------------------------------------------------------------------------
   How to get hold of the static link field for a static closure.
   -------------------------------------------------------------------------- */

/* These are hard-coded. */
#define FUN_STATIC_LINK(p)   (&(p)->payload[0])
#define THUNK_STATIC_LINK(p) (&(p)->payload[1])
#define IND_STATIC_LINK(p)   (&(p)->payload[1])

INLINE_HEADER StgClosure **
STATIC_LINK(const StgInfoTable *info, StgClosure *p)
{
    switch (info->type) {
    case THUNK_STATIC:
        return THUNK_STATIC_LINK(p);
    case FUN_STATIC:
        return FUN_STATIC_LINK(p);
    case IND_STATIC:
        return IND_STATIC_LINK(p);
    default:
        return &(p)->payload[info->layout.payload.ptrs +
                             info->layout.payload.nptrs];
    }
}

INLINE_HEADER StgClosure *STATIC_LINK2(const StgInfoTable *info,
                                       StgClosure *p) {
    return (*(StgClosure**)(&((p)->payload[info->layout.payload.ptrs +
                            info->layout.payload.nptrs + 1])));
}

/* -----------------------------------------------------------------------------
   INTLIKE and CHARLIKE closures.
   -------------------------------------------------------------------------- */

INLINE_HEADER P_ CHARLIKE_CLOSURE(int n) {
    return (P_)&stg_CHARLIKE_closure[(n)-MIN_CHARLIKE];
}
INLINE_HEADER P_ INTLIKE_CLOSURE(int n) {
    return (P_)&stg_INTLIKE_closure[(n)-MIN_INTLIKE];
}

/* ----------------------------------------------------------------------------
   Macros for untagging and retagging closure pointers
   For more information look at the comments in Cmm.h
   ------------------------------------------------------------------------- */

static inline StgWord
GET_CLOSURE_TAG(StgClosure * p)
{
    return (StgWord)p & TAG_MASK;
}

static inline StgClosure *
UNTAG_CLOSURE(StgClosure * p)
{
    return (StgClosure*)((StgWord)p & ~TAG_MASK);
}

static inline StgClosure *
TAG_CLOSURE(StgWord tag,StgClosure * p)
{
    return (StgClosure*)((StgWord)p | tag);
}

/* -----------------------------------------------------------------------------
   Forwarding pointers
   -------------------------------------------------------------------------- */

#define IS_FORWARDING_PTR(p) ((((StgWord)p) & 1) != 0)
#define MK_FORWARDING_PTR(p) (((StgWord)p) | 1)
#define UN_FORWARDING_PTR(p) (((StgWord)p) - 1)

/* -----------------------------------------------------------------------------
   DEBUGGING predicates for pointers

   LOOKS_LIKE_INFO_PTR(p)    returns False if p is definitely not an info ptr
   LOOKS_LIKE_CLOSURE_PTR(p) returns False if p is definitely not a closure ptr

   These macros are complete but not sound.  That is, they might
   return false positives.  Do not rely on them to distinguish info
   pointers from closure pointers, for example.

   We don't use address-space predicates these days, for portability
   reasons, and the fact that code/data can be scattered about the
   address space in a dynamically-linked environment.  Our best option
   is to look at the alleged info table and see whether it seems to
   make sense...
   -------------------------------------------------------------------------- */

INLINE_HEADER rtsBool LOOKS_LIKE_INFO_PTR_NOT_NULL (StgWord p)
{
    StgInfoTable *info = INFO_PTR_TO_STRUCT((StgInfoTable *)p);
    return (info->type != INVALID_OBJECT && info->type < N_CLOSURE_TYPES) ? rtsTrue : rtsFalse;
}

INLINE_HEADER rtsBool LOOKS_LIKE_INFO_PTR (StgWord p)
{
    return (p && (IS_FORWARDING_PTR(p) || LOOKS_LIKE_INFO_PTR_NOT_NULL(p))) ? rtsTrue : rtsFalse;
}

INLINE_HEADER rtsBool LOOKS_LIKE_CLOSURE_PTR (void *p)
{
    return LOOKS_LIKE_INFO_PTR((StgWord)(UNTAG_CLOSURE((StgClosure *)(p)))->header.info);
}

/* -----------------------------------------------------------------------------
   Macros for calculating the size of a closure
   -------------------------------------------------------------------------- */

EXTERN_INLINE StgOffset PAP_sizeW   ( nat n_args );
EXTERN_INLINE StgOffset PAP_sizeW   ( nat n_args )
{ return sizeofW(StgPAP) + n_args; }

EXTERN_INLINE StgOffset AP_sizeW   ( nat n_args );
EXTERN_INLINE StgOffset AP_sizeW   ( nat n_args )
{ return sizeofW(StgAP) + n_args; }

EXTERN_INLINE StgOffset AP_STACK_sizeW ( nat size );
EXTERN_INLINE StgOffset AP_STACK_sizeW ( nat size )
{ return sizeofW(StgAP_STACK) + size; }

EXTERN_INLINE StgOffset CONSTR_sizeW( nat p, nat np );
EXTERN_INLINE StgOffset CONSTR_sizeW( nat p, nat np )
{ return sizeofW(StgHeader) + p + np; }

EXTERN_INLINE StgOffset THUNK_SELECTOR_sizeW ( void );
EXTERN_INLINE StgOffset THUNK_SELECTOR_sizeW ( void )
{ return sizeofW(StgSelector); }

EXTERN_INLINE StgOffset BLACKHOLE_sizeW ( void );
EXTERN_INLINE StgOffset BLACKHOLE_sizeW ( void )
{ return sizeofW(StgInd); } // a BLACKHOLE is a kind of indirection

/* --------------------------------------------------------------------------
   Sizes of closures
   ------------------------------------------------------------------------*/

EXTERN_INLINE StgOffset sizeW_fromITBL( const StgInfoTable* itbl );
EXTERN_INLINE StgOffset sizeW_fromITBL( const StgInfoTable* itbl )
{ return sizeofW(StgClosure)
       + sizeofW(StgPtr)  * itbl->layout.payload.ptrs
       + sizeofW(StgWord) * itbl->layout.payload.nptrs; }

EXTERN_INLINE StgOffset thunk_sizeW_fromITBL( const StgInfoTable* itbl );
EXTERN_INLINE StgOffset thunk_sizeW_fromITBL( const StgInfoTable* itbl )
{ return sizeofW(StgThunk)
       + sizeofW(StgPtr)  * itbl->layout.payload.ptrs
       + sizeofW(StgWord) * itbl->layout.payload.nptrs; }

EXTERN_INLINE StgOffset ap_stack_sizeW( StgAP_STACK* x );
EXTERN_INLINE StgOffset ap_stack_sizeW( StgAP_STACK* x )
{ return AP_STACK_sizeW(x->size); }

EXTERN_INLINE StgOffset ap_sizeW( StgAP* x );
EXTERN_INLINE StgOffset ap_sizeW( StgAP* x )
{ return AP_sizeW(x->n_args); }

EXTERN_INLINE StgOffset pap_sizeW( StgPAP* x );
EXTERN_INLINE StgOffset pap_sizeW( StgPAP* x )
{ return PAP_sizeW(x->n_args); }

EXTERN_INLINE StgWord arr_words_words( StgArrBytes* x);
EXTERN_INLINE StgWord arr_words_words( StgArrBytes* x)
{ return ROUNDUP_BYTES_TO_WDS(x->bytes); }

EXTERN_INLINE StgOffset arr_words_sizeW( StgArrBytes* x );
EXTERN_INLINE StgOffset arr_words_sizeW( StgArrBytes* x )
{ return sizeofW(StgArrBytes) + arr_words_words(x); }

EXTERN_INLINE StgOffset mut_arr_ptrs_sizeW( StgMutArrPtrs* x );
EXTERN_INLINE StgOffset mut_arr_ptrs_sizeW( StgMutArrPtrs* x )
{ return sizeofW(StgMutArrPtrs) + x->size; }

EXTERN_INLINE StgOffset small_mut_arr_ptrs_sizeW( StgSmallMutArrPtrs* x );
EXTERN_INLINE StgOffset small_mut_arr_ptrs_sizeW( StgSmallMutArrPtrs* x )
{ return sizeofW(StgSmallMutArrPtrs) + x->ptrs; }

EXTERN_INLINE StgWord stack_sizeW ( StgStack *stack );
EXTERN_INLINE StgWord stack_sizeW ( StgStack *stack )
{ return sizeofW(StgStack) + stack->stack_size; }

EXTERN_INLINE StgWord bco_sizeW ( StgBCO *bco );
EXTERN_INLINE StgWord bco_sizeW ( StgBCO *bco )
{ return bco->size; }

/*
 * TODO: Consider to switch return type from 'nat' to 'StgWord' #8742
 *
 * (Also for 'closure_sizeW' below)
 */
EXTERN_INLINE nat closure_sizeW_ (StgClosure *p, StgInfoTable *info);
EXTERN_INLINE nat
closure_sizeW_ (StgClosure *p, StgInfoTable *info)
{
    switch (info->type) {
    case THUNK_0_1:
    case THUNK_1_0:
        return sizeofW(StgThunk) + 1;
    case FUN_0_1:
    case CONSTR_0_1:
    case FUN_1_0:
    case CONSTR_1_0:
        return sizeofW(StgHeader) + 1;
    case THUNK_0_2:
    case THUNK_1_1:
    case THUNK_2_0:
        return sizeofW(StgThunk) + 2;
    case FUN_0_2:
    case CONSTR_0_2:
    case FUN_1_1:
    case CONSTR_1_1:
    case FUN_2_0:
    case CONSTR_2_0:
        return sizeofW(StgHeader) + 2;
    case THUNK:
        return thunk_sizeW_fromITBL(info);
    case THUNK_SELECTOR:
        return THUNK_SELECTOR_sizeW();
    case AP_STACK:
        return ap_stack_sizeW((StgAP_STACK *)p);
    case AP:
        return ap_sizeW((StgAP *)p);
    case PAP:
        return pap_sizeW((StgPAP *)p);
    case IND:
    case IND_PERM:
        return sizeofW(StgInd);
    case ARR_WORDS:
        return arr_words_sizeW((StgArrBytes *)p);
    case MUT_ARR_PTRS_CLEAN:
    case MUT_ARR_PTRS_DIRTY:
    case MUT_ARR_PTRS_FROZEN:
    case MUT_ARR_PTRS_FROZEN0:
        return mut_arr_ptrs_sizeW((StgMutArrPtrs*)p);
    case SMALL_MUT_ARR_PTRS_CLEAN:
    case SMALL_MUT_ARR_PTRS_DIRTY:
    case SMALL_MUT_ARR_PTRS_FROZEN:
    case SMALL_MUT_ARR_PTRS_FROZEN0:
        return small_mut_arr_ptrs_sizeW((StgSmallMutArrPtrs*)p);
    case TSO:
        return sizeofW(StgTSO);
    case STACK:
        return stack_sizeW((StgStack*)p);
    case BCO:
        return bco_sizeW((StgBCO *)p);
    case TREC_CHUNK:
        return sizeofW(StgTRecChunk);
    default:
        return sizeW_fromITBL(info);
    }
}

// The definitive way to find the size, in words, of a heap-allocated closure
EXTERN_INLINE nat closure_sizeW (StgClosure *p);
EXTERN_INLINE nat closure_sizeW (StgClosure *p)
{
    return closure_sizeW_(p, get_itbl(p));
}

/* -----------------------------------------------------------------------------
   Sizes of stack frames
   -------------------------------------------------------------------------- */

EXTERN_INLINE StgWord stack_frame_sizeW( StgClosure *frame );
EXTERN_INLINE StgWord stack_frame_sizeW( StgClosure *frame )
{
    StgRetInfoTable *info;

    info = get_ret_itbl(frame);
    switch (info->i.type) {

    case RET_FUN:
        return sizeofW(StgRetFun) + ((StgRetFun *)frame)->size;

    case RET_BIG:
        return 1 + GET_LARGE_BITMAP(&info->i)->size;

    case RET_BCO:
        return 2 + BCO_BITMAP_SIZE((StgBCO *)((P_)frame)[1]);

    default:
        return 1 + BITMAP_SIZE(info->i.layout.bitmap);
    }
}

/* -----------------------------------------------------------------------------
   StgMutArrPtrs macros

   An StgMutArrPtrs has a card table to indicate which elements are
   dirty for the generational GC.  The card table is an array of
   bytes, where each byte covers (1 << MUT_ARR_PTRS_CARD_BITS)
   elements.  The card table is directly after the array data itself.
   -------------------------------------------------------------------------- */

// The number of card bytes needed
INLINE_HEADER W_ mutArrPtrsCards (W_ elems)
{
    return (W_)((elems + (1 << MUT_ARR_PTRS_CARD_BITS) - 1)
                           >> MUT_ARR_PTRS_CARD_BITS);
}

// The number of words in the card table
INLINE_HEADER W_ mutArrPtrsCardTableSize (W_ elems)
{
    return ROUNDUP_BYTES_TO_WDS(mutArrPtrsCards(elems));
}

// The address of the card for a particular card number
INLINE_HEADER StgWord8 *mutArrPtrsCard (StgMutArrPtrs *a, W_ n)
{
    return ((StgWord8 *)&(a->payload[a->ptrs]) + n);
}

/* -----------------------------------------------------------------------------
   Replacing a closure with a different one.  We must call
   OVERWRITING_CLOSURE(p) on the old closure that is about to be
   overwritten.

   Note [zeroing slop]

   In some scenarios we write zero words into "slop"; memory that is
   left unoccupied after we overwrite a closure in the heap with a
   smaller closure.

   Zeroing slop is required for:

    - full-heap sanity checks (DEBUG, and +RTS -DS)
    - LDV profiling (PROFILING, and +RTS -hb)

   Zeroing slop must be disabled for:

    - THREADED_RTS with +RTS -N2 and greater, because we cannot
      overwrite slop when another thread might be reading it.

   Hence, slop is zeroed when either:

    - PROFILING && era <= 0 (LDV is on)
    - !THREADED_RTS && DEBUG

   And additionally:

    - LDV profiling and +RTS -N2 are incompatible
    - full-heap sanity checks are disabled for THREADED_RTS

   -------------------------------------------------------------------------- */

#define ZERO_SLOP_FOR_LDV_PROF     (defined(PROFILING))
#define ZERO_SLOP_FOR_SANITY_CHECK (defined(DEBUG) && !defined(THREADED_RTS))

#if ZERO_SLOP_FOR_LDV_PROF || ZERO_SLOP_FOR_SANITY_CHECK
#define OVERWRITING_CLOSURE(c) overwritingClosure(c)
#define OVERWRITING_CLOSURE_OFS(c,n) \
    overwritingClosureOfs(c,n)
#else
#define OVERWRITING_CLOSURE(c) /* nothing */
#define OVERWRITING_CLOSURE_OFS(c,n) /* nothing */
#endif

#ifdef PROFILING
void LDV_recordDead (StgClosure *c, nat size);
#endif

EXTERN_INLINE void overwritingClosure (StgClosure *p);
EXTERN_INLINE void overwritingClosure (StgClosure *p)
{
    nat size, i;

#if ZERO_SLOP_FOR_LDV_PROF && !ZERO_SLOP_FOR_SANITY_CHECK
    // see Note [zeroing slop], also #8402
    if (era <= 0) return;
#endif

    size = closure_sizeW(p);

    // For LDV profiling, we need to record the closure as dead
#if defined(PROFILING)
    LDV_recordDead(p, size);
#endif

    for (i = 0; i < size - sizeofW(StgThunkHeader); i++) {
        ((StgThunk *)(p))->payload[i] = 0;
    }
}

// Version of 'overwritingClosure' which overwrites only a suffix of a
// closure.  The offset is expressed in words relative to 'p' and shall
// be less than or equal to closure_sizeW(p), and usually at least as
// large as the respective thunk header.
//
// Note: As this calls LDV_recordDead() you have to call LDV_RECORD()
//       on the final state of the closure at the call-site
EXTERN_INLINE void overwritingClosureOfs (StgClosure *p, nat offset);
EXTERN_INLINE void overwritingClosureOfs (StgClosure *p, nat offset)
{
    nat size, i;

#if ZERO_SLOP_FOR_LDV_PROF && !ZERO_SLOP_FOR_SANITY_CHECK
    // see Note [zeroing slop], also #8402
    if (era <= 0) return;
#endif

    size = closure_sizeW(p);

    ASSERT(offset <= size);

    // For LDV profiling, we need to record the closure as dead
#if defined(PROFILING)
    LDV_recordDead(p, size);
#endif

    for (i = offset; i < size; i++)
        ((StgWord *)p)[i] = 0;
}

#endif /* RTS_STORAGE_CLOSUREMACROS_H */
{-# START_FILE include/ghc-8.0.2/rts/storage/Closures.h #-}
/* ----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2004
 *
 * Closures
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_STORAGE_CLOSURES_H
#define RTS_STORAGE_CLOSURES_H

/*
 * The Layout of a closure header depends on which kind of system we're
 * compiling for: profiling, parallel, ticky, etc.
 */

/* -----------------------------------------------------------------------------
   The profiling header
   -------------------------------------------------------------------------- */

typedef struct {
  CostCentreStack *ccs;
  union {
    struct _RetainerSet *rs;  /* Retainer Set */
    StgWord ldvw;             /* Lag/Drag/Void Word */
  } hp;
} StgProfHeader;

/* -----------------------------------------------------------------------------
   The SMP header

   A thunk has a padding word to take the updated value.  This is so
   that the update doesn't overwrite the payload, so we can avoid
   needing to lock the thunk during entry and update.

   Note: this doesn't apply to THUNK_STATICs, which have no payload.

   Note: we leave this padding word in all ways, rather than just SMP,
   so that we don't have to recompile all our libraries for SMP.
   -------------------------------------------------------------------------- */

typedef struct {
    StgWord pad;
} StgSMPThunkHeader;

/* -----------------------------------------------------------------------------
   The full fixed-size closure header

   The size of the fixed header is the sum of the optional parts plus a single
   word for the entry code pointer.
   -------------------------------------------------------------------------- */

typedef struct {
    const StgInfoTable* info;
#ifdef PROFILING
    StgProfHeader         prof;
#endif
} StgHeader;

typedef struct {
    const StgInfoTable* info;
#ifdef PROFILING
    StgProfHeader         prof;
#endif
    StgSMPThunkHeader     smp;
} StgThunkHeader;

#define THUNK_EXTRA_HEADER_W (sizeofW(StgThunkHeader)-sizeofW(StgHeader))

/* -----------------------------------------------------------------------------
   Closure Types

   For any given closure type (defined in InfoTables.h), there is a
   corresponding structure defined below.  The name of the structure
   is obtained by concatenating the closure type with '_closure'
   -------------------------------------------------------------------------- */

/* All closures follow the generic format */

typedef struct StgClosure_ {
    StgHeader   header;
    struct StgClosure_ *payload[FLEXIBLE_ARRAY];
} *StgClosurePtr; // StgClosure defined in rts/Types.h

typedef struct {
    StgThunkHeader  header;
    struct StgClosure_ *payload[FLEXIBLE_ARRAY];
} StgThunk;

typedef struct {
    StgThunkHeader   header;
    StgClosure *selectee;
} StgSelector;

typedef struct {
    StgHeader   header;
    StgHalfWord arity;          /* zero if it is an AP */
    StgHalfWord n_args;
    StgClosure *fun;            /* really points to a fun */
    StgClosure *payload[FLEXIBLE_ARRAY];
} StgPAP;

typedef struct {
    StgThunkHeader   header;
    StgHalfWord arity;          /* zero if it is an AP */
    StgHalfWord n_args;
    StgClosure *fun;            /* really points to a fun */
    StgClosure *payload[FLEXIBLE_ARRAY];
} StgAP;

typedef struct {
    StgThunkHeader   header;
    StgWord     size;                    /* number of words in payload */
    StgClosure *fun;
    StgClosure *payload[FLEXIBLE_ARRAY]; /* contains a chunk of *stack* */
} StgAP_STACK;

typedef struct {
    StgHeader   header;
    StgClosure *indirectee;
} StgInd;

typedef struct {
    StgHeader     header;
    StgClosure   *indirectee;
    StgClosure   *static_link;
    const StgInfoTable *saved_info;
} StgIndStatic;

typedef struct StgBlockingQueue_ {
    StgHeader   header;
    struct StgBlockingQueue_ *link; // here so it looks like an IND
    StgClosure *bh;  // the BLACKHOLE
    StgTSO     *owner;
    struct MessageBlackHole_ *queue;
} StgBlockingQueue;

typedef struct {
    StgHeader  header;
    StgWord    bytes;
    StgWord    payload[FLEXIBLE_ARRAY];
} StgArrBytes;

typedef struct {
    StgHeader   header;
    StgWord     ptrs;
    StgWord     size; // ptrs plus card table
    StgClosure *payload[FLEXIBLE_ARRAY];
    // see also: StgMutArrPtrs macros in ClosureMacros.h
} StgMutArrPtrs;

typedef struct {
    StgHeader   header;
    StgWord     ptrs;
    StgClosure *payload[FLEXIBLE_ARRAY];
} StgSmallMutArrPtrs;

typedef struct {
    StgHeader   header;
    StgClosure *var;
} StgMutVar;

typedef struct _StgUpdateFrame {
    StgHeader  header;
    StgClosure *updatee;
} StgUpdateFrame;

typedef struct {
    StgHeader  header;
    StgWord    exceptions_blocked;
    StgClosure *handler;
} StgCatchFrame;

typedef struct {
    const StgInfoTable* info;
    struct StgStack_ *next_chunk;
} StgUnderflowFrame;

typedef struct {
    StgHeader  header;
} StgStopFrame;

typedef struct {
  StgHeader header;
  StgWord data;
} StgIntCharlikeClosure;

/* statically allocated */
typedef struct {
  StgHeader  header;
} StgRetry;

typedef struct _StgStableName {
  StgHeader      header;
  StgWord        sn;
} StgStableName;

typedef struct _StgWeak {       /* Weak v */
  StgHeader header;
  StgClosure *cfinalizers;
  StgClosure *key;
  StgClosure *value;            /* v */
  StgClosure *finalizer;
  struct _StgWeak *link;
} StgWeak;

typedef struct _StgCFinalizerList {
  StgHeader header;
  StgClosure *link;
  void (*fptr)(void);
  void *ptr;
  void *eptr;
  StgWord flag; /* has environment (0 or 1) */
} StgCFinalizerList;

/* Byte code objects.  These are fixed size objects with pointers to
 * four arrays, designed so that a BCO can be easily "re-linked" to
 * other BCOs, to facilitate GHC's intelligent recompilation.  The
 * array of instructions is static and not re-generated when the BCO
 * is re-linked, but the other 3 arrays will be regenerated.
 *
 * A BCO represents either a function or a stack frame.  In each case,
 * it needs a bitmap to describe to the garbage collector the
 * pointerhood of its arguments/free variables respectively, and in
 * the case of a function it also needs an arity.  These are stored
 * directly in the BCO, rather than in the instrs array, for two
 * reasons:
 * (a) speed: we need to get at the bitmap info quickly when
 *     the GC is examining APs and PAPs that point to this BCO
 * (b) a subtle interaction with the compacting GC.  In compacting
 *     GC, the info that describes the size/layout of a closure
 *     cannot be in an object more than one level of indirection
 *     away from the current object, because of the order in
 *     which pointers are updated to point to their new locations.
 */

typedef struct {
    StgHeader      header;
    StgArrBytes   *instrs;      /* a pointer to an ArrWords */
    StgArrBytes   *literals;    /* a pointer to an ArrWords */
    StgMutArrPtrs *ptrs;        /* a pointer to a  MutArrPtrs */
    StgHalfWord   arity;        /* arity of this BCO */
    StgHalfWord   size;         /* size of this BCO (in words) */
    StgWord       bitmap[FLEXIBLE_ARRAY];  /* an StgLargeBitmap */
} StgBCO;

#define BCO_BITMAP(bco)      ((StgLargeBitmap *)((StgBCO *)(bco))->bitmap)
#define BCO_BITMAP_SIZE(bco) (BCO_BITMAP(bco)->size)
#define BCO_BITMAP_BITS(bco) (BCO_BITMAP(bco)->bitmap)
#define BCO_BITMAP_SIZEW(bco) ((BCO_BITMAP_SIZE(bco) + BITS_IN(StgWord) - 1) \
                                / BITS_IN(StgWord))

/* A function return stack frame: used when saving the state for a
 * garbage collection at a function entry point.  The function
 * arguments are on the stack, and we also save the function (its
 * info table describes the pointerhood of the arguments).
 *
 * The stack frame size is also cached in the frame for convenience.
 */
typedef struct {
    const StgInfoTable* info;
    StgWord        size;
    StgClosure *   fun;
    StgClosure *   payload[FLEXIBLE_ARRAY];
} StgRetFun;

/* Concurrent communication objects */

typedef struct StgMVarTSOQueue_ {
    StgHeader                header;
    struct StgMVarTSOQueue_ *link;
    struct StgTSO_          *tso;
} StgMVarTSOQueue;

typedef struct {
    StgHeader                header;
    struct StgMVarTSOQueue_ *head;
    struct StgMVarTSOQueue_ *tail;
    StgClosure*              value;
} StgMVar;


/* STM data structures
 *
 *  StgTVar defines the only type that can be updated through the STM
 *  interface.
 *
 *  Note that various optimisations may be possible in order to use less
 *  space for these data structures at the cost of more complexity in the
 *  implementation:
 *
 *   - In StgTVar, current_value and first_watch_queue_entry could be held in
 *     the same field: if any thread is waiting then its expected_value for
 *     the tvar is the current value.
 *
 *   - In StgTRecHeader, it might be worthwhile having separate chunks
 *     of read-only and read-write locations.  This would save a
 *     new_value field in the read-only locations.
 *
 *   - In StgAtomicallyFrame, we could combine the waiting bit into
 *     the header (maybe a different info tbl for a waiting transaction).
 *     This means we can specialise the code for the atomically frame
 *     (it immediately switches on frame->waiting anyway).
 */

typedef struct StgTRecHeader_ StgTRecHeader;

typedef struct StgTVarWatchQueue_ {
  StgHeader                  header;
  StgClosure                *closure; // StgTSO or StgAtomicInvariant
  struct StgTVarWatchQueue_ *next_queue_entry;
  struct StgTVarWatchQueue_ *prev_queue_entry;
} StgTVarWatchQueue;

typedef struct {
  StgHeader                  header;
  StgClosure                *volatile current_value;
  StgTVarWatchQueue         *volatile first_watch_queue_entry;
  StgInt                     volatile num_updates;
} StgTVar;

typedef struct {
  StgHeader      header;
  StgClosure    *code;
  StgTRecHeader *last_execution;
  StgWord        lock;
} StgAtomicInvariant;

/* new_value == expected_value for read-only accesses */
/* new_value is a StgTVarWatchQueue entry when trec in state TREC_WAITING */
typedef struct {
  StgTVar                   *tvar;
  StgClosure                *expected_value;
  StgClosure                *new_value;
#if defined(THREADED_RTS)
  StgInt                     num_updates;
#endif
} TRecEntry;

#define TREC_CHUNK_NUM_ENTRIES 16

typedef struct StgTRecChunk_ {
  StgHeader                  header;
  struct StgTRecChunk_      *prev_chunk;
  StgWord                    next_entry_idx;
  TRecEntry                  entries[TREC_CHUNK_NUM_ENTRIES];
} StgTRecChunk;

typedef enum {
  TREC_ACTIVE,        /* Transaction in progress, outcome undecided */
  TREC_CONDEMNED,     /* Transaction in progress, inconsistent / out of date reads */
  TREC_COMMITTED,     /* Transaction has committed, now updating tvars */
  TREC_ABORTED,       /* Transaction has aborted, now reverting tvars */
  TREC_WAITING,       /* Transaction currently waiting */
} TRecState;

typedef struct StgInvariantCheckQueue_ {
  StgHeader                       header;
  StgAtomicInvariant             *invariant;
  StgTRecHeader                  *my_execution;
  struct StgInvariantCheckQueue_ *next_queue_entry;
} StgInvariantCheckQueue;

struct StgTRecHeader_ {
  StgHeader                  header;
  struct StgTRecHeader_     *enclosing_trec;
  StgTRecChunk              *current_chunk;
  StgInvariantCheckQueue    *invariants_to_check;
  TRecState                  state;
};

typedef struct {
  StgHeader   header;
  StgClosure *code;
  StgTVarWatchQueue *next_invariant_to_check;
  StgClosure *result;
} StgAtomicallyFrame;

typedef struct {
  StgHeader   header;
  StgClosure *code;
  StgClosure *handler;
} StgCatchSTMFrame;

typedef struct {
  StgHeader      header;
  StgWord        running_alt_code;
  StgClosure    *first_code;
  StgClosure    *alt_code;
} StgCatchRetryFrame;

/* ----------------------------------------------------------------------------
   Messages
   ------------------------------------------------------------------------- */

typedef struct Message_ {
    StgHeader        header;
    struct Message_ *link;
} Message;

typedef struct MessageWakeup_ {
    StgHeader header;
    Message  *link;
    StgTSO   *tso;
} MessageWakeup;

typedef struct MessageThrowTo_ {
    StgHeader   header;
    struct MessageThrowTo_ *link;
    StgTSO     *source;
    StgTSO     *target;
    StgClosure *exception;
} MessageThrowTo;

typedef struct MessageBlackHole_ {
    StgHeader   header;
    struct MessageBlackHole_ *link;
    StgTSO     *tso;
    StgClosure *bh;
} MessageBlackHole;

#endif /* RTS_STORAGE_CLOSURES_H */
{-# START_FILE include/ghc-8.0.2/rts/storage/ClosureTypes.h #-}
/* ----------------------------------------------------------------------------
 * 
 * (c) The GHC Team, 1998-2005
 *
 * Closure Type Constants: out here because the native code generator
 * needs to get at them.
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_STORAGE_CLOSURETYPES_H
#define RTS_STORAGE_CLOSURETYPES_H

/* 
 * WARNING WARNING WARNING
 *
 * If you add or delete any closure types, don't forget to update
 * the closure flags table in rts/ClosureFlags.c.
 */

/* Object tag 0 raises an internal error */
#define INVALID_OBJECT          0
#define CONSTR                  1
#define CONSTR_1_0              2
#define CONSTR_0_1              3
#define CONSTR_2_0              4
#define CONSTR_1_1              5
#define CONSTR_0_2              6
#define CONSTR_STATIC           7
#define CONSTR_NOCAF_STATIC     8
#define FUN                     9
#define FUN_1_0                 10
#define FUN_0_1                 11
#define FUN_2_0                 12
#define FUN_1_1                 13
#define FUN_0_2                 14
#define FUN_STATIC              15
#define THUNK                   16
#define THUNK_1_0               17
#define THUNK_0_1               18
#define THUNK_2_0               19
#define THUNK_1_1               20
#define THUNK_0_2               21
#define THUNK_STATIC            22
#define THUNK_SELECTOR          23
#define BCO                     24
#define AP                      25
#define PAP                     26
#define AP_STACK                27
#define IND                     28
#define IND_PERM                29
#define IND_STATIC              30
#define RET_BCO                 31
#define RET_SMALL               32
#define RET_BIG                 33
#define RET_FUN                 34
#define UPDATE_FRAME            35
#define CATCH_FRAME             36
#define UNDERFLOW_FRAME         37
#define STOP_FRAME              38
#define BLOCKING_QUEUE          39
#define BLACKHOLE               40
#define MVAR_CLEAN              41
#define MVAR_DIRTY              42
#define TVAR                    43
#define ARR_WORDS               44
#define MUT_ARR_PTRS_CLEAN      45
#define MUT_ARR_PTRS_DIRTY      46
#define MUT_ARR_PTRS_FROZEN0    47
#define MUT_ARR_PTRS_FROZEN     48
#define MUT_VAR_CLEAN           49
#define MUT_VAR_DIRTY           50
#define WEAK                    51
#define PRIM                    52
#define MUT_PRIM                53
#define TSO                     54
#define STACK                   55
#define TREC_CHUNK              56
#define ATOMICALLY_FRAME        57
#define CATCH_RETRY_FRAME       58
#define CATCH_STM_FRAME         59
#define WHITEHOLE               60
#define SMALL_MUT_ARR_PTRS_CLEAN      61
#define SMALL_MUT_ARR_PTRS_DIRTY      62
#define SMALL_MUT_ARR_PTRS_FROZEN0    63
#define SMALL_MUT_ARR_PTRS_FROZEN     64
#define N_CLOSURE_TYPES         65

#endif /* RTS_STORAGE_CLOSURETYPES_H */
{-# START_FILE include/ghc-8.0.2/rts/storage/FunTypes.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2002
 *
 * Things for functions.
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_STORAGE_FUNTYPES_H
#define RTS_STORAGE_FUNTYPES_H

/* generic - function comes with a small bitmap */
#define ARG_GEN      0   

/* generic - function comes with a large bitmap */
#define ARG_GEN_BIG  1

/* BCO - function is really a BCO */
#define ARG_BCO      2

/*
 * Specialised function types: bitmaps and calling sequences
 * for these functions are pre-generated: see ghc/utils/genapply and
 * generated code in ghc/rts/AutoApply.cmm.
 *
 *  NOTE: other places to change if you change this table:
 *       - utils/genapply/GenApply.hs: stackApplyTypes
 *       - compiler/codeGen/CgCallConv.lhs: stdPattern
 */
#define ARG_NONE     3 
#define ARG_N        4  
#define ARG_P        5 
#define ARG_F        6 
#define ARG_D        7 
#define ARG_L        8 
#define ARG_V16      9 
#define ARG_V32      10
#define ARG_V64      11
#define ARG_NN       12 
#define ARG_NP       13
#define ARG_PN       14
#define ARG_PP       15
#define ARG_NNN      16
#define ARG_NNP      17
#define ARG_NPN      18
#define ARG_NPP      19
#define ARG_PNN      20
#define ARG_PNP      21
#define ARG_PPN      22
#define ARG_PPP      23
#define ARG_PPPP     24
#define ARG_PPPPP    25
#define ARG_PPPPPP   26
#define ARG_PPPPPPP  27
#define ARG_PPPPPPPP 28

#endif /* RTS_STORAGE_FUNTYPES_H */
{-# START_FILE include/ghc-8.0.2/rts/storage/GC.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2004
 *
 * External Storage Manger Interface
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_STORAGE_GC_H
#define RTS_STORAGE_GC_H

#include <stddef.h>
#include "rts/OSThreads.h"

/* -----------------------------------------------------------------------------
 * Generational GC
 *
 * We support an arbitrary number of generations, with an arbitrary number
 * of steps per generation.  Notes (in no particular order):
 *
 *       - all generations except the oldest should have the same
 *         number of steps.  Multiple steps gives objects a decent
 *         chance to age before being promoted, and helps ensure that
 *         we don't end up with too many thunks being updated in older
 *         generations.
 *
 *       - the oldest generation has one step.  There's no point in aging
 *         objects in the oldest generation.
 *
 *       - generation 0, step 0 (G0S0) is the allocation area.  It is given
 *         a fixed set of blocks during initialisation, and these blocks
 *         normally stay in G0S0.  In parallel execution, each
 *         Capability has its own nursery.
 *
 *       - during garbage collection, each step which is an evacuation
 *         destination (i.e. all steps except G0S0) is allocated a to-space.
 *         evacuated objects are allocated into the step's to-space until
 *         GC is finished, when the original step's contents may be freed
 *         and replaced by the to-space.
 *
 *       - the mutable-list is per-generation (not per-step).  G0 doesn't
 *         have one (since every garbage collection collects at least G0).
 *
 *       - block descriptors contain pointers to both the step and the
 *         generation that the block belongs to, for convenience.
 *
 *       - static objects are stored in per-generation lists.  See GC.c for
 *         details of how we collect CAFs in the generational scheme.
 *
 *       - large objects are per-step, and are promoted in the same way
 *         as small objects, except that we may allocate large objects into
 *         generation 1 initially.
 *
 * ------------------------------------------------------------------------- */

// A count of blocks needs to store anything up to the size of memory
// divided by the block size.  The safest thing is therefore to use a
// type that can store the full range of memory addresses,
// ie. StgWord.  Note that we have had some tricky int overflows in a
// couple of cases caused by using ints rather than longs (e.g. #5086)

typedef StgWord memcount;

typedef struct nursery_ {
    bdescr *       blocks;
    memcount       n_blocks;
} nursery;

// Nursery invariants:
//
//  - cap->r.rNursery points to the nursery for this capability
//
//  - cap->r.rCurrentNursery points to the block in the nursery that we are
//    currently allocating into.  While in Haskell the current heap pointer is
//    in Hp, outside Haskell it is stored in cap->r.rCurrentNursery->free.
//
//  - the blocks *after* cap->rCurrentNursery in the chain are empty
//    (although their bd->free pointers have not been updated to
//    reflect that)
//
//  - the blocks *before* cap->rCurrentNursery have been used.  Except
//    for rCurrentAlloc.
//
//  - cap->r.rCurrentAlloc is either NULL, or it points to a block in
//    the nursery *before* cap->r.rCurrentNursery.
//
// See also Note [allocation accounting] to understand how total
// memory allocation is tracked.

typedef struct generation_ {
    nat            no;                  // generation number

    bdescr *       blocks;              // blocks in this gen
    memcount       n_blocks;            // number of blocks
    memcount       n_words;             // number of used words

    bdescr *       large_objects;       // large objects (doubly linked)
    memcount       n_large_blocks;      // no. of blocks used by large objs
    memcount       n_large_words;       // no. of words used by large objs
    memcount       n_new_large_words;   // words of new large objects
                                        // (for doYouWantToGC())

    memcount       max_blocks;          // max blocks

    StgTSO *       threads;             // threads in this gen
                                        // linked via global_link
    StgWeak *      weak_ptr_list;       // weak pointers in this gen

    struct generation_ *to;             // destination gen for live objects

    // stats information
    nat collections;
    nat par_collections;
    nat failed_promotions;

    // ------------------------------------
    // Fields below are used during GC only

#if defined(THREADED_RTS)
    char pad[128];                      // make sure the following is
                                        // on a separate cache line.
    SpinLock     sync;                  // lock for large_objects
                                        //    and scavenged_large_objects
#endif

    int          mark;                  // mark (not copy)? (old gen only)
    int          compact;               // compact (not sweep)? (old gen only)

    // During GC, if we are collecting this gen, blocks and n_blocks
    // are copied into the following two fields.  After GC, these blocks
    // are freed.
    bdescr *     old_blocks;            // bdescr of first from-space block
    memcount     n_old_blocks;         // number of blocks in from-space
    memcount     live_estimate;         // for sweeping: estimate of live data

    bdescr *     scavenged_large_objects;  // live large objs after GC (d-link)
    memcount     n_scavenged_large_blocks; // size (not count) of above

    bdescr *     bitmap;                // bitmap for compacting collection

    StgTSO *     old_threads;
    StgWeak *    old_weak_ptr_list;
} generation;

extern generation * generations;
extern generation * g0;
extern generation * oldest_gen;

/* -----------------------------------------------------------------------------
   Generic allocation

   StgPtr allocate(Capability *cap, W_ n)
                                Allocates memory from the nursery in
                                the current Capability.

   StgPtr allocatePinned(Capability *cap, W_ n)
                                Allocates a chunk of contiguous store
                                n words long, which is at a fixed
                                address (won't be moved by GC).
                                Returns a pointer to the first word.
                                Always succeeds.

                                NOTE: the GC can't in general handle
                                pinned objects, so allocatePinned()
                                can only be used for ByteArrays at the
                                moment.

                                Don't forget to TICK_ALLOC_XXX(...)
                                after calling allocate or
                                allocatePinned, for the
                                benefit of the ticky-ticky profiler.

   -------------------------------------------------------------------------- */

StgPtr  allocate        ( Capability *cap, W_ n );
StgPtr  allocatePinned  ( Capability *cap, W_ n );

/* memory allocator for executable memory */
typedef void* AdjustorWritable;
typedef void* AdjustorExecutable;

AdjustorWritable allocateExec(W_ len, AdjustorExecutable *exec_addr);
void flushExec(W_ len, AdjustorExecutable exec_addr);
#if defined(ios_HOST_OS)
AdjustorWritable execToWritable(AdjustorExecutable exec);
#endif
void             freeExec (AdjustorExecutable p);

// Used by GC checks in external .cmm code:
extern W_ large_alloc_lim;

/* -----------------------------------------------------------------------------
   Performing Garbage Collection
   -------------------------------------------------------------------------- */

void performGC(void);
void performMajorGC(void);

/* -----------------------------------------------------------------------------
   The CAF table - used to let us revert CAFs in GHCi
   -------------------------------------------------------------------------- */

StgInd *newCAF         (StgRegTable *reg, StgIndStatic *caf);
StgInd *newRetainedCAF (StgRegTable *reg, StgIndStatic *caf);
StgInd *newGCdCAF      (StgRegTable *reg, StgIndStatic *caf);
void revertCAFs (void);

// Request that all CAFs are retained indefinitely.
// (preferably use RtsConfig.keep_cafs instead)
void setKeepCAFs (void);

/* -----------------------------------------------------------------------------
   Stats
   -------------------------------------------------------------------------- */

typedef struct _GCStats {
  StgWord64 bytes_allocated;
  StgWord64 num_gcs;
  StgWord64 num_byte_usage_samples;
  StgWord64 max_bytes_used;
  StgWord64 cumulative_bytes_used;
  StgWord64 bytes_copied;
  StgWord64 current_bytes_used;
  StgWord64 current_bytes_slop;
  StgWord64 max_bytes_slop;
  StgWord64 peak_megabytes_allocated;
  StgWord64 par_tot_bytes_copied;
  StgWord64 par_max_bytes_copied;
  StgDouble mutator_cpu_seconds;
  StgDouble mutator_wall_seconds;
  StgDouble gc_cpu_seconds;
  StgDouble gc_wall_seconds;
  StgDouble cpu_seconds;
  StgDouble wall_seconds;
} GCStats;
void getGCStats (GCStats *s);
rtsBool getGCStatsEnabled (void);

// These don't change over execution, so do them elsewhere
//  StgDouble init_cpu_seconds;
//  StgDouble init_wall_seconds;

typedef struct _ParGCStats {
  StgWord64 tot_copied;
  StgWord64 max_copied;
} ParGCStats;
void getParGCStats (ParGCStats *s);

/*
typedef struct _TaskStats {
  StgWord64 mut_time;
  StgWord64 mut_etime;
  StgWord64 gc_time;
  StgWord64 gc_etime;
} TaskStats;
// would need to allocate arbitrarily large amount of memory
// because it's a linked list of results
void getTaskStats (TaskStats **s);
// Need to stuff SparkCounters in a public header file...
void getSparkStats (SparkCounters *s);
*/

// Returns the total number of bytes allocated since the start of the program.
HsInt64 getAllocations (void);

/* -----------------------------------------------------------------------------
   This is the write barrier for MUT_VARs, a.k.a. IORefs.  A
   MUT_VAR_CLEAN object is not on the mutable list; a MUT_VAR_DIRTY
   is.  When written to, a MUT_VAR_CLEAN turns into a MUT_VAR_DIRTY
   and is put on the mutable list.
   -------------------------------------------------------------------------- */

void dirty_MUT_VAR(StgRegTable *reg, StgClosure *p);

/* set to disable CAF garbage collection in GHCi. */
/* (needed when dynamic libraries are used). */
extern rtsBool keepCAFs;

INLINE_HEADER void initBdescr(bdescr *bd, generation *gen, generation *dest)
{
    bd->gen     = gen;
    bd->gen_no  = gen->no;
    bd->dest_no = dest->no;
}

#endif /* RTS_STORAGE_GC_H */
{-# START_FILE include/ghc-8.0.2/rts/storage/InfoTables.h #-}
/* ----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2002
 *
 * Info Tables
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_STORAGE_INFOTABLES_H
#define RTS_STORAGE_INFOTABLES_H

/* ----------------------------------------------------------------------------
   Relative pointers

   Several pointer fields in info tables are expressed as offsets
   relative to the info pointer, so that we can generate
   position-independent code.

   Note [x86-64-relative]
   There is a complication on the x86_64 platform, where pointeres are
   64 bits, but the tools don't support 64-bit relative relocations.
   However, the default memory model (small) ensures that all symbols
   have values in the lower 2Gb of the address space, so offsets all
   fit in 32 bits.  Hence we can use 32-bit offset fields.

   Somewhere between binutils-2.16.1 and binutils-2.16.91.0.6,
   support for 64-bit PC-relative relocations was added, so maybe this
   hackery can go away sometime.
   ------------------------------------------------------------------------- */

#if x86_64_TARGET_ARCH
#define OFFSET_FIELD(n) StgHalfInt n; StgHalfWord __pad_##n
#else
#define OFFSET_FIELD(n) StgInt n
#endif

/* -----------------------------------------------------------------------------
   Profiling info
   -------------------------------------------------------------------------- */

typedef struct {
#ifndef TABLES_NEXT_TO_CODE
    char *closure_type;
    char *closure_desc;
#else
    OFFSET_FIELD(closure_type_off);
    OFFSET_FIELD(closure_desc_off);
#endif
} StgProfInfo;

/* -----------------------------------------------------------------------------
   Closure flags
   -------------------------------------------------------------------------- */

/* The type flags provide quick access to certain properties of a closure. */

#define _HNF (1<<0)  /* head normal form?    */
#define _BTM (1<<1)  /* uses info->layout.bitmap */
#define _NS  (1<<2)  /* non-sparkable        */
#define _STA (1<<3)  /* static?              */
#define _THU (1<<4)  /* thunk?               */
#define _MUT (1<<5)  /* mutable?             */
#define _UPT (1<<6)  /* unpointed?           */
#define _SRT (1<<7)  /* has an SRT?          */
#define _IND (1<<8)  /* is an indirection?   */

#define isSTATIC(flags)    ((flags) &_STA)
#define isMUTABLE(flags)   ((flags) &_MUT)
#define isBITMAP(flags)    ((flags) &_BTM)
#define isTHUNK(flags)     ((flags) &_THU)
#define isUNPOINTED(flags) ((flags) &_UPT)
#define hasSRT(flags)      ((flags) &_SRT)

extern StgWord16 closure_flags[];

#define closureFlags(c)         (closure_flags[get_itbl(UNTAG_CLOSURE(c))->type])

#define closure_HNF(c)          (  closureFlags(c) & _HNF)
#define closure_BITMAP(c)       (  closureFlags(c) & _BTM)
#define closure_NON_SPARK(c)    ( (closureFlags(c) & _NS))
#define closure_SHOULD_SPARK(c) (!(closureFlags(c) & _NS))
#define closure_STATIC(c)       (  closureFlags(c) & _STA)
#define closure_THUNK(c)        (  closureFlags(c) & _THU)
#define closure_MUTABLE(c)      (  closureFlags(c) & _MUT)
#define closure_UNPOINTED(c)    (  closureFlags(c) & _UPT)
#define closure_SRT(c)          (  closureFlags(c) & _SRT)
#define closure_IND(c)          (  closureFlags(c) & _IND)

/* same as above but for info-ptr rather than closure */
#define ipFlags(ip)             (closure_flags[ip->type])

#define ip_HNF(ip)               (  ipFlags(ip) & _HNF)
#define ip_BITMAP(ip)            (  ipFlags(ip) & _BTM)
#define ip_SHOULD_SPARK(ip)      (!(ipFlags(ip) & _NS))
#define ip_STATIC(ip)            (  ipFlags(ip) & _STA)
#define ip_THUNK(ip)             (  ipFlags(ip) & _THU)
#define ip_MUTABLE(ip)           (  ipFlags(ip) & _MUT)
#define ip_UNPOINTED(ip)         (  ipFlags(ip) & _UPT)
#define ip_SRT(ip)               (  ipFlags(ip) & _SRT)
#define ip_IND(ip)               (  ipFlags(ip) & _IND)

/* -----------------------------------------------------------------------------
   Bitmaps

   These are used to describe the pointerhood of a sequence of words
   (usually on the stack) to the garbage collector.  The two primary
   uses are for stack frames, and functions (where we need to describe
   the layout of a PAP to the GC).

   In these bitmaps: 0 == ptr, 1 == non-ptr.
   -------------------------------------------------------------------------- */

/*
 * Small bitmaps:  for a small bitmap, we store the size and bitmap in
 * the same word, using the following macros.  If the bitmap doesn't
 * fit in a single word, we use a pointer to an StgLargeBitmap below.
 */
#define MK_SMALL_BITMAP(size,bits) (((bits)<<BITMAP_BITS_SHIFT) | (size))

#define BITMAP_SIZE(bitmap) ((bitmap) & BITMAP_SIZE_MASK)
#define BITMAP_BITS(bitmap) ((bitmap) >> BITMAP_BITS_SHIFT)

/*
 * A large bitmap.
 */
typedef struct {
  StgWord size;
  StgWord bitmap[FLEXIBLE_ARRAY];
} StgLargeBitmap;

/* -----------------------------------------------------------------------------
   SRTs  (Static Reference Tables)

   These tables are used to keep track of the static objects referred
   to by the code for a closure or stack frame, so that we can follow
   static data references from code and thus accurately
   garbage-collect CAFs.
   -------------------------------------------------------------------------- */

/* An SRT is just an array of closure pointers: */
typedef StgClosure* StgSRT[];

/*
 * Each info table refers to some subset of the closure pointers in an
 * SRT.  It does this using a pair of an StgSRT pointer and a
 * half-word bitmap.  If the half-word bitmap isn't large enough, then
 * we fall back to a large SRT, including an unbounded bitmap.  If the
 * half-word bitmap is set to all ones (0xffff), then the StgSRT
 * pointer instead points to an StgLargeSRT:
 */
typedef struct StgLargeSRT_ {
    StgSRT *srt;
    StgLargeBitmap l;
} StgLargeSRT;

/* ----------------------------------------------------------------------------
   Info Tables
   ------------------------------------------------------------------------- */

/*
 * Stuff describing the closure layout.  Well, actually, it might
 * contain the selector index for a THUNK_SELECTOR.  This union is one
 * word long.
 */
typedef union {
    struct {                    /* Heap closure payload layout: */
        StgHalfWord ptrs;       /* number of pointers */
        StgHalfWord nptrs;      /* number of non-pointers */
    } payload;

    StgWord bitmap;               /* word-sized bit pattern describing */
                                  /*  a stack frame: see below */

#ifndef TABLES_NEXT_TO_CODE
    StgLargeBitmap* large_bitmap; /* pointer to large bitmap structure */
#else
    OFFSET_FIELD(large_bitmap_offset);  /* offset from info table to large bitmap structure */
#endif

    StgWord selector_offset;      /* used in THUNK_SELECTORs */

} StgClosureInfo;


/*
 * The "standard" part of an info table.  Every info table has this bit.
 */
typedef struct StgInfoTable_ {

#if !defined(TABLES_NEXT_TO_CODE)
    StgFunPtr       entry;      /* pointer to the entry code */
#endif

#ifdef PROFILING
    StgProfInfo     prof;
#endif

    StgClosureInfo  layout;     /* closure layout info (one word) */

    StgHalfWord     type;       /* closure type */
    StgHalfWord     srt_bitmap;
       /* In a CONSTR:
            - the constructor tag
          In a FUN/THUNK
            - a bitmap of SRT entries
       */

#ifdef TABLES_NEXT_TO_CODE
    StgCode         code[FLEXIBLE_ARRAY];
#endif
} *StgInfoTablePtr;


/* -----------------------------------------------------------------------------
   Function info tables

   This is the general form of function info tables.  The compiler
   will omit some of the fields in common cases:

   -  If fun_type is not ARG_GEN or ARG_GEN_BIG, then the slow_apply
      and bitmap fields may be left out (they are at the end, so omitting
      them doesn't affect the layout).

   -  If srt_bitmap (in the std info table part) is zero, then the srt
      field may be omitted.  This only applies if the slow_apply and
      bitmap fields have also been omitted.
   -------------------------------------------------------------------------- */

typedef struct StgFunInfoExtraRev_ {
    OFFSET_FIELD(slow_apply_offset); /* apply to args on the stack */
    union {
        StgWord bitmap;
        OFFSET_FIELD(bitmap_offset);    /* arg ptr/nonptr bitmap */
    } b;
    OFFSET_FIELD(srt_offset);   /* pointer to the SRT table */
    StgHalfWord    fun_type;    /* function type */
    StgHalfWord    arity;       /* function arity */
} StgFunInfoExtraRev;

typedef struct StgFunInfoExtraFwd_ {
    StgHalfWord    fun_type;    /* function type */
    StgHalfWord    arity;       /* function arity */
    StgSRT         *srt;        /* pointer to the SRT table */
    union { /* union for compat. with TABLES_NEXT_TO_CODE version */
        StgWord        bitmap;  /* arg ptr/nonptr bitmap */
    } b;
    StgFun         *slow_apply; /* apply to args on the stack */
} StgFunInfoExtraFwd;

typedef struct {
#if defined(TABLES_NEXT_TO_CODE)
    StgFunInfoExtraRev f;
    StgInfoTable i;
#else
    StgInfoTable i;
    StgFunInfoExtraFwd f;
#endif
} StgFunInfoTable;

// canned bitmap for each arg type, indexed by constants in FunTypes.h
extern StgWord stg_arg_bitmaps[];

/* -----------------------------------------------------------------------------
   Return info tables
   -------------------------------------------------------------------------- */

/*
 * When info tables are laid out backwards, we can omit the SRT
 * pointer iff srt_bitmap is zero.
 */

typedef struct {
#if defined(TABLES_NEXT_TO_CODE)
    OFFSET_FIELD(srt_offset);   /* offset to the SRT table */
    StgInfoTable i;
#else
    StgInfoTable i;
    StgSRT      *srt;   /* pointer to the SRT table */
#endif
} StgRetInfoTable;

/* -----------------------------------------------------------------------------
   Thunk info tables
   -------------------------------------------------------------------------- */

/*
 * When info tables are laid out backwards, we can omit the SRT
 * pointer iff srt_bitmap is zero.
 */

typedef struct StgThunkInfoTable_ {
#if !defined(TABLES_NEXT_TO_CODE)
    StgInfoTable i;
#endif
#if defined(TABLES_NEXT_TO_CODE)
    OFFSET_FIELD(srt_offset);   /* offset to the SRT table */
#else
    StgSRT         *srt;        /* pointer to the SRT table */
#endif
#if defined(TABLES_NEXT_TO_CODE)
    StgInfoTable i;
#endif
} StgThunkInfoTable;

/* -----------------------------------------------------------------------------
   Constructor info tables
   -------------------------------------------------------------------------- */

typedef struct StgConInfoTable_ {
#if !defined(TABLES_NEXT_TO_CODE)
    StgInfoTable i;
#endif

#if defined(TABLES_NEXT_TO_CODE)
    OFFSET_FIELD(con_desc); // the name of the data constructor
                            // as: Package:Module.Name
#else
    char *con_desc;
#endif

#if defined(TABLES_NEXT_TO_CODE)
    StgInfoTable i;
#endif
} StgConInfoTable;


/* -----------------------------------------------------------------------------
   Accessor macros for fields that might be offsets (C version)
   -------------------------------------------------------------------------- */

/*
 * GET_SRT(info)
 * info must be a Stg[Ret|Thunk]InfoTable* (an info table that has a SRT)
 */
#ifdef TABLES_NEXT_TO_CODE
#define GET_SRT(info) ((StgSRT*) (((StgWord) ((info)+1)) + (info)->srt_offset))
#else
#define GET_SRT(info) ((info)->srt)
#endif

/*
 * GET_CON_DESC(info)
 * info must be a StgConInfoTable*.
 */
#ifdef TABLES_NEXT_TO_CODE
#define GET_CON_DESC(info) ((char *)((StgWord)((info)+1) + (info->con_desc)))
#else
#define GET_CON_DESC(info) ((info)->con_desc)
#endif

/*
 * GET_FUN_SRT(info)
 * info must be a StgFunInfoTable*
 */
#ifdef TABLES_NEXT_TO_CODE
#define GET_FUN_SRT(info) ((StgSRT*) (((StgWord) ((info)+1)) + (info)->f.srt_offset))
#else
#define GET_FUN_SRT(info) ((info)->f.srt)
#endif

#ifdef TABLES_NEXT_TO_CODE
#define GET_LARGE_BITMAP(info) ((StgLargeBitmap*) (((StgWord) ((info)+1)) \
                                        + (info)->layout.large_bitmap_offset))
#else
#define GET_LARGE_BITMAP(info) ((info)->layout.large_bitmap)
#endif

#ifdef TABLES_NEXT_TO_CODE
#define GET_FUN_LARGE_BITMAP(info) ((StgLargeBitmap*) (((StgWord) ((info)+1)) \
                                        + (info)->f.b.bitmap_offset))
#else
#define GET_FUN_LARGE_BITMAP(info) ((StgLargeBitmap*) ((info)->f.b.bitmap))
#endif

/*
 * GET_PROF_TYPE, GET_PROF_DESC
 */
#ifdef TABLES_NEXT_TO_CODE
#define GET_PROF_TYPE(info) ((char *)((StgWord)((info)+1) + (info->prof.closure_type_off)))
#else
#define GET_PROF_TYPE(info) ((info)->prof.closure_type)
#endif
#ifdef TABLES_NEXT_TO_CODE
#define GET_PROF_DESC(info) ((char *)((StgWord)((info)+1) + (info->prof.closure_desc_off)))
#else
#define GET_PROF_DESC(info) ((info)->prof.closure_desc)
#endif

#endif /* RTS_STORAGE_INFOTABLES_H */
{-# START_FILE include/ghc-8.0.2/rts/storage/MBlock.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2008
 *
 * MegaBlock Allocator interface.
 *
 * See wiki commentary at
 *  http://ghc.haskell.org/trac/ghc/wiki/Commentary/HeapAlloced
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_STORAGE_MBLOCK_H
#define RTS_STORAGE_MBLOCK_H

extern W_ peak_mblocks_allocated;
extern W_ mblocks_allocated;

extern void initMBlocks(void);
extern void * getMBlock(void);
extern void * getMBlocks(nat n);
extern void freeMBlocks(void *addr, nat n);
extern void releaseFreeMemory(void);
extern void freeAllMBlocks(void);

extern void *getFirstMBlock(void **state);
extern void *getNextMBlock(void **state, void *mblock);

#ifdef THREADED_RTS
// needed for HEAP_ALLOCED below
extern SpinLock gc_alloc_block_sync;
#endif

#endif /* RTS_STORAGE_MBLOCK_H */
{-# START_FILE include/ghc-8.0.2/rts/storage/SMPClosureOps.h #-}
/* ----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2005-2013
 *
 * Macros for THREADED_RTS support
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_STORAGE_SMPCLOSUREOPS_H
#define RTS_STORAGE_SMPCLOSUREOPS_H

#ifdef CMINUSMINUS

/* Lock closure, equivalent to ccall lockClosure but the condition is inlined.
 * Arguments are swapped for uniformity with unlockClosure. */
#if defined(THREADED_RTS)
#define LOCK_CLOSURE(closure, info)                             \
    if (CInt[n_capabilities] == 1 :: CInt) {                    \
        info = GET_INFO(closure);                               \
    } else {                                                    \
        ("ptr" info) = ccall reallyLockClosure(closure "ptr");  \
    }
#else
#define LOCK_CLOSURE(closure, info) info = GET_INFO(closure)
#endif

#define unlockClosure(ptr,info)                 \
    prim_write_barrier;                         \
    StgHeader_info(ptr) = info;

#else

INLINE_HEADER StgInfoTable *lockClosure(StgClosure *p);
EXTERN_INLINE StgInfoTable *reallyLockClosure(StgClosure *p);
EXTERN_INLINE StgInfoTable *tryLockClosure(StgClosure *p);
EXTERN_INLINE void unlockClosure(StgClosure *p, const StgInfoTable *info);

#if defined(THREADED_RTS)

/* -----------------------------------------------------------------------------
 * Locking/unlocking closures
 *
 * This is used primarily in the implementation of MVars.
 * -------------------------------------------------------------------------- */

// We want a callable copy of reallyLockClosure() so that we can refer to it
// from .cmm files compiled using the native codegen, so these are given
// EXTERN_INLINE.  C-- should use LOCK_CLOSURE not lockClosure, so we've
// kept it INLINE_HEADER.
EXTERN_INLINE StgInfoTable *reallyLockClosure(StgClosure *p)
{
    StgWord info;
    do {
        nat i = 0;
        do {
            info = xchg((P_)(void *)&p->header.info, (W_)&stg_WHITEHOLE_info);
            if (info != (W_)&stg_WHITEHOLE_info) return (StgInfoTable *)info;
        } while (++i < SPIN_COUNT);
        yieldThread();
    } while (1);
}

INLINE_HEADER StgInfoTable *lockClosure(StgClosure *p)
{
    if (n_capabilities == 1) {
        return (StgInfoTable *)p->header.info;
    }
    else {
        return reallyLockClosure(p);
    }
}

// ToDo: consider splitting tryLockClosure into reallyTryLockClosure,
// same as lockClosure
EXTERN_INLINE StgInfoTable *tryLockClosure(StgClosure *p)
{
    StgWord info;
    if (n_capabilities == 1) {
        return (StgInfoTable *)p->header.info;
    }
    else {
        info = xchg((P_)(void *)&p->header.info, (W_)&stg_WHITEHOLE_info);
        if (info != (W_)&stg_WHITEHOLE_info) {
            return (StgInfoTable *)info;
        } else {
            return NULL;
        }
    }
}

#else /* !THREADED_RTS */

EXTERN_INLINE StgInfoTable *
reallyLockClosure(StgClosure *p)
{ return (StgInfoTable *)p->header.info; }

INLINE_HEADER StgInfoTable *
lockClosure(StgClosure *p)
{ return (StgInfoTable *)p->header.info; }

EXTERN_INLINE StgInfoTable *
tryLockClosure(StgClosure *p)
{ return (StgInfoTable *)p->header.info; }

#endif /* THREADED_RTS */

EXTERN_INLINE void unlockClosure(StgClosure *p, const StgInfoTable *info)
{
    // This is a strictly ordered write, so we need a write_barrier():
    write_barrier();
    p->header.info = info;
}

// Handy specialised versions of lockClosure()/unlockClosure()
INLINE_HEADER void lockTSO(StgTSO *tso);
INLINE_HEADER void lockTSO(StgTSO *tso)
{ lockClosure((StgClosure *)tso); }

INLINE_HEADER void unlockTSO(StgTSO *tso);
INLINE_HEADER void unlockTSO(StgTSO *tso)
{ unlockClosure((StgClosure*)tso, (const StgInfoTable *)&stg_TSO_info); }

#endif /* CMINUSMINUS */

#endif /* RTS_STORAGE_SMPCLOSUREOPS_H */
{-# START_FILE include/ghc-8.0.2/rts/storage/TSO.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * The definitions for Thread State Objects.
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_STORAGE_TSO_H
#define RTS_STORAGE_TSO_H

/*
 * PROFILING info in a TSO
 */
typedef struct {
  CostCentreStack *cccs;       /* thread's current CCS */
} StgTSOProfInfo;

/*
 * There is no TICKY info in a TSO at this time.
 */

/*
 * Thread IDs are 32 bits.
 */
typedef StgWord32 StgThreadID;

#define tsoLocked(tso) ((tso)->flags & TSO_LOCKED)

/*
 * Type returned after running a thread.  Values of this type
 * include HeapOverflow, StackOverflow etc.  See Constants.h for the
 * full list.
 */
typedef unsigned int StgThreadReturnCode;

#if defined(mingw32_HOST_OS)
/* results from an async I/O request + its request ID. */
typedef struct {
  unsigned int reqID;
  int          len;
  int          errCode;
} StgAsyncIOResult;
#endif

/* Reason for thread being blocked. See comment above struct StgTso_. */
typedef union {
  StgClosure *closure;
  StgTSO *prev; // a back-link when the TSO is on the run queue (NotBlocked)
  struct MessageBlackHole_ *bh;
  struct MessageThrowTo_ *throwto;
  struct MessageWakeup_  *wakeup;
  StgInt fd;    /* StgInt instead of int, so that it's the same size as the ptrs */
#if defined(mingw32_HOST_OS)
  StgAsyncIOResult *async_result;
#endif
#if !defined(THREADED_RTS)
  StgWord target;
    // Only for the non-threaded RTS: the target time for a thread
    // blocked in threadDelay, in units of 1ms.  This is a
    // compromise: we don't want to take up much space in the TSO.  If
    // you want better resolution for threadDelay, use -threaded.
#endif
} StgTSOBlockInfo;


/*
 * TSOs live on the heap, and therefore look just like heap objects.
 * Large TSOs will live in their own "block group" allocated by the
 * storage manager, and won't be copied during garbage collection.
 */

/*
 * Threads may be blocked for several reasons.  A blocked thread will
 * have the reason in the why_blocked field of the TSO, and some
 * further info (such as the closure the thread is blocked on, or the
 * file descriptor if the thread is waiting on I/O) in the block_info
 * field.
 */

typedef struct StgTSO_ {
    StgHeader               header;

    /* The link field, for linking threads together in lists (e.g. the
       run queue on a Capability.
    */
    struct StgTSO_*         _link;
    /*
      Currently used for linking TSOs on:
      * cap->run_queue_{hd,tl}
      * (non-THREADED_RTS); the blocked_queue
      * and pointing to the next chunk for a ThreadOldStack

       NOTE!!!  do not modify _link directly, it is subject to
       a write barrier for generational GC.  Instead use the
       setTSOLink() function.  Exceptions to this rule are:

       * setting the link field to END_TSO_QUEUE
       * setting the link field of the currently running TSO, as it
         will already be dirty.
    */

    struct StgTSO_*         global_link;    // Links threads on the
                                            // generation->threads lists

    /*
     * The thread's stack
     */
    struct StgStack_       *stackobj;

    /*
     * The tso->dirty flag indicates that this TSO's stack should be
     * scanned during garbage collection.  It also indicates that this
     * TSO is on the mutable list.
     *
     * NB. The dirty flag gets a word to itself, so that it can be set
     * safely by multiple threads simultaneously (the flags field is
     * not safe for this purpose; see #3429).  It is harmless for the
     * TSO to be on the mutable list multiple times.
     *
     * tso->dirty is set by dirty_TSO(), and unset by the garbage
     * collector (only).
     */

    StgWord16               what_next;      // Values defined in Constants.h
    StgWord16               why_blocked;    // Values defined in Constants.h
    StgWord32               flags;          // Values defined in Constants.h
    StgTSOBlockInfo         block_info;
    StgThreadID             id;
    StgWord32               saved_errno;
    StgWord32               dirty;          /* non-zero => dirty */
    struct InCall_*         bound;
    struct Capability_*     cap;

    struct StgTRecHeader_ * trec;       /* STM transaction record */

    /*
     * A list of threads blocked on this TSO waiting to throw exceptions.
    */
    struct MessageThrowTo_ * blocked_exceptions;

    /*
     * A list of StgBlockingQueue objects, representing threads
     * blocked on thunks that are under evaluation by this thread.
    */
    struct StgBlockingQueue_ *bq;

    /*
     * The allocation limit for this thread, which is updated as the
     * thread allocates.  If the value drops below zero, and
     * TSO_ALLOC_LIMIT is set in flags, we raise an exception in the
     * thread, and give the thread a little more space to handle the
     * exception before we raise the exception again.
     *
     * This is an integer, because we might update it in a place where
     * it isn't convenient to raise the exception, so we want it to
     * stay negative until we get around to checking it.
     *
     * Use only PK_Int64/ASSIGN_Int64 macros to get/set the value of alloc_limit
     * in C code otherwise you will cause alignment issues on SPARC
     */
    StgInt64  alloc_limit;     /* in bytes */

    /*
     * sum of the sizes of all stack chunks (in words), used to decide
     * whether to throw the StackOverflow exception when the stack
     * overflows, or whether to just chain on another stack chunk.
     *
     * Note that this overestimates the real stack size, because each
     * chunk will have a gap at the end, of +RTS -kb<size> words.
     * This means stack overflows are not entirely accurate, because
     * the more gaps there are, the sooner the stack will run into the
     * hard +RTS -K<size> limit.
     */
    StgWord32  tot_stack_size;

#ifdef TICKY_TICKY
    /* TICKY-specific stuff would go here. */
#endif
#ifdef PROFILING
    StgTSOProfInfo prof;
#endif
#ifdef mingw32_HOST_OS
    StgWord32 saved_winerror;
#endif

} *StgTSOPtr;

typedef struct StgStack_ {
    StgHeader  header;
    StgWord32  stack_size;     // stack size in *words*
    StgWord32  dirty;          // non-zero => dirty
    StgPtr     sp;             // current stack pointer
    StgWord    stack[FLEXIBLE_ARRAY];
} StgStack;

// Calculate SpLim from a TSO (reads tso->stackobj, but no fields from
// the stackobj itself).
INLINE_HEADER StgPtr tso_SpLim (StgTSO* tso)
{
    return tso->stackobj->stack + RESERVED_STACK_WORDS;
}

/* -----------------------------------------------------------------------------
   functions
   -------------------------------------------------------------------------- */

void dirty_TSO  (Capability *cap, StgTSO *tso);
void setTSOLink (Capability *cap, StgTSO *tso, StgTSO *target);
void setTSOPrev (Capability *cap, StgTSO *tso, StgTSO *target);

void dirty_STACK (Capability *cap, StgStack *stack);

/* -----------------------------------------------------------------------------
   Invariants:

   An active thread has the following properties:

      tso->stack < tso->sp < tso->stack+tso->stack_size
      tso->stack_size <= tso->max_stack_size

      RESERVED_STACK_WORDS is large enough for any heap-check or
      stack-check failure.

      The size of the TSO struct plus the stack is either
        (a) smaller than a block, or
        (b) a multiple of BLOCK_SIZE

        tso->why_blocked       tso->block_info      location
        ----------------------------------------------------------------------
        NotBlocked             END_TSO_QUEUE        runnable_queue, or running

        BlockedOnBlackHole     MessageBlackHole *   TSO->bq

        BlockedOnMVar          the MVAR             the MVAR's queue

        BlockedOnSTM           END_TSO_QUEUE        STM wait queue(s)
        BlockedOnSTM           STM_AWOKEN           run queue

        BlockedOnMsgThrowTo    MessageThrowTo *     TSO->blocked_exception

        BlockedOnRead          NULL                 blocked_queue
        BlockedOnWrite         NULL                 blocked_queue
        BlockedOnDelay         NULL                 blocked_queue
        BlockedOnGA            closure TSO blocks on   BQ of that closure
        BlockedOnGA_NoSend     closure TSO blocks on   BQ of that closure

      tso->link == END_TSO_QUEUE, if the thread is currently running.

   A zombie thread has the following properties:

      tso->what_next == ThreadComplete or ThreadKilled
      tso->link     ==  (could be on some queue somewhere)
      tso->sp       ==  tso->stack + tso->stack_size - 1 (i.e. top stack word)
      tso->sp[0]    ==  return value of thread, if what_next == ThreadComplete,
                        exception             , if what_next == ThreadKilled

      (tso->sp is left pointing at the top word on the stack so that
      the return value or exception will be retained by a GC).

   The 2 cases BlockedOnGA and BlockedOnGA_NoSend are needed in a GUM
   setup only. They mark a TSO that has entered a FETCH_ME or
   FETCH_ME_BQ closure, respectively; only the first TSO hitting the
   closure will send a Fetch message.
   Currently we have no separate code for blocking on an RBH; we use the
   BlockedOnBlackHole case for that.   -- HWL

 ---------------------------------------------------------------------------- */

/* this is the NIL ptr for a TSO queue (e.g. runnable queue) */
#define END_TSO_QUEUE  ((StgTSO *)(void*)&stg_END_TSO_QUEUE_closure)

#endif /* RTS_STORAGE_TSO_H */
{-# START_FILE include/ghc-8.0.2/rts/Threads.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team 1998-2009
 *
 * External API for the scheduler.  For most uses, the functions in
 * RtsAPI.h should be enough.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_THREADS_H
#define RTS_THREADS_H

#ifdef HAVE_SYS_TYPES_H
#include <sys/types.h>
#endif

//
// Creating threads
//
StgTSO *createThread (Capability *cap, W_ stack_size);

void scheduleWaitThread (/* in    */ StgTSO *tso,
                         /* out   */ HaskellObj* ret,
                         /* inout */ Capability **cap);

StgTSO *createGenThread       (Capability *cap, W_ stack_size,
                               StgClosure *closure);
StgTSO *createIOThread        (Capability *cap, W_ stack_size,
                               StgClosure *closure);
StgTSO *createStrictIOThread  (Capability *cap, W_ stack_size,
                               StgClosure *closure);

// Suspending/resuming threads around foreign calls
void *        suspendThread (StgRegTable *, rtsBool interruptible);
StgRegTable * resumeThread  (void *);

//
// Thread operations from Threads.c
//
int     cmp_thread                       (StgPtr tso1, StgPtr tso2);
int     rts_getThreadId                  (StgPtr tso);
HsInt64 rts_getThreadAllocationCounter   (StgPtr tso);
void    rts_setThreadAllocationCounter   (StgPtr tso, HsInt64 i);
void    rts_enableThreadAllocationLimit  (StgPtr tso);
void    rts_disableThreadAllocationLimit (StgPtr tso);

#if !defined(mingw32_HOST_OS)
pid_t  forkProcess     (HsStablePtr *entry);
#else
pid_t  forkProcess     (HsStablePtr *entry)
    GNU_ATTRIBUTE(__noreturn__);
#endif

HsBool rtsSupportsBoundThreads (void);

// The number of Capabilities
extern unsigned int n_capabilities;

// The number of Capabilities that are not disabled
extern nat enabled_capabilities;

#if !IN_STG_CODE
extern Capability MainCapability;
#endif

//
// Change the number of capabilities (only supports increasing the
// current value at the moment).
//
extern void setNumCapabilities (nat new_);

#endif /* RTS_THREADS_H */
{-# START_FILE include/ghc-8.0.2/rts/Ticky.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * TICKY_TICKY types
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_TICKY_H
#define RTS_TICKY_H

/* -----------------------------------------------------------------------------
   The StgEntCounter type - needed regardless of TICKY_TICKY
   -------------------------------------------------------------------------- */

typedef struct _StgEntCounter {
  /* Using StgWord for everything, because both the C and asm code
     generators make trouble if you try to pack things tighter */
    StgWord     registeredp;    /* 0 == no, 1 == yes */
    StgInt      arity;          /* arity (static info) */
    StgInt      allocd;         /* # allocation of this closure */
                                /* (rest of args are in registers) */
    char        *str;           /* name of the thing */
    char        *arg_kinds;     /* info about the args types */
    StgInt      entry_count;    /* Trips to fast entry code */
    StgInt      allocs;         /* number of allocations by this fun */
    struct _StgEntCounter *link;/* link to chain them all together */
} StgEntCounter;

#endif /* RTS_TICKY_H */
{-# START_FILE include/ghc-8.0.2/rts/Timer.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1995-2009
 *
 * Interface to the RTS timer signal (uses OS-dependent Ticker.h underneath)
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_TIMER_H
#define RTS_TIMER_H

void startTimer (void);
void stopTimer  (void);
int rtsTimerSignal (void);

#endif /* RTS_TIMER_H */
{-# START_FILE include/ghc-8.0.2/rts/TTY.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2009
 *
 * POSIX TTY-related functionality
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * -------------------------------------------------------------------------- */

#ifndef RTS_TTY_H
#define RTS_TTY_H

void* __hscore_get_saved_termios(int fd);
void  __hscore_set_saved_termios(int fd, void* ts);

#endif /* RTS_TTY_H */
{-# START_FILE include/ghc-8.0.2/rts/Types.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * RTS-specific types.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_TYPES_H
#define RTS_TYPES_H

#include <stddef.h>

typedef unsigned int     nat;           /* at least 32 bits (like int) */

// Deprecated; just use StgWord instead
typedef StgWord lnat;

/* ullong (64|128-bit) type: only include if needed (not ANSI) */
#if defined(__GNUC__) 
#define LL(x) (x##LL)
#else
#define LL(x) (x##L)
#endif
  
typedef enum { 
    rtsFalse = 0, 
    rtsTrue 
} rtsBool;

typedef struct StgClosure_   StgClosure;
typedef struct StgInfoTable_ StgInfoTable;
typedef struct StgTSO_       StgTSO;

#endif /* RTS_TYPES_H */
{-# START_FILE include/ghc-8.0.2/rts/Utils.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * RTS external APIs.  This file declares everything that the GHC RTS
 * exposes externally.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_UTILS_H
#define RTS_UTILS_H

/* Alternate to raise(3) for threaded rts, for BSD-based OSes */
int genericRaise(int sig);

#endif /* RTS_UTILS_H */
{-# START_FILE include/ghc-8.0.2/Rts.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * RTS external APIs.  This file declares everything that the GHC RTS
 * exposes externally.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTS_H
#define RTS_H

#ifdef __cplusplus
extern "C" {
#endif

/* We include windows.h very early, as on Win64 the CONTEXT type has
   fields "R8", "R9" and "R10", which goes bad if we've already
   #define'd those names for our own purposes (in stg/Regs.h) */
#if defined(HAVE_WINDOWS_H)
#include <windows.h>
#endif

#ifndef IN_STG_CODE
#define IN_STG_CODE 0
#endif
#include "Stg.h"

#include "HsFFI.h"
#include "RtsAPI.h"

// Turn off inlining when debugging - it obfuscates things
#ifdef DEBUG
# undef  STATIC_INLINE
# define STATIC_INLINE static
#endif

#include "rts/Types.h"

#if __GNUC__ >= 3
/* Assume that a flexible array member at the end of a struct
 * can be defined thus: T arr[]; */
#define FLEXIBLE_ARRAY
#else
/* Assume that it must be defined thus: T arr[0]; */
#define FLEXIBLE_ARRAY 0
#endif

#if __GNUC__ >= 3
#define ATTRIBUTE_ALIGNED(n) __attribute__((aligned(n)))
#else
#define ATTRIBUTE_ALIGNED(n) /*nothing*/
#endif

// Symbols that are extern, but private to the RTS, are declared
// with visibility "hidden" to hide them outside the RTS shared
// library.
#if defined(HAS_VISIBILITY_HIDDEN)
#define RTS_PRIVATE  GNUC3_ATTRIBUTE(visibility("hidden"))
#else
#define RTS_PRIVATE  /* disabled: RTS_PRIVATE */
#endif

#if __GNUC__ >= 4
#define RTS_UNLIKELY(p) __builtin_expect((p),0)
#else
#define RTS_UNLIKELY(p) p
#endif

/* Fix for mingw stat problem (done here so it's early enough) */
#ifdef mingw32_HOST_OS
#define __MSVCRT__ 1
#endif

/* Needed to get the macro version of errno on some OSs, and also to
   get prototypes for the _r versions of C library functions. */
#ifndef _REENTRANT
#define _REENTRANT 1
#endif

/*
 * We often want to know the size of something in units of an
 * StgWord... (rounded up, of course!)
 */
#define ROUNDUP_BYTES_TO_WDS(n) (((n) + sizeof(W_) - 1) / sizeof(W_))

#define sizeofW(t) ROUNDUP_BYTES_TO_WDS(sizeof(t))

/* -----------------------------------------------------------------------------
   Assertions and Debuggery

   CHECK(p)   evaluates p and terminates with an error if p is false
   ASSERT(p)  like CHECK(p) if DEBUG is on, otherwise a no-op
   -------------------------------------------------------------------------- */

void _assertFail(const char *filename, unsigned int linenum)
   GNUC3_ATTRIBUTE(__noreturn__);

#define CHECK(predicate)                        \
        if (predicate)                          \
            /*null*/;                           \
        else                                    \
            _assertFail(__FILE__, __LINE__)

#define CHECKM(predicate, msg, ...)             \
        if (predicate)                          \
            /*null*/;                           \
        else                                    \
            barf(msg, ##__VA_ARGS__)

#ifndef DEBUG
#define ASSERT(predicate) /* nothing */
#define ASSERTM(predicate,msg,...) /* nothing */
#else
#define ASSERT(predicate) CHECK(predicate)
#define ASSERTM(predicate,msg,...) CHECKM(predicate,msg,##__VA_ARGS__)
#endif /* DEBUG */

/*
 * Use this on the RHS of macros which expand to nothing
 * to make sure that the macro can be used in a context which
 * demands a non-empty statement.
 */

#define doNothing() do { } while (0)

#ifdef DEBUG
#define USED_IF_DEBUG
#define USED_IF_NOT_DEBUG STG_UNUSED
#else
#define USED_IF_DEBUG STG_UNUSED
#define USED_IF_NOT_DEBUG
#endif

#ifdef THREADED_RTS
#define USED_IF_THREADS
#define USED_IF_NOT_THREADS STG_UNUSED
#else
#define USED_IF_THREADS STG_UNUSED
#define USED_IF_NOT_THREADS
#endif

#define FMT_SizeT    "zu"
#define FMT_HexSizeT "zx"

/* -----------------------------------------------------------------------------
   Time values in the RTS
   -------------------------------------------------------------------------- */

// For most time values in the RTS we use a fixed resolution of nanoseconds,
// normalising the time we get from platform-dependent APIs to this
// resolution.
#define TIME_RESOLUTION 1000000000
typedef StgInt64 Time;

#define TIME_MAX HS_INT64_MAX

#if TIME_RESOLUTION == 1000000000
// I'm being lazy, but it's awkward to define fully general versions of these
#define TimeToUS(t)      ((t) / 1000)
#define TimeToNS(t)      (t)
#define USToTime(t)      ((Time)(t) * 1000)
#define NSToTime(t)      ((Time)(t))
#else
#error Fix TimeToNS(), TimeToUS() etc.
#endif

#define SecondsToTime(t) ((Time)(t) * TIME_RESOLUTION)
#define TimeToSeconds(t) ((t) / TIME_RESOLUTION)

// Use instead of SecondsToTime() when we have a floating-point
// seconds value, to avoid truncating it.
INLINE_HEADER Time fsecondsToTime (double t)
{
    return (Time)(t * TIME_RESOLUTION);
}

/* -----------------------------------------------------------------------------
   Include everything STG-ish
   -------------------------------------------------------------------------- */

/* System headers: stdlib.h is needed so that we can use NULL.  It must
 * come after MachRegs.h, because stdlib.h might define some inline
 * functions which may only be defined after register variables have
 * been declared.
 */
#include <stdlib.h>

#include "rts/Config.h"

/* Global constraints */
#include "rts/Constants.h"

/* Profiling information */
#include "rts/prof/CCS.h"
#include "rts/prof/LDV.h"

/* Parallel information */
#include "rts/OSThreads.h"
#include "rts/SpinLock.h"

#include "rts/Messages.h"
#include "rts/Threads.h"

/* Storage format definitions */
#include "rts/storage/FunTypes.h"
#include "rts/storage/InfoTables.h"
#include "rts/storage/Closures.h"
#include "rts/storage/ClosureTypes.h"
#include "rts/storage/TSO.h"
#include "stg/MiscClosures.h" /* InfoTables, closures etc. defined in the RTS */
#include "rts/storage/SMPClosureOps.h"
#include "rts/storage/Block.h"
#include "rts/storage/ClosureMacros.h"
#include "rts/storage/MBlock.h"
#include "rts/storage/GC.h"

/* Other RTS external APIs */
#include "rts/Parallel.h"
#include "rts/Signals.h"
#include "rts/BlockSignals.h"
#include "rts/Hpc.h"
#include "rts/Flags.h"
#include "rts/Adjustor.h"
#include "rts/FileLock.h"
#include "rts/GetTime.h"
#include "rts/Globals.h"
#include "rts/IOManager.h"
#include "rts/Linker.h"
#include "rts/Ticky.h"
#include "rts/Timer.h"
#include "rts/Stable.h"
#include "rts/TTY.h"
#include "rts/Utils.h"
#include "rts/PrimFloat.h"
#include "rts/Main.h"
#include "rts/StaticPtrTable.h"
#include "rts/Libdw.h"
#include "rts/LibdwPool.h"

/* Misc stuff without a home */
DLL_IMPORT_RTS extern char **prog_argv; /* so we can get at these from Haskell */
DLL_IMPORT_RTS extern int    prog_argc;
DLL_IMPORT_RTS extern char  *prog_name;

#ifdef mingw32_HOST_OS
// We need these two from Haskell too
void getWin32ProgArgv(int *argc, wchar_t **argv[]);
void setWin32ProgArgv(int argc, wchar_t *argv[]);
#endif

void stackOverflow(StgTSO* tso);

void stg_exit(int n) GNU_ATTRIBUTE(__noreturn__);

#ifndef mingw32_HOST_OS
int stg_sig_install (int, int, void *);
#endif

/* -----------------------------------------------------------------------------
   Ways
   -------------------------------------------------------------------------- */

// Returns non-zero if the RTS is a profiling version
int rts_isProfiled(void);

// Returns non-zero if the RTS is a dynamically-linked version
int rts_isDynamic(void);

/* -----------------------------------------------------------------------------
   RTS Exit codes
   -------------------------------------------------------------------------- */

/* 255 is allegedly used by dynamic linkers to report linking failure */
#define EXIT_INTERNAL_ERROR 254
#define EXIT_DEADLOCK       253
#define EXIT_INTERRUPTED    252
#define EXIT_HEAPOVERFLOW   251
#define EXIT_KILLED         250

/* -----------------------------------------------------------------------------
   Miscellaneous garbage
   -------------------------------------------------------------------------- */

#ifdef DEBUG
#define TICK_VAR(arity) \
  extern StgInt SLOW_CALLS_##arity; \
  extern StgInt RIGHT_ARITY_##arity; \
  extern StgInt TAGGED_PTR_##arity;

extern StgInt TOTAL_CALLS;

TICK_VAR(1)
TICK_VAR(2)
#endif

/* -----------------------------------------------------------------------------
   Assertions and Debuggery
   -------------------------------------------------------------------------- */

#define IF_RTSFLAGS(c,s)  if (RtsFlags.c) { s; }

#ifdef DEBUG
#if IN_STG_CODE
#define IF_DEBUG(c,s)  if (RtsFlags[0].DebugFlags.c) { s; }
#else
#define IF_DEBUG(c,s)  if (RtsFlags.DebugFlags.c) { s; }
#endif
#else
#define IF_DEBUG(c,s)  doNothing()
#endif

#ifdef DEBUG
#define DEBUG_ONLY(s) s
#else
#define DEBUG_ONLY(s) doNothing()
#endif

#ifdef DEBUG
#define DEBUG_IS_ON   1
#else
#define DEBUG_IS_ON   0
#endif

/* -----------------------------------------------------------------------------
   Useful macros and inline functions
   -------------------------------------------------------------------------- */

#if defined(__GNUC__)
#define SUPPORTS_TYPEOF
#endif

#if defined(SUPPORTS_TYPEOF)
#define stg_min(a,b) ({typeof(a) _a = (a), _b = (b); _a <= _b ? _a : _b; })
#define stg_max(a,b) ({typeof(a) _a = (a), _b = (b); _a <= _b ? _b : _a; })
#else
#define stg_min(a,b) ((a) <= (b) ? (a) : (b))
#define stg_max(a,b) ((a) <= (b) ? (b) : (a))
#endif

/* -------------------------------------------------------------------------- */

#ifdef __cplusplus
}
#endif

#endif /* RTS_H */
{-# START_FILE include/ghc-8.0.2/RtsAPI.h #-}
/* ----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2004
 *
 * API for invoking Haskell functions via the RTS
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * --------------------------------------------------------------------------*/

#ifndef RTSAPI_H
#define RTSAPI_H

#ifdef __cplusplus
extern "C" {
#endif

#include "HsFFI.h"

/*
 * Running the scheduler
 */
typedef enum {
    NoStatus,    /* not finished yet */
    Success,     /* completed successfully */
    Killed,      /* uncaught exception */
    Interrupted, /* stopped in response to a call to interruptStgRts */
    HeapExhausted /* out of memory */
} SchedulerStatus;

typedef struct StgClosure_ *HaskellObj;

/*
 * An abstract type representing the token returned by rts_lock() and
 * used when allocating objects and threads in the RTS.
 */
typedef struct Capability_ Capability;

/*
 * The public view of a Capability: we can be sure it starts with
 * these two components (but it may have more private fields).
 */
typedef struct CapabilityPublic_ {
    StgFunTable f;
    StgRegTable r;
} CapabilityPublic;

/* ----------------------------------------------------------------------------
   RTS configuration settings, for passing to hs_init_ghc()
   ------------------------------------------------------------------------- */

typedef enum {
    RtsOptsNone,         // +RTS causes an error
    RtsOptsSafeOnly,     // safe RTS options allowed; others cause an error
    RtsOptsAll           // all RTS options allowed
  } RtsOptsEnabledEnum;

// The RtsConfig struct is passed (by value) to hs_init_ghc().  The
// reason for using a struct is extensibility: we can add more
// fields to this later without breaking existing client code.
typedef struct {

    // Whether to interpret +RTS options on the command line
    RtsOptsEnabledEnum rts_opts_enabled;

    // Whether to give RTS flag suggestions
    HsBool rts_opts_suggestions;

    // additional RTS options
    const char *rts_opts;

    // True if GHC was not passed -no-hs-main
    HsBool rts_hs_main;

    // Whether to retain CAFs (default: false)
    HsBool keep_cafs;

    // Called before processing command-line flags, so that default
    // settings for RtsFlags can be provided.
    void (* defaultsHook) (void);

    // Called just before exiting
    void (* onExitHook) (void);

    // Called on a stack overflow, before exiting
    void (* stackOverflowHook) (W_ stack_size);

    // Called on heap overflow, before exiting
    void (* outOfHeapHook) (W_ request_size, W_ heap_size);

    // Called when malloc() fails, before exiting
    void (* mallocFailHook) (W_ request_size /* in bytes */, char *msg);

    // Called for every GC
    void (* gcDoneHook) (unsigned int gen,
                         W_ allocated_bytes, /* since last GC */
                         W_ live_bytes,
                         W_ copied_bytes,
                         W_ max_copied_per_thread_bytes,
                         W_ total_bytes,
                         W_ slop_bytes,
                         W_ sync_elapsed_ns, W_ elapsed_ns, W_ cpu_ns);

} RtsConfig;

// Clients should start with defaultRtsConfig and then customise it.
// Bah, I really wanted this to be a const struct value, but it seems
// you can't do that in C (it generates code).
extern const RtsConfig defaultRtsConfig;

/* ----------------------------------------------------------------------------
   Starting up and shutting down the Haskell RTS.
   ------------------------------------------------------------------------- */

/* DEPRECATED, use hs_init() or hs_init_ghc() instead  */
extern void startupHaskell         ( int argc, char *argv[],
                                     void (*init_root)(void) );

/* DEPRECATED, use hs_exit() instead  */
extern void shutdownHaskell        ( void );

/* Like hs_init(), but allows rtsopts. For more complicated usage,
 * use hs_init_ghc. */
extern void hs_init_with_rtsopts (int *argc, char **argv[]);

/*
 * GHC-specific version of hs_init() that allows specifying whether
 * +RTS ... -RTS options are allowed or not (default: only "safe"
 * options are allowed), and allows passing an option string that is
 * to be interpreted by the RTS only, not passed to the program.
 */
extern void hs_init_ghc (int *argc, char **argv[],   // program arguments
                         RtsConfig rts_config);      // RTS configuration

extern void shutdownHaskellAndExit (int exitCode, int fastExit)
    GNUC3_ATTRIBUTE(__noreturn__);

#ifndef mingw32_HOST_OS
extern void shutdownHaskellAndSignal (int sig, int fastExit)
     GNUC3_ATTRIBUTE(__noreturn__);
#endif

extern void getProgArgv            ( int *argc, char **argv[] );
extern void setProgArgv            ( int argc, char *argv[] );
extern void getFullProgArgv        ( int *argc, char **argv[] );
extern void setFullProgArgv        ( int argc, char *argv[] );
extern void freeFullProgArgv       ( void ) ;

/* exit() override */
extern void (*exitFn)(int);

/* ----------------------------------------------------------------------------
   Locking.

   You have to surround all access to the RtsAPI with these calls.
   ------------------------------------------------------------------------- */

// acquires a token which may be used to create new objects and
// evaluate them.
Capability *rts_lock (void);

// releases the token acquired with rts_lock().
void rts_unlock (Capability *token);

// If you are in a context where you know you have a current capability but
// do not know what it is, then use this to get it. Basically this only
// applies to "unsafe" foreign calls (as unsafe foreign calls are made with
// the capability held).
//
// WARNING: There is *no* guarantee this returns anything sensible (eg NULL)
// when there is no current capability.
Capability *rts_unsafeGetMyCapability (void);

/* ----------------------------------------------------------------------------
   Building Haskell objects from C datatypes.
   ------------------------------------------------------------------------- */
HaskellObj   rts_mkChar       ( Capability *, HsChar   c );
HaskellObj   rts_mkInt        ( Capability *, HsInt    i );
HaskellObj   rts_mkInt8       ( Capability *, HsInt8   i );
HaskellObj   rts_mkInt16      ( Capability *, HsInt16  i );
HaskellObj   rts_mkInt32      ( Capability *, HsInt32  i );
HaskellObj   rts_mkInt64      ( Capability *, HsInt64  i );
HaskellObj   rts_mkWord       ( Capability *, HsWord   w );
HaskellObj   rts_mkWord8      ( Capability *, HsWord8  w );
HaskellObj   rts_mkWord16     ( Capability *, HsWord16 w );
HaskellObj   rts_mkWord32     ( Capability *, HsWord32 w );
HaskellObj   rts_mkWord64     ( Capability *, HsWord64 w );
HaskellObj   rts_mkPtr        ( Capability *, HsPtr    a );
HaskellObj   rts_mkFunPtr     ( Capability *, HsFunPtr a );
HaskellObj   rts_mkFloat      ( Capability *, HsFloat  f );
HaskellObj   rts_mkDouble     ( Capability *, HsDouble f );
HaskellObj   rts_mkStablePtr  ( Capability *, HsStablePtr s );
HaskellObj   rts_mkBool       ( Capability *, HsBool   b );
HaskellObj   rts_mkString     ( Capability *, char    *s );

HaskellObj   rts_apply        ( Capability *, HaskellObj, HaskellObj );

/* ----------------------------------------------------------------------------
   Deconstructing Haskell objects
   ------------------------------------------------------------------------- */
HsChar       rts_getChar      ( HaskellObj );
HsInt        rts_getInt       ( HaskellObj );
HsInt8       rts_getInt8      ( HaskellObj );
HsInt16      rts_getInt16     ( HaskellObj );
HsInt32      rts_getInt32     ( HaskellObj );
HsInt64      rts_getInt64     ( HaskellObj );
HsWord       rts_getWord      ( HaskellObj );
HsWord8      rts_getWord8     ( HaskellObj );
HsWord16     rts_getWord16    ( HaskellObj );
HsWord32     rts_getWord32    ( HaskellObj );
HsWord64     rts_getWord64    ( HaskellObj );
HsPtr        rts_getPtr       ( HaskellObj );
HsFunPtr     rts_getFunPtr    ( HaskellObj );
HsFloat      rts_getFloat     ( HaskellObj );
HsDouble     rts_getDouble    ( HaskellObj );
HsStablePtr  rts_getStablePtr ( HaskellObj );
HsBool       rts_getBool      ( HaskellObj );

/* ----------------------------------------------------------------------------
   Evaluating Haskell expressions

   The versions ending in '_' allow you to specify an initial stack size.
   Note that these calls may cause Garbage Collection, so all HaskellObj
   references are rendered invalid by these calls.

   All of these functions take a (Capability **) - there is a
   Capability pointer both input and output.  We use an inout
   parameter because this is less error-prone for the client than a
   return value - the client could easily forget to use the return
   value, whereas incorrectly using an inout parameter will usually
   result in a type error.
   ------------------------------------------------------------------------- */

void rts_eval (/* inout */ Capability **,
               /* in    */ HaskellObj p,
               /* out */   HaskellObj *ret);

void rts_eval_ (/* inout */ Capability **,
                /* in    */ HaskellObj p,
                /* in    */ unsigned int stack_size,
                /* out   */ HaskellObj *ret);

void rts_evalIO (/* inout */ Capability **,
                 /* in    */ HaskellObj p,
                 /* out */   HaskellObj *ret);

void rts_evalStableIO (/* inout */ Capability **,
                       /* in    */ HsStablePtr s,
                       /* out */   HsStablePtr *ret);

void rts_evalLazyIO (/* inout */ Capability **,
                     /* in    */ HaskellObj p,
                     /* out */   HaskellObj *ret);

void rts_evalLazyIO_ (/* inout */ Capability **,
                      /* in    */ HaskellObj p,
                      /* in    */ unsigned int stack_size,
                      /* out   */ HaskellObj *ret);

void rts_checkSchedStatus (char* site, Capability *);

SchedulerStatus rts_getSchedStatus (Capability *cap);

/*
 * The RTS allocates some thread-local data when you make a call into
 * Haskell using one of the rts_eval() functions.  This data is not
 * normally freed until hs_exit().  If you want to free it earlier
 * than this, perhaps because the thread is about to exit, then call
 * rts_done() from the thread.
 *
 * It is safe to make more rts_eval() calls after calling rts_done(),
 * but the next one will cause allocation of the thread-local memory
 * again.
 */
void rts_done (void);

/* --------------------------------------------------------------------------
   Wrapper closures

   These are used by foreign export and foreign import "wrapper" stubs.
   ----------------------------------------------------------------------- */

// When producing Windows DLLs the we need to know which symbols are in the
//      local package/DLL vs external ones.
//
//      Note that RtsAPI.h is also included by foreign export stubs in
//      the base package itself.
//
#if defined(COMPILING_WINDOWS_DLL) && !defined(COMPILING_BASE_PACKAGE)
__declspec(dllimport) extern StgWord base_GHCziTopHandler_runIO_closure[];
__declspec(dllimport) extern StgWord base_GHCziTopHandler_runNonIO_closure[];
#else
extern StgWord base_GHCziTopHandler_runIO_closure[];
extern StgWord base_GHCziTopHandler_runNonIO_closure[];
#endif

#define runIO_closure     base_GHCziTopHandler_runIO_closure
#define runNonIO_closure  base_GHCziTopHandler_runNonIO_closure

/* ------------------------------------------------------------------------ */

#ifdef __cplusplus
}
#endif

#endif /* RTSAPI_H */
{-# START_FILE include/ghc-8.0.2/stg/DLL.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * Support for Windows DLLs.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef __STGDLL_H__
#define __STGDLL_H__ 1

#if defined(COMPILING_WINDOWS_DLL)
#  if defined(x86_64_HOST_ARCH)
#    define DLL_IMPORT_DATA_REF(x) (__imp_##x)
#    define DLL_IMPORT_DATA_VARNAME(x) *__imp_##x
#  else
#    define DLL_IMPORT_DATA_REF(x) (_imp__##x)
#    define DLL_IMPORT_DATA_VARNAME(x) *_imp__##x
#  endif
#  if __GNUC__ && !defined(__declspec)
#    define DLLIMPORT
#  else
#    define DLLIMPORT __declspec(dllimport)
#    if defined(x86_64_HOST_ARCH)
#      define DLLIMPORT_DATA(x) __imp_##x
#    else
#      define DLLIMPORT_DATA(x) _imp__##x
#    endif
#  endif
#else
#  define DLL_IMPORT_DATA_REF(x) (&(x))
#  define DLL_IMPORT_DATA_VARNAME(x) x
#  define DLLIMPORT
#endif

/* The view of the ghc/includes/ header files differ ever so
   slightly depending on whether the RTS is being compiled
   or not - so we're forced to distinguish between two.
   [oh, you want details :) : Data symbols defined by the RTS
    have to be accessed through an extra level of indirection
    when compiling generated .hc code compared to when the RTS
    sources are being processed. This is only the case when 
    using Win32 DLLs. ]
*/
#ifdef COMPILING_RTS
#define DLL_IMPORT DLLIMPORT
#define DLL_IMPORT_RTS
#define DLL_IMPORT_DATA_VAR(x) x
#else
#define DLL_IMPORT
#define DLL_IMPORT_RTS DLLIMPORT
# if defined(COMPILING_WINDOWS_DLL)
#  if defined(x86_64_HOST_ARCH)
#   define DLL_IMPORT_DATA_VAR(x) __imp_##x
#  else
#   define DLL_IMPORT_DATA_VAR(x) _imp__##x
#  endif
# else
#  define DLL_IMPORT_DATA_VAR(x) x
# endif
#endif


#ifdef COMPILING_STDLIB
#define DLL_IMPORT_STDLIB
#else
#define DLL_IMPORT_STDLIB DLLIMPORT
#endif

#endif /* __STGDLL_H__ */
{-# START_FILE include/ghc-8.0.2/stg/HaskellMachRegs.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2011
 *
 * Registers used in STG code.  Might or might not correspond to
 * actual machine registers.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef HASKELLMACHREGS_H
#define HASKELLMACHREGS_H

/*
 * Defining NO_REGS causes no global registers to be used.  NO_REGS is
 * typically defined by GHC, via a command-line option passed to gcc,
 * when the -funregisterised flag is given.
 *
 * NB. When NO_REGS is on, calling & return conventions may be
 * different.  For example, all function arguments will be passed on
 * the stack, and components of an unboxed tuple will be returned on
 * the stack rather than in registers.
 */
#ifdef NO_REGS

#define MACHREGS_NO_REGS 1

#else

#define MACHREGS_NO_REGS 0

#define MACHREGS_i386     i386_TARGET_ARCH
#define MACHREGS_x86_64   x86_64_TARGET_ARCH
#define MACHREGS_powerpc  (powerpc_TARGET_ARCH || powerpc64_TARGET_ARCH \
                || powerpc64le_TARGET_ARCH || rs6000_TARGET_ARCH)
#define MACHREGS_sparc    sparc_TARGET_ARCH
#define MACHREGS_arm      arm_TARGET_ARCH
#define MACHREGS_aarch64  aarch64_TARGET_ARCH
#define MACHREGS_darwin   darwin_TARGET_OS

#endif

#include "MachRegs.h"

#endif /* HASKELLMACHREGS_H */
{-# START_FILE include/ghc-8.0.2/stg/MachRegs.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2014
 *
 * Registers used in STG code.  Might or might not correspond to
 * actual machine registers.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef MACHREGS_H
#define MACHREGS_H

/* This file is #included into Haskell code in the compiler: #defines
 * only in here please.
 */

/*
 * Undefine these as a precaution: some of them were found to be
 * defined by system headers on ARM/Linux.
 */
#undef REG_R1
#undef REG_R2
#undef REG_R3
#undef REG_R4
#undef REG_R5
#undef REG_R6
#undef REG_R7
#undef REG_R8
#undef REG_R9
#undef REG_R10

/*
 * Defining MACHREGS_NO_REGS to 1 causes no global registers to be used.
 * MACHREGS_NO_REGS is typically controlled by NO_REGS, which is
 * typically defined by GHC, via a command-line option passed to gcc,
 * when the -funregisterised flag is given.
 *
 * NB. When MACHREGS_NO_REGS to 1, calling & return conventions may be
 * different.  For example, all function arguments will be passed on
 * the stack, and components of an unboxed tuple will be returned on
 * the stack rather than in registers.
 */
#if MACHREGS_NO_REGS == 1

/* Nothing */

#elif MACHREGS_NO_REGS == 0

/* ----------------------------------------------------------------------------
   Caller saves and callee-saves regs.

   Caller-saves regs have to be saved around C-calls made from STG
   land, so this file defines CALLER_SAVES_<reg> for each <reg> that
   is designated caller-saves in that machine's C calling convention.

   As it stands, the only registers that are ever marked caller saves
   are the RX, FX, DX and USER registers; as a result, if you
   decide to caller save a system register (e.g. SP, HP, etc), note that
   this code path is completely untested! -- EZY
   -------------------------------------------------------------------------- */

/* -----------------------------------------------------------------------------
   The x86 register mapping

   Ok, we've only got 6 general purpose registers, a frame pointer and a
   stack pointer.  \tr{%eax} and \tr{%edx} are return values from C functions,
   hence they get trashed across ccalls and are caller saves. \tr{%ebx},
   \tr{%esi}, \tr{%edi}, \tr{%ebp} are all callee-saves.

   Reg     STG-Reg
   ---------------
   ebx     Base
   ebp     Sp
   esi     R1
   edi     Hp

   Leaving SpLim out of the picture.
   -------------------------------------------------------------------------- */

#if MACHREGS_i386

#define REG(x) __asm__("%" #x)

#ifndef not_doing_dynamic_linking
#define REG_Base    ebx
#endif
#define REG_Sp      ebp

#ifndef STOLEN_X86_REGS
#define STOLEN_X86_REGS 4
#endif

#if STOLEN_X86_REGS >= 3
# define REG_R1     esi
#endif

#if STOLEN_X86_REGS >= 4
# define REG_Hp     edi
#endif
#define REG_MachSp  esp

#define REG_XMM1    xmm0
#define REG_XMM2    xmm1
#define REG_XMM3    xmm2
#define REG_XMM4    xmm3

#define REG_YMM1    ymm0
#define REG_YMM2    ymm1
#define REG_YMM3    ymm2
#define REG_YMM4    ymm3

#define REG_ZMM1    zmm0
#define REG_ZMM2    zmm1
#define REG_ZMM3    zmm2
#define REG_ZMM4    zmm3

#define MAX_REAL_VANILLA_REG 1  /* always, since it defines the entry conv */
#define MAX_REAL_FLOAT_REG   0
#define MAX_REAL_DOUBLE_REG  0
#define MAX_REAL_LONG_REG    0
#define MAX_REAL_XMM_REG     4
#define MAX_REAL_YMM_REG     4
#define MAX_REAL_ZMM_REG     4

/* -----------------------------------------------------------------------------
  The x86-64 register mapping

  %rax          caller-saves, don't steal this one
  %rbx          YES
  %rcx          arg reg, caller-saves
  %rdx          arg reg, caller-saves
  %rsi          arg reg, caller-saves
  %rdi          arg reg, caller-saves
  %rbp          YES (our *prime* register)
  %rsp          (unavailable - stack pointer)
  %r8           arg reg, caller-saves
  %r9           arg reg, caller-saves
  %r10          caller-saves
  %r11          caller-saves
  %r12          YES
  %r13          YES
  %r14          YES
  %r15          YES

  %xmm0-7       arg regs, caller-saves
  %xmm8-15      caller-saves

  Use the caller-saves regs for Rn, because we don't always have to
  save those (as opposed to Sp/Hp/SpLim etc. which always have to be
  saved).

  --------------------------------------------------------------------------- */

#elif MACHREGS_x86_64

#define REG(x) __asm__("%" #x)

#define REG_Base  r13
#define REG_Sp    rbp
#define REG_Hp    r12
#define REG_R1    rbx
#define REG_R2    r14
#define REG_R3    rsi
#define REG_R4    rdi
#define REG_R5    r8
#define REG_R6    r9
#define REG_SpLim r15
#define REG_MachSp  rsp

/*
Map both Fn and Dn to register xmmn so that we can pass a function any
combination of up to six Float# or Double# arguments without touching
the stack. See Note [Overlapping global registers] for implications.
*/

#define REG_F1    xmm1
#define REG_F2    xmm2
#define REG_F3    xmm3
#define REG_F4    xmm4
#define REG_F5    xmm5
#define REG_F6    xmm6

#define REG_D1    xmm1
#define REG_D2    xmm2
#define REG_D3    xmm3
#define REG_D4    xmm4
#define REG_D5    xmm5
#define REG_D6    xmm6

#define REG_XMM1    xmm1
#define REG_XMM2    xmm2
#define REG_XMM3    xmm3
#define REG_XMM4    xmm4
#define REG_XMM5    xmm5
#define REG_XMM6    xmm6

#define REG_YMM1    ymm1
#define REG_YMM2    ymm2
#define REG_YMM3    ymm3
#define REG_YMM4    ymm4
#define REG_YMM5    ymm5
#define REG_YMM6    ymm6

#define REG_ZMM1    zmm1
#define REG_ZMM2    zmm2
#define REG_ZMM3    zmm3
#define REG_ZMM4    zmm4
#define REG_ZMM5    zmm5
#define REG_ZMM6    zmm6

#if !defined(mingw32_HOST_OS)
#define CALLER_SAVES_R3
#define CALLER_SAVES_R4
#endif
#define CALLER_SAVES_R5
#define CALLER_SAVES_R6

#define CALLER_SAVES_F1
#define CALLER_SAVES_F2
#define CALLER_SAVES_F3
#define CALLER_SAVES_F4
#define CALLER_SAVES_F5
#if !defined(mingw32_HOST_OS)
#define CALLER_SAVES_F6
#endif

#define CALLER_SAVES_D1
#define CALLER_SAVES_D2
#define CALLER_SAVES_D3
#define CALLER_SAVES_D4
#define CALLER_SAVES_D5
#if !defined(mingw32_HOST_OS)
#define CALLER_SAVES_D6
#endif

#define CALLER_SAVES_XMM1
#define CALLER_SAVES_XMM2
#define CALLER_SAVES_XMM3
#define CALLER_SAVES_XMM4
#define CALLER_SAVES_XMM5
#if !defined(mingw32_HOST_OS)
#define CALLER_SAVES_XMM6
#endif

#define CALLER_SAVES_YMM1
#define CALLER_SAVES_YMM2
#define CALLER_SAVES_YMM3
#define CALLER_SAVES_YMM4
#define CALLER_SAVES_YMM5
#if !defined(mingw32_HOST_OS)
#define CALLER_SAVES_YMM6
#endif

#define CALLER_SAVES_ZMM1
#define CALLER_SAVES_ZMM2
#define CALLER_SAVES_ZMM3
#define CALLER_SAVES_ZMM4
#define CALLER_SAVES_ZMM5
#if !defined(mingw32_HOST_OS)
#define CALLER_SAVES_ZMM6
#endif

#define MAX_REAL_VANILLA_REG 6
#define MAX_REAL_FLOAT_REG   6
#define MAX_REAL_DOUBLE_REG  6
#define MAX_REAL_LONG_REG    0
#define MAX_REAL_XMM_REG     6
#define MAX_REAL_YMM_REG     6
#define MAX_REAL_ZMM_REG     6

/* -----------------------------------------------------------------------------
   The PowerPC register mapping

   0            system glue?    (caller-save, volatile)
   1            SP              (callee-save, non-volatile)
   2            AIX, powerpc64-linux:
                    RTOC        (a strange special case)
                darwin:
                                (caller-save, volatile)
                powerpc32-linux:
                                reserved for use by system

   3-10         args/return     (caller-save, volatile)
   11,12        system glue?    (caller-save, volatile)
   13           on 64-bit:      reserved for thread state pointer
                on 32-bit:      (callee-save, non-volatile)
   14-31                        (callee-save, non-volatile)

   f0                           (caller-save, volatile)
   f1-f13       args/return     (caller-save, volatile)
   f14-f31                      (callee-save, non-volatile)

   \tr{14}--\tr{31} are wonderful callee-save registers on all ppc OSes.
   \tr{0}--\tr{12} are caller-save registers.

   \tr{%f14}--\tr{%f31} are callee-save floating-point registers.

   We can do the Whole Business with callee-save registers only!
   -------------------------------------------------------------------------- */

#elif MACHREGS_powerpc

#define REG(x) __asm__(#x)

#define REG_R1          r14
#define REG_R2          r15
#define REG_R3          r16
#define REG_R4          r17
#define REG_R5          r18
#define REG_R6          r19
#define REG_R7          r20
#define REG_R8          r21

#if MACHREGS_darwin

#define REG_F1          f14
#define REG_F2          f15
#define REG_F3          f16
#define REG_F4          f17

#define REG_D1          f18
#define REG_D2          f19

#else

#define REG_F1          fr14
#define REG_F2          fr15
#define REG_F3          fr16
#define REG_F4          fr17

#define REG_D1          fr18
#define REG_D2          fr19

#endif

#define REG_Sp          r22
#define REG_SpLim       r24

#define REG_Hp          r25

#define REG_Base        r27

/* -----------------------------------------------------------------------------
   The Sun SPARC register mapping

   !! IMPORTANT: if you change this register mapping you must also update
                 compiler/nativeGen/SPARC/Regs.hs. That file handles the
                 mapping for the NCG. This one only affects via-c code.

   The SPARC register (window) story: Remember, within the Haskell
   Threaded World, we essentially ``shut down'' the register-window
   mechanism---the window doesn't move at all while in this World.  It
   *does* move, of course, if we call out to arbitrary~C...

   The %i, %l, and %o registers (8 each) are the input, local, and
   output registers visible in one register window.  The 8 %g (global)
   registers are visible all the time.

      zero: always zero
   scratch: volatile across C-fn calls. used by linker.
       app: usable by application
    system: reserved for system

     alloc: allocated to in the register allocator, intra-closure only

                GHC usage     v8 ABI        v9 ABI
   Global
     %g0        zero        zero          zero
     %g1        alloc       scratch       scrach
     %g2        alloc       app           app
     %g3        alloc       app           app
     %g4        alloc       app           scratch
     %g5                    system        scratch
     %g6                    system        system
     %g7                    system        system

   Output: can be zapped by callee
     %o0-o5     alloc       caller saves
     %o6                    C stack ptr
     %o7                    C ret addr

   Local: maintained by register windowing mechanism
     %l0        alloc
     %l1        R1
     %l2        R2
     %l3        R3
     %l4        R4
     %l5        R5
     %l6        alloc
     %l7        alloc

   Input
     %i0        Sp
     %i1        Base
     %i2        SpLim
     %i3        Hp
     %i4        alloc
     %i5        R6
     %i6                    C frame ptr
     %i7                    C ret addr

   The paired nature of the floating point registers causes complications for
   the native code generator.  For convenience, we pretend that the first 22
   fp regs %f0 .. %f21 are actually 11 double regs, and the remaining 10 are
   float (single) regs.  The NCG acts accordingly.  That means that the
   following FP assignment is rather fragile, and should only be changed
   with extreme care.  The current scheme is:

      %f0 /%f1    FP return from C
      %f2 /%f3    D1
      %f4 /%f5    D2
      %f6 /%f7    ncg double spill tmp #1
      %f8 /%f9    ncg double spill tmp #2
      %f10/%f11   allocatable
      %f12/%f13   allocatable
      %f14/%f15   allocatable
      %f16/%f17   allocatable
      %f18/%f19   allocatable
      %f20/%f21   allocatable

      %f22        F1
      %f23        F2
      %f24        F3
      %f25        F4
      %f26        ncg single spill tmp #1
      %f27        ncg single spill tmp #2
      %f28        allocatable
      %f29        allocatable
      %f30        allocatable
      %f31        allocatable

   -------------------------------------------------------------------------- */

#elif MACHREGS_sparc

#define REG(x) __asm__("%" #x)

#define CALLER_SAVES_USER

#define CALLER_SAVES_F1
#define CALLER_SAVES_F2
#define CALLER_SAVES_F3
#define CALLER_SAVES_F4
#define CALLER_SAVES_D1
#define CALLER_SAVES_D2

#define REG_R1          l1
#define REG_R2          l2
#define REG_R3          l3
#define REG_R4          l4
#define REG_R5          l5
#define REG_R6          i5

#define REG_F1          f22
#define REG_F2          f23
#define REG_F3          f24
#define REG_F4          f25

/* for each of the double arg regs,
   Dn_2 is the high half. */

#define REG_D1          f2
#define REG_D1_2        f3

#define REG_D2          f4
#define REG_D2_2        f5

#define REG_Sp          i0
#define REG_SpLim       i2

#define REG_Hp          i3

#define REG_Base        i1

#define NCG_FirstFloatReg f22

/* -----------------------------------------------------------------------------
   The ARM EABI register mapping

   Here we consider ARM mode (i.e. 32bit isns)
   and also CPU with full VFPv3 implementation

   ARM registers (see Chapter 5.1 in ARM IHI 0042D)

   r15  PC         The Program Counter.
   r14  LR         The Link Register.
   r13  SP         The Stack Pointer.
   r12  IP         The Intra-Procedure-call scratch register.
   r11  v8         Variable-register 8.
   r10  v7         Variable-register 7.
   r9   v6/SB/TR   Platform register. The meaning of this register is
                   defined by the platform standard.
   r8   v5         Variable-register 5.
   r7   v4         Variable register 4.
   r6   v3         Variable register 3.
   r5   v2         Variable register 2.
   r4   v1         Variable register 1.
   r3   a4         Argument / scratch register 4.
   r2   a3         Argument / scratch register 3.
   r1   a2         Argument / result / scratch register 2.
   r0   a1         Argument / result / scratch register 1.

   VFPv2/VFPv3/NEON registers
   s0-s15/d0-d7/q0-q3    Argument / result/ scratch registers
   s16-s31/d8-d15/q4-q7  callee-saved registers (must be preserved across
                         subrutine calls)

   VFPv3/NEON registers (added to the VFPv2 registers set)
   d16-d31/q8-q15        Argument / result/ scratch registers
   ----------------------------------------------------------------------------- */

#elif MACHREGS_arm

#define REG(x) __asm__(#x)

#define REG_Base        r4
#define REG_Sp          r5
#define REG_Hp          r6
#define REG_R1          r7
#define REG_R2          r8
#define REG_R3          r9
#define REG_R4          r10
#define REG_SpLim       r11

#if !defined(arm_HOST_ARCH_PRE_ARMv6)
/* d8 */
#define REG_F1    s16
#define REG_F2    s17
/* d9 */
#define REG_F3    s18
#define REG_F4    s19

#define REG_D1    d10
#define REG_D2    d11
#endif

/* -----------------------------------------------------------------------------
   The ARMv8/AArch64 ABI register mapping

   The AArch64 provides 31 64-bit general purpose registers
   and 32 128-bit SIMD/floating point registers.

   General purpose registers (see Chapter 5.1.1 in ARM IHI 0055B)

   Register | Special | Role in the procedure call standard
   ---------+---------+------------------------------------
     SP     |         | The Stack Pointer
     r30    |  LR     | The Link Register
     r29    |  FP     | The Frame Pointer
   r19-r28  |         | Callee-saved registers
     r18    |         | The Platform Register, if needed; 
            |         | or temporary register
     r17    |  IP1    | The second intra-procedure-call temporary register
     r16    |  IP0    | The first intra-procedure-call scratch register
    r9-r15  |         | Temporary registers
     r8     |         | Indirect result location register
    r0-r7   |         | Parameter/result registers


   FPU/SIMD registers

   s/d/q/v0-v7    Argument / result/ scratch registers
   s/d/q/v8-v15   callee-saved registers (must be preserved across subrutine calls,
                  but only bottom 64-bit value needs to be preserved)
   s/d/q/v16-v31  temporary registers

   ----------------------------------------------------------------------------- */

#elif MACHREGS_aarch64

#define REG(x) __asm__(#x)

#define REG_Base        r19
#define REG_Sp          r20
#define REG_Hp          r21
#define REG_R1          r22
#define REG_R2          r23
#define REG_R3          r24
#define REG_R4          r25
#define REG_R5          r26
#define REG_R6          r27
#define REG_SpLim       r28

#define REG_F1          s8
#define REG_F2          s9
#define REG_F3          s10
#define REG_F4          s11

#define REG_D1          d12
#define REG_D2          d13
#define REG_D3          d14
#define REG_D4          d15

#else

#error Cannot find platform to give register info for

#endif

#else

#error Bad MACHREGS_NO_REGS value

#endif

/* -----------------------------------------------------------------------------
 * These constants define how many stg registers will be used for
 * passing arguments (and results, in the case of an unboxed-tuple
 * return).
 *
 * We usually set MAX_REAL_VANILLA_REG and co. to be the number of the
 * highest STG register to occupy a real machine register, otherwise
 * the calling conventions will needlessly shuffle data between the
 * stack and memory-resident STG registers.  We might occasionally
 * set these macros to other values for testing, though.
 *
 * Registers above these values might still be used, for instance to
 * communicate with PrimOps and RTS functions.
 */

#ifndef MAX_REAL_VANILLA_REG
#  if   defined(REG_R10)
#  define MAX_REAL_VANILLA_REG 10
#  elif   defined(REG_R9)
#  define MAX_REAL_VANILLA_REG 9
#  elif   defined(REG_R8)
#  define MAX_REAL_VANILLA_REG 8
#  elif defined(REG_R7)
#  define MAX_REAL_VANILLA_REG 7
#  elif defined(REG_R6)
#  define MAX_REAL_VANILLA_REG 6
#  elif defined(REG_R5)
#  define MAX_REAL_VANILLA_REG 5
#  elif defined(REG_R4)
#  define MAX_REAL_VANILLA_REG 4
#  elif defined(REG_R3)
#  define MAX_REAL_VANILLA_REG 3
#  elif defined(REG_R2)
#  define MAX_REAL_VANILLA_REG 2
#  elif defined(REG_R1)
#  define MAX_REAL_VANILLA_REG 1
#  else
#  define MAX_REAL_VANILLA_REG 0
#  endif
#endif

#ifndef MAX_REAL_FLOAT_REG
#  if   defined(REG_F4)
#  define MAX_REAL_FLOAT_REG 4
#  elif defined(REG_F3)
#  define MAX_REAL_FLOAT_REG 3
#  elif defined(REG_F2)
#  define MAX_REAL_FLOAT_REG 2
#  elif defined(REG_F1)
#  define MAX_REAL_FLOAT_REG 1
#  else
#  define MAX_REAL_FLOAT_REG 0
#  endif
#endif

#ifndef MAX_REAL_DOUBLE_REG
#  if   defined(REG_D2)
#  define MAX_REAL_DOUBLE_REG 2
#  elif defined(REG_D1)
#  define MAX_REAL_DOUBLE_REG 1
#  else
#  define MAX_REAL_DOUBLE_REG 0
#  endif
#endif

#ifndef MAX_REAL_LONG_REG
#  if   defined(REG_L1)
#  define MAX_REAL_LONG_REG 1
#  else
#  define MAX_REAL_LONG_REG 0
#  endif
#endif

#ifndef MAX_REAL_XMM_REG
#  if   defined(REG_XMM6)
#  define MAX_REAL_XMM_REG 6
#  elif defined(REG_XMM5)
#  define MAX_REAL_XMM_REG 5
#  elif defined(REG_XMM4)
#  define MAX_REAL_XMM_REG 4
#  elif defined(REG_XMM3)
#  define MAX_REAL_XMM_REG 3
#  elif defined(REG_XMM2)
#  define MAX_REAL_XMM_REG 2
#  elif defined(REG_XMM1)
#  define MAX_REAL_XMM_REG 1
#  else
#  define MAX_REAL_XMM_REG 0
#  endif
#endif

/* define NO_ARG_REGS if we have no argument registers at all (we can
 * optimise certain code paths using this predicate).
 */
#if MAX_REAL_VANILLA_REG < 2
#define NO_ARG_REGS
#else
#undef NO_ARG_REGS
#endif

#endif /* MACHREGS_H */
{-# START_FILE include/ghc-8.0.2/stg/MiscClosures.h #-}
/* ----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * Declarations for various symbols exported by the RTS.
 *
 * ToDo: many of the symbols in here don't need to be exported, but
 * our Cmm code generator doesn't know how to generate local symbols
 * for the RTS bits (it assumes all RTS symbols are external).
 *
 * See wiki:Commentary/Compiler/Backends/PprC#Prototypes
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * --------------------------------------------------------------------------*/

#ifndef STGMISCCLOSURES_H
#define STGMISCCLOSURES_H

#if IN_STG_CODE
#  define RTS_RET_INFO(i)   extern W_(i)[]
#  define RTS_FUN_INFO(i)   extern W_(i)[]
#  define RTS_THUNK_INFO(i) extern W_(i)[]
#  define RTS_INFO(i)       extern W_(i)[]
#  define RTS_CLOSURE(i)    extern W_(i)[]
#  define RTS_FUN_DECL(f)   extern DLL_IMPORT_RTS StgFunPtr f(void)
#else
#  define RTS_RET_INFO(i)   extern DLL_IMPORT_RTS const StgRetInfoTable i
#  define RTS_FUN_INFO(i)   extern DLL_IMPORT_RTS const StgFunInfoTable i
#  define RTS_THUNK_INFO(i) extern DLL_IMPORT_RTS const StgThunkInfoTable i
#  define RTS_INFO(i)       extern DLL_IMPORT_RTS const StgInfoTable i
#  define RTS_CLOSURE(i)    extern DLL_IMPORT_RTS StgClosure i
#  define RTS_FUN_DECL(f)   extern DLL_IMPORT_RTS StgFunPtr f(void)
#endif

#ifdef TABLES_NEXT_TO_CODE
#  define RTS_RET(f)      RTS_INFO(f##_info)
#  define RTS_ENTRY(f)    RTS_INFO(f##_info)
#  define RTS_FUN(f)      RTS_FUN_INFO(f##_info)
#  define RTS_THUNK(f)    RTS_THUNK_INFO(f##_info)
#else
#  define RTS_RET(f)      RTS_INFO(f##_info);  RTS_FUN_DECL(f##_ret)
#  define RTS_ENTRY(f)    RTS_INFO(f##_info);  RTS_FUN_DECL(f##_entry)
#  define RTS_FUN(f)      RTS_FUN_INFO(f##_info); RTS_FUN_DECL(f##_entry)
#  define RTS_THUNK(f)    RTS_THUNK_INFO(f##_info); RTS_FUN_DECL(f##_entry)
#endif

/* Stack frames */
RTS_RET(stg_upd_frame);
RTS_RET(stg_bh_upd_frame);
RTS_RET(stg_marked_upd_frame);
RTS_RET(stg_noupd_frame);
RTS_RET(stg_catch_frame);
RTS_RET(stg_catch_retry_frame);
RTS_RET(stg_atomically_frame);
RTS_RET(stg_atomically_waiting_frame);
RTS_RET(stg_catch_stm_frame);
RTS_RET(stg_unmaskAsyncExceptionszh_ret);
RTS_RET(stg_maskUninterruptiblezh_ret);
RTS_RET(stg_maskAsyncExceptionszh_ret);
RTS_RET(stg_stack_underflow_frame);
RTS_RET(stg_restore_cccs);

// RTS_FUN(stg_interp_constr1_entry);
// RTS_FUN(stg_interp_constr2_entry);
// RTS_FUN(stg_interp_constr3_entry);
// RTS_FUN(stg_interp_constr4_entry);
// RTS_FUN(stg_interp_constr5_entry);
// RTS_FUN(stg_interp_constr6_entry);
// RTS_FUN(stg_interp_constr7_entry);
//
// This is referenced using the FFI in the compiler (ByteCodeItbls),
// so we can't give it the correct type here because the prototypes
// would clash (FFI references are always declared with type StgWord[]
// in the generated C code).

/* Magic glue code for when compiled code returns a value in R1/F1/D1
   or a VoidRep to the interpreter. */
RTS_RET(stg_ctoi_R1p);
RTS_RET(stg_ctoi_R1unpt);
RTS_RET(stg_ctoi_R1n);
RTS_RET(stg_ctoi_F1);
RTS_RET(stg_ctoi_D1);
RTS_RET(stg_ctoi_L1);
RTS_RET(stg_ctoi_V);

RTS_RET(stg_apply_interp);

RTS_ENTRY(stg_IND);
RTS_ENTRY(stg_IND_direct);
RTS_ENTRY(stg_IND_STATIC);
RTS_ENTRY(stg_IND_PERM);
RTS_ENTRY(stg_BLACKHOLE);
RTS_ENTRY(stg_CAF_BLACKHOLE);
RTS_ENTRY(__stg_EAGER_BLACKHOLE);
RTS_ENTRY(stg_WHITEHOLE);
RTS_ENTRY(stg_BLOCKING_QUEUE_CLEAN);
RTS_ENTRY(stg_BLOCKING_QUEUE_DIRTY);

RTS_FUN(stg_BCO);
RTS_ENTRY(stg_EVACUATED);
RTS_ENTRY(stg_WEAK);
RTS_ENTRY(stg_DEAD_WEAK);
RTS_ENTRY(stg_C_FINALIZER_LIST);
RTS_ENTRY(stg_STABLE_NAME);
RTS_ENTRY(stg_MVAR_CLEAN);
RTS_ENTRY(stg_MVAR_DIRTY);
RTS_ENTRY(stg_TVAR_CLEAN);
RTS_ENTRY(stg_TVAR_DIRTY);
RTS_ENTRY(stg_TSO);
RTS_ENTRY(stg_STACK);
RTS_ENTRY(stg_ARR_WORDS);
RTS_ENTRY(stg_MUT_ARR_WORDS);
RTS_ENTRY(stg_MUT_ARR_PTRS_CLEAN);
RTS_ENTRY(stg_MUT_ARR_PTRS_DIRTY);
RTS_ENTRY(stg_MUT_ARR_PTRS_FROZEN);
RTS_ENTRY(stg_MUT_ARR_PTRS_FROZEN0);
RTS_ENTRY(stg_SMALL_MUT_ARR_PTRS_CLEAN);
RTS_ENTRY(stg_SMALL_MUT_ARR_PTRS_DIRTY);
RTS_ENTRY(stg_SMALL_MUT_ARR_PTRS_FROZEN);
RTS_ENTRY(stg_SMALL_MUT_ARR_PTRS_FROZEN0);
RTS_ENTRY(stg_MUT_VAR_CLEAN);
RTS_ENTRY(stg_MUT_VAR_DIRTY);
RTS_ENTRY(stg_END_TSO_QUEUE);
RTS_ENTRY(stg_GCD_CAF);
RTS_ENTRY(stg_STM_AWOKEN);
RTS_ENTRY(stg_MSG_TRY_WAKEUP);
RTS_ENTRY(stg_MSG_THROWTO);
RTS_ENTRY(stg_MSG_BLACKHOLE);
RTS_ENTRY(stg_MSG_NULL);
RTS_ENTRY(stg_MVAR_TSO_QUEUE);
RTS_ENTRY(stg_catch);
RTS_ENTRY(stg_PAP);
RTS_ENTRY(stg_AP);
RTS_ENTRY(stg_AP_NOUPD);
RTS_ENTRY(stg_AP_STACK);
RTS_ENTRY(stg_AP_STACK_NOUPD);
RTS_ENTRY(stg_dummy_ret);
RTS_ENTRY(stg_raise);
RTS_ENTRY(stg_raise_ret);
RTS_ENTRY(stg_atomically);
RTS_ENTRY(stg_TVAR_WATCH_QUEUE);
RTS_ENTRY(stg_INVARIANT_CHECK_QUEUE);
RTS_ENTRY(stg_ATOMIC_INVARIANT);
RTS_ENTRY(stg_TREC_CHUNK);
RTS_ENTRY(stg_TREC_HEADER);
RTS_ENTRY(stg_END_STM_WATCH_QUEUE);
RTS_ENTRY(stg_END_INVARIANT_CHECK_QUEUE);
RTS_ENTRY(stg_END_STM_CHUNK_LIST);
RTS_ENTRY(stg_NO_TREC);

/* closures */

RTS_CLOSURE(stg_END_TSO_QUEUE_closure);
RTS_CLOSURE(stg_STM_AWOKEN_closure);
RTS_CLOSURE(stg_NO_FINALIZER_closure);
RTS_CLOSURE(stg_dummy_ret_closure);
RTS_CLOSURE(stg_forceIO_closure);

RTS_CLOSURE(stg_END_STM_WATCH_QUEUE_closure);
RTS_CLOSURE(stg_END_INVARIANT_CHECK_QUEUE_closure);
RTS_CLOSURE(stg_END_STM_CHUNK_LIST_closure);
RTS_CLOSURE(stg_NO_TREC_closure);

RTS_ENTRY(stg_NO_FINALIZER_entry);

#if IN_STG_CODE
extern DLL_IMPORT_RTS StgWordArray stg_CHARLIKE_closure;
extern DLL_IMPORT_RTS StgWordArray stg_INTLIKE_closure;
#else
extern DLL_IMPORT_RTS StgIntCharlikeClosure stg_CHARLIKE_closure[];
extern DLL_IMPORT_RTS StgIntCharlikeClosure stg_INTLIKE_closure[];
#endif

/* StgStartup */

RTS_RET(stg_forceIO);
RTS_RET(stg_noforceIO);

/* standard entry points */

/* standard selector thunks */

RTS_ENTRY(stg_sel_0_upd);
RTS_ENTRY(stg_sel_1_upd);
RTS_ENTRY(stg_sel_2_upd);
RTS_ENTRY(stg_sel_3_upd);
RTS_ENTRY(stg_sel_4_upd);
RTS_ENTRY(stg_sel_5_upd);
RTS_ENTRY(stg_sel_6_upd);
RTS_ENTRY(stg_sel_7_upd);
RTS_ENTRY(stg_sel_8_upd);
RTS_ENTRY(stg_sel_9_upd);
RTS_ENTRY(stg_sel_10_upd);
RTS_ENTRY(stg_sel_11_upd);
RTS_ENTRY(stg_sel_12_upd);
RTS_ENTRY(stg_sel_13_upd);
RTS_ENTRY(stg_sel_14_upd);
RTS_ENTRY(stg_sel_15_upd);

RTS_ENTRY(stg_sel_0_noupd);
RTS_ENTRY(stg_sel_1_noupd);
RTS_ENTRY(stg_sel_2_noupd);
RTS_ENTRY(stg_sel_3_noupd);
RTS_ENTRY(stg_sel_4_noupd);
RTS_ENTRY(stg_sel_5_noupd);
RTS_ENTRY(stg_sel_6_noupd);
RTS_ENTRY(stg_sel_7_noupd);
RTS_ENTRY(stg_sel_8_noupd);
RTS_ENTRY(stg_sel_9_noupd);
RTS_ENTRY(stg_sel_10_noupd);
RTS_ENTRY(stg_sel_11_noupd);
RTS_ENTRY(stg_sel_12_noupd);
RTS_ENTRY(stg_sel_13_noupd);
RTS_ENTRY(stg_sel_14_noupd);
RTS_ENTRY(stg_sel_15_noupd);

/* standard ap thunks */

RTS_THUNK(stg_ap_1_upd);
RTS_THUNK(stg_ap_2_upd);
RTS_THUNK(stg_ap_3_upd);
RTS_THUNK(stg_ap_4_upd);
RTS_THUNK(stg_ap_5_upd);
RTS_THUNK(stg_ap_6_upd);
RTS_THUNK(stg_ap_7_upd);

/* standard application routines (see also utils/genapply,
 * and compiler/codeGen/CgStackery.lhs).
 */
RTS_RET(stg_ap_v);
RTS_RET(stg_ap_f);
RTS_RET(stg_ap_d);
RTS_RET(stg_ap_l);
RTS_RET(stg_ap_v16);
RTS_RET(stg_ap_v32);
RTS_RET(stg_ap_v64);
RTS_RET(stg_ap_n);
RTS_RET(stg_ap_p);
RTS_RET(stg_ap_pv);
RTS_RET(stg_ap_pp);
RTS_RET(stg_ap_ppv);
RTS_RET(stg_ap_ppp);
RTS_RET(stg_ap_pppv);
RTS_RET(stg_ap_pppp);
RTS_RET(stg_ap_ppppp);
RTS_RET(stg_ap_pppppp);

RTS_FUN_DECL(stg_ap_0_fast);
RTS_FUN_DECL(stg_ap_v_fast);
RTS_FUN_DECL(stg_ap_f_fast);
RTS_FUN_DECL(stg_ap_d_fast);
RTS_FUN_DECL(stg_ap_l_fast);
RTS_FUN_DECL(stg_ap_v16_fast);
RTS_FUN_DECL(stg_ap_v32_fast);
RTS_FUN_DECL(stg_ap_v64_fast);
RTS_FUN_DECL(stg_ap_n_fast);
RTS_FUN_DECL(stg_ap_p_fast);
RTS_FUN_DECL(stg_ap_pv_fast);
RTS_FUN_DECL(stg_ap_pp_fast);
RTS_FUN_DECL(stg_ap_ppv_fast);
RTS_FUN_DECL(stg_ap_ppp_fast);
RTS_FUN_DECL(stg_ap_pppv_fast);
RTS_FUN_DECL(stg_ap_pppp_fast);
RTS_FUN_DECL(stg_ap_ppppp_fast);
RTS_FUN_DECL(stg_ap_pppppp_fast);
RTS_FUN_DECL(stg_PAP_apply);

/* standard GC & stack check entry points, all defined in HeapStackCheck.hc */

RTS_FUN_DECL(stg_gc_noregs);

RTS_RET(stg_enter_checkbh);

RTS_RET(stg_ret_v);
RTS_RET(stg_ret_p);
RTS_RET(stg_ret_n);
RTS_RET(stg_ret_f);
RTS_RET(stg_ret_d);
RTS_RET(stg_ret_l);

RTS_FUN_DECL(stg_gc_prim);
RTS_FUN_DECL(stg_gc_prim_p);
RTS_FUN_DECL(stg_gc_prim_pp);
RTS_FUN_DECL(stg_gc_prim_n);

RTS_RET(stg_gc_prim_p_ll_ret);
RTS_FUN_DECL(stg_gc_prim_p_ll);

RTS_RET(stg_enter);
RTS_FUN_DECL(__stg_gc_enter_1);

RTS_FUN_DECL(stg_gc_unpt_r1);
RTS_FUN_DECL(stg_gc_unbx_r1);
RTS_FUN_DECL(stg_gc_f1);
RTS_FUN_DECL(stg_gc_d1);
RTS_FUN_DECL(stg_gc_l1);
RTS_FUN_DECL(stg_gc_pp);
RTS_FUN_DECL(stg_gc_ppp);
RTS_FUN_DECL(stg_gc_pppp);

RTS_RET(stg_gc_fun);
RTS_FUN_DECL(__stg_gc_fun);

RTS_FUN_DECL(stg_yield_noregs);
RTS_FUN_DECL(stg_yield_to_interpreter);
RTS_FUN_DECL(stg_block_noregs);
RTS_FUN_DECL(stg_block_blackhole);
RTS_FUN_DECL(stg_block_blackhole_finally);
RTS_FUN_DECL(stg_block_takemvar);
RTS_FUN_DECL(stg_block_readmvar);
RTS_RET(stg_block_takemvar);
RTS_RET(stg_block_readmvar);
RTS_FUN_DECL(stg_block_putmvar);
RTS_RET(stg_block_putmvar);
#ifdef mingw32_HOST_OS
RTS_FUN_DECL(stg_block_async);
RTS_RET(stg_block_async);
RTS_FUN_DECL(stg_block_async_void);
RTS_RET(stg_block_async_void);
#endif
RTS_FUN_DECL(stg_block_stmwait);
RTS_FUN_DECL(stg_block_throwto);
RTS_RET(stg_block_throwto);

/* Entry/exit points from StgStartup.cmm */

RTS_RET(stg_stop_thread);

RTS_FUN_DECL(stg_returnToStackTop);
RTS_FUN_DECL(stg_returnToSched);
RTS_FUN_DECL(stg_returnToSchedNotPaused);
RTS_FUN_DECL(stg_returnToSchedButFirst);
RTS_FUN_DECL(stg_threadFinished);

RTS_FUN_DECL(stg_init_finish);
RTS_FUN_DECL(stg_init);

RTS_FUN_DECL(StgReturn);

/* -----------------------------------------------------------------------------
   PrimOps
   -------------------------------------------------------------------------- */

RTS_FUN_DECL(stg_decodeFloatzuIntzh);
RTS_FUN_DECL(stg_decodeDoublezu2Intzh);
RTS_FUN_DECL(stg_decodeDoublezuInt64zh);

RTS_FUN_DECL(stg_unsafeThawArrayzh);
RTS_FUN_DECL(stg_casArrayzh);
RTS_FUN_DECL(stg_newByteArrayzh);
RTS_FUN_DECL(stg_newPinnedByteArrayzh);
RTS_FUN_DECL(stg_newAlignedPinnedByteArrayzh);
RTS_FUN_DECL(stg_shrinkMutableByteArrayzh);
RTS_FUN_DECL(stg_resizzeMutableByteArrayzh);
RTS_FUN_DECL(stg_casIntArrayzh);
RTS_FUN_DECL(stg_newArrayzh);
RTS_FUN_DECL(stg_newArrayArrayzh);
RTS_FUN_DECL(stg_copyArrayzh);
RTS_FUN_DECL(stg_copyMutableArrayzh);
RTS_FUN_DECL(stg_copyArrayArrayzh);
RTS_FUN_DECL(stg_copyMutableArrayArrayzh);
RTS_FUN_DECL(stg_cloneArrayzh);
RTS_FUN_DECL(stg_cloneMutableArrayzh);
RTS_FUN_DECL(stg_freezzeArrayzh);
RTS_FUN_DECL(stg_thawArrayzh);

RTS_FUN_DECL(stg_newSmallArrayzh);
RTS_FUN_DECL(stg_unsafeThawSmallArrayzh);
RTS_FUN_DECL(stg_cloneSmallArrayzh);
RTS_FUN_DECL(stg_cloneSmallMutableArrayzh);
RTS_FUN_DECL(stg_freezzeSmallArrayzh);
RTS_FUN_DECL(stg_thawSmallArrayzh);
RTS_FUN_DECL(stg_copySmallArrayzh);
RTS_FUN_DECL(stg_copySmallMutableArrayzh);
RTS_FUN_DECL(stg_casSmallArrayzh);

RTS_FUN_DECL(stg_newMutVarzh);
RTS_FUN_DECL(stg_atomicModifyMutVarzh);
RTS_FUN_DECL(stg_casMutVarzh);

RTS_FUN_DECL(stg_isEmptyMVarzh);
RTS_FUN_DECL(stg_newMVarzh);
RTS_FUN_DECL(stg_takeMVarzh);
RTS_FUN_DECL(stg_putMVarzh);
RTS_FUN_DECL(stg_readMVarzh);
RTS_FUN_DECL(stg_tryTakeMVarzh);
RTS_FUN_DECL(stg_tryPutMVarzh);
RTS_FUN_DECL(stg_tryReadMVarzh);

RTS_FUN_DECL(stg_waitReadzh);
RTS_FUN_DECL(stg_waitWritezh);
RTS_FUN_DECL(stg_delayzh);
#ifdef mingw32_HOST_OS
RTS_FUN_DECL(stg_asyncReadzh);
RTS_FUN_DECL(stg_asyncWritezh);
RTS_FUN_DECL(stg_asyncDoProczh);
#endif

RTS_FUN_DECL(stg_catchzh);
RTS_FUN_DECL(stg_raisezh);
RTS_FUN_DECL(stg_raiseIOzh);

RTS_FUN_DECL(stg_makeStableNamezh);
RTS_FUN_DECL(stg_makeStablePtrzh);
RTS_FUN_DECL(stg_deRefStablePtrzh);

RTS_FUN_DECL(stg_forkzh);
RTS_FUN_DECL(stg_forkOnzh);
RTS_FUN_DECL(stg_yieldzh);
RTS_FUN_DECL(stg_killMyself);
RTS_FUN_DECL(stg_killThreadzh);
RTS_FUN_DECL(stg_getMaskingStatezh);
RTS_FUN_DECL(stg_maskAsyncExceptionszh);
RTS_FUN_DECL(stg_maskUninterruptiblezh);
RTS_FUN_DECL(stg_unmaskAsyncExceptionszh);
RTS_FUN_DECL(stg_myThreadIdzh);
RTS_FUN_DECL(stg_labelThreadzh);
RTS_FUN_DECL(stg_isCurrentThreadBoundzh);
RTS_FUN_DECL(stg_threadStatuszh);

RTS_FUN_DECL(stg_mkWeakzh);
RTS_FUN_DECL(stg_mkWeakNoFinalizzerzh);
RTS_FUN_DECL(stg_mkWeakForeignzh);
RTS_FUN_DECL(stg_addCFinalizzerToWeakzh);
RTS_FUN_DECL(stg_finalizzeWeakzh);
RTS_FUN_DECL(stg_deRefWeakzh);

RTS_FUN_DECL(stg_runRWzh);

RTS_FUN_DECL(stg_newBCOzh);
RTS_FUN_DECL(stg_mkApUpd0zh);

RTS_FUN_DECL(stg_retryzh);
RTS_FUN_DECL(stg_catchRetryzh);
RTS_FUN_DECL(stg_catchSTMzh);
RTS_FUN_DECL(stg_atomicallyzh);
RTS_FUN_DECL(stg_newTVarzh);
RTS_FUN_DECL(stg_readTVarzh);
RTS_FUN_DECL(stg_readTVarIOzh);
RTS_FUN_DECL(stg_writeTVarzh);
RTS_FUN_DECL(stg_checkzh);

RTS_FUN_DECL(stg_unpackClosurezh);
RTS_FUN_DECL(stg_getApStackValzh);
RTS_FUN_DECL(stg_getSparkzh);
RTS_FUN_DECL(stg_numSparkszh);

RTS_FUN_DECL(stg_noDuplicatezh);

RTS_FUN_DECL(stg_traceCcszh);
RTS_FUN_DECL(stg_clearCCSzh);
RTS_FUN_DECL(stg_traceEventzh);
RTS_FUN_DECL(stg_traceMarkerzh);

/* Other misc stuff */
// See wiki:Commentary/Compiler/Backends/PprC#Prototypes

#if IN_STG_CODE && !IN_STGCRUN

// Interpreter.c
extern StgWord rts_stop_next_breakpoint[];
extern StgWord rts_stop_on_exception[];
extern StgWord rts_breakpoint_io_action[];

// Schedule.c
extern StgWord RTS_VAR(blocked_queue_hd), RTS_VAR(blocked_queue_tl);
extern StgWord RTS_VAR(sleeping_queue);
extern StgWord RTS_VAR(sched_mutex);

// Apply.cmm
// canned bitmap for each arg type
extern StgWord stg_arg_bitmaps[];
extern StgWord stg_ap_stack_entries[];
extern StgWord stg_stack_save_entries[];

// Storage.c
extern unsigned int RTS_VAR(g0);
extern unsigned int RTS_VAR(large_alloc_lim);
extern StgWord RTS_VAR(atomic_modify_mutvar_mutex);

// RtsFlags
extern StgWord RTS_VAR(RtsFlags); // bogus type

// Stable.c
extern StgWord RTS_VAR(stable_ptr_table);
extern StgWord RTS_VAR(stable_name_table);

// Profiling.c
extern unsigned int RTS_VAR(era);
extern unsigned int RTS_VAR(entering_PAP);
extern StgWord      RTS_VAR(CC_LIST);          /* registered CC list */
extern StgWord      RTS_VAR(CCS_LIST);         /* registered CCS list */
extern StgWord      CCS_SYSTEM[];
extern unsigned int RTS_VAR(CC_ID);            /* global ids */
extern unsigned int RTS_VAR(CCS_ID);

// Calls to these rts functions are generated directly
// by codegen (see compiler/codeGen/StgCmmProf.hs)
// and don't require (don't emit) forward declarations.
//
// In unregisterised mode (when building via .hc files)
// the calls are ordinary C calls. Functions must be in
// scope and must match prototype assumed by
//    'compiler/codeGen/StgCmmProf.hs'
// as opposed to real prototype declared in
//    'includes/rts/prof/CCS.h'
void enterFunCCS (void *reg, void *ccsfn);
void * pushCostCentre (void *ccs, void *cc);

// Capability.c
extern unsigned int n_capabilities;

#endif

#endif /* STGMISCCLOSURES_H */
{-# START_FILE include/ghc-8.0.2/stg/Prim.h #-}
/* ----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2014-2014
 *
 * Declarations for C fallback primitives implemented by 'ghc-prim' package.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * -------------------------------------------------------------------------- */

#ifndef PRIM_H
#define PRIM_H

/* libraries/ghc-prim/cbits/atomic.c */
StgWord hs_atomic_add8(StgWord x, StgWord val);
StgWord hs_atomic_add16(StgWord x, StgWord val);
StgWord hs_atomic_add32(StgWord x, StgWord val);
StgWord64 hs_atomic_add64(StgWord x, StgWord64 val);
StgWord hs_atomic_sub8(StgWord x, StgWord val);
StgWord hs_atomic_sub16(StgWord x, StgWord val);
StgWord hs_atomic_sub32(StgWord x, StgWord val);
StgWord64 hs_atomic_sub64(StgWord x, StgWord64 val);
StgWord hs_atomic_and8(StgWord x, StgWord val);
StgWord hs_atomic_and16(StgWord x, StgWord val);
StgWord hs_atomic_and32(StgWord x, StgWord val);
StgWord64 hs_atomic_and64(StgWord x, StgWord64 val);
StgWord hs_atomic_nand8(StgWord x, StgWord val);
StgWord hs_atomic_nand16(StgWord x, StgWord val);
StgWord hs_atomic_nand32(StgWord x, StgWord val);
StgWord64 hs_atomic_nand64(StgWord x, StgWord64 val);
StgWord hs_atomic_or8(StgWord x, StgWord val);
StgWord hs_atomic_or16(StgWord x, StgWord val);
StgWord hs_atomic_or32(StgWord x, StgWord val);
StgWord64 hs_atomic_or64(StgWord x, StgWord64 val);
StgWord hs_atomic_xor8(StgWord x, StgWord val);
StgWord hs_atomic_xor16(StgWord x, StgWord val);
StgWord hs_atomic_xor32(StgWord x, StgWord val);
StgWord64 hs_atomic_xor64(StgWord x, StgWord64 val);
StgWord hs_cmpxchg8(StgWord x, StgWord old, StgWord new_);
StgWord hs_cmpxchg16(StgWord x, StgWord old, StgWord new_);
StgWord hs_cmpxchg32(StgWord x, StgWord old, StgWord new_);
StgWord hs_cmpxchg64(StgWord x, StgWord64 old, StgWord64 new_);
StgWord hs_atomicread8(StgWord x);
StgWord hs_atomicread16(StgWord x);
StgWord hs_atomicread32(StgWord x);
StgWord64 hs_atomicread64(StgWord x);
void hs_atomicwrite8(StgWord x, StgWord val);
void hs_atomicwrite16(StgWord x, StgWord val);
void hs_atomicwrite32(StgWord x, StgWord val);
void hs_atomicwrite64(StgWord x, StgWord64 val);

/* libraries/ghc-prim/cbits/bswap.c */
StgWord16 hs_bswap16(StgWord16 x);
StgWord32 hs_bswap32(StgWord32 x);
StgWord64 hs_bswap64(StgWord64 x);

/* TODO: longlong.c */

/* libraries/ghc-prim/cbits/popcnt.c */
StgWord hs_popcnt8(StgWord x);
StgWord hs_popcnt16(StgWord x);
StgWord hs_popcnt32(StgWord x);
StgWord hs_popcnt64(StgWord64 x);
StgWord hs_popcnt(StgWord x);

/* libraries/ghc-prim/cbits/word2float.c */
StgFloat hs_word2float32(StgWord x);
StgDouble hs_word2float64(StgWord x);

/* libraries/ghc-prim/cbits/clz.c */
StgWord hs_clz8(StgWord x);
StgWord hs_clz16(StgWord x);
StgWord hs_clz32(StgWord x);
StgWord hs_clz64(StgWord64 x);

/* libraries/ghc-prim/cbits/ctz.c */
StgWord hs_ctz8(StgWord x);
StgWord hs_ctz16(StgWord x);
StgWord hs_ctz32(StgWord x);
StgWord hs_ctz64(StgWord64 x);

#endif /* PRIM_H */
{-# START_FILE include/ghc-8.0.2/stg/Regs.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2012
 *
 * Registers in the STG machine.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef REGS_H
#define REGS_H

/*
 * The STG machine has a collection of "registers", each one of which
 * may or may not correspond to an actual machine register when
 * running code.
 *
 * The register set is backed by a table in memory (struct
 * StgRegTable).  If a particular STG register is not mapped to a
 * machine register, then the appropriate slot in this table is used
 * instead.
 *
 * This table is itself pointed to by another register, BaseReg.  If
 * BaseReg is not in a machine register, then the register table is
 * used from an absolute location (MainCapability).
 *
 */

typedef struct {
  StgWord        stgEagerBlackholeInfo;
  StgFunPtr      stgGCEnter1;
  StgFunPtr      stgGCFun;
} StgFunTable;

/*
 * Vanilla registers are given this union type, which is purely so
 * that we can cast the vanilla reg to a variety of types with the
 * minimum of syntax.  eg.  R1.w instead of (StgWord)R1.
 */
typedef union {
    StgWord        w;
    StgAddr        a;
    StgChar        c;
    StgFloat       f;
    StgInt         i;
    StgPtr         p;
} StgUnion;

/*
 * This is the table that holds shadow-locations for all the STG
 * registers.  The shadow locations are used when:
 *
 *     1) the particular register isn't mapped to a real machine
 *        register, probably because there's a shortage of real registers.
 *     2) caller-saves registers are saved across a CCall
 */
typedef struct {
  StgUnion        rR1;
  StgUnion        rR2;
  StgUnion        rR3;
  StgUnion        rR4;
  StgUnion        rR5;
  StgUnion        rR6;
  StgUnion        rR7;
  StgUnion        rR8;
  StgUnion        rR9;          /* used occasionally by heap/stack checks */
  StgUnion        rR10;         /* used occasionally by heap/stack checks */
  StgFloat        rF1;
  StgFloat        rF2;
  StgFloat        rF3;
  StgFloat        rF4;
  StgFloat        rF5;
  StgFloat        rF6;
  StgDouble       rD1;
  StgDouble       rD2;
  StgDouble       rD3;
  StgDouble       rD4;
  StgDouble       rD5;
  StgDouble       rD6;
  StgWord128      rXMM1;
  StgWord128      rXMM2;
  StgWord128      rXMM3;
  StgWord128      rXMM4;
  StgWord128      rXMM5;
  StgWord128      rXMM6;
  StgWord256      rYMM1;
  StgWord256      rYMM2;
  StgWord256      rYMM3;
  StgWord256      rYMM4;
  StgWord256      rYMM5;
  StgWord256      rYMM6;
  StgWord512      rZMM1;
  StgWord512      rZMM2;
  StgWord512      rZMM3;
  StgWord512      rZMM4;
  StgWord512      rZMM5;
  StgWord512      rZMM6;
  StgWord64       rL1;
  StgPtr          rSp;
  StgPtr          rSpLim;
  StgPtr          rHp;
  StgPtr          rHpLim;
  struct CostCentreStack_ * rCCCS;  /* current cost-centre-stack */
  struct StgTSO_ *     rCurrentTSO;
  struct nursery_ *    rNursery;
  struct bdescr_ *     rCurrentNursery; /* Hp/HpLim point into this block */
  struct bdescr_ *     rCurrentAlloc;   /* for allocation using allocate() */
  StgWord         rHpAlloc;     /* number of *bytes* being allocated in heap */
  StgWord         rRet;  /* holds the return code of the thread */
} StgRegTable;

#if IN_STG_CODE

/*
 * Registers Hp and HpLim are global across the entire system, and are
 * copied into the RegTable or registers before executing a thread.
 *
 * Registers Sp and SpLim are saved in the TSO for the thread, but are
 * copied into the RegTable or registers before executing a thread.
 *
 * All other registers are "general purpose", and are used for passing
 * arguments to functions, and returning values.  The code generator
 * knows how many of these are in real registers, and avoids
 * generating code that uses non-real registers.  General purpose
 * registers are never saved when returning to the scheduler, instead
 * we save whatever is live at the time on the stack, and restore it
 * later.  This should reduce the context switch time, amongst other
 * things.
 *
 * For argument passing, the stack will be used in preference to
 * pseudo-registers if the architecture has too few general purpose
 * registers.
 *
 * Some special RTS functions like newArray and the Integer primitives
 * expect their arguments to be in registers R1-Rn, so we use these
 * (pseudo-)registers in those cases.
 */

/* -----------------------------------------------------------------------------
 * Emit the GCC-specific register declarations for each machine
 * register being used.  If any STG register isn't mapped to a machine
 * register, then map it to an offset from BaseReg.
 *
 * First, the general purpose registers.  The idea is, if a particular
 * general-purpose STG register can't be mapped to a real machine
 * register, it won't be used at all.  Instead, we'll use the stack.
 */

/* define NO_REGS to omit register declarations - used in RTS C code
 * that needs all the STG definitions but not the global register
 * settings.
 */
#define GLOBAL_REG_DECL(type,name,reg) register type name REG(reg);

#if defined(REG_R1) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgUnion,R1,REG_R1)
#else
# define R1 (BaseReg->rR1)
#endif

#if defined(REG_R2) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgUnion,R2,REG_R2)
#else
# define R2 (BaseReg->rR2)
#endif

#if defined(REG_R3) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgUnion,R3,REG_R3)
#else
# define R3 (BaseReg->rR3)
#endif

#if defined(REG_R4) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgUnion,R4,REG_R4)
#else
# define R4 (BaseReg->rR4)
#endif

#if defined(REG_R5) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgUnion,R5,REG_R5)
#else
# define R5 (BaseReg->rR5)
#endif

#if defined(REG_R6) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgUnion,R6,REG_R6)
#else
# define R6 (BaseReg->rR6)
#endif

#if defined(REG_R7) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgUnion,R7,REG_R7)
#else
# define R7 (BaseReg->rR7)
#endif

#if defined(REG_R8) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgUnion,R8,REG_R8)
#else
# define R8 (BaseReg->rR8)
#endif

#if defined(REG_R9) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgUnion,R9,REG_R9)
#else
# define R9 (BaseReg->rR9)
#endif

#if defined(REG_R10) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgUnion,R10,REG_R10)
#else
# define R10 (BaseReg->rR10)
#endif

#if defined(REG_F1) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgFloat,F1,REG_F1)
#else
#define F1 (BaseReg->rF1)
#endif

#if defined(REG_F2) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgFloat,F2,REG_F2)
#else
#define F2 (BaseReg->rF2)
#endif

#if defined(REG_F3) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgFloat,F3,REG_F3)
#else
#define F3 (BaseReg->rF3)
#endif

#if defined(REG_F4) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgFloat,F4,REG_F4)
#else
#define F4 (BaseReg->rF4)
#endif

#if defined(REG_F5) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgFloat,F5,REG_F5)
#else
#define F5 (BaseReg->rF5)
#endif

#if defined(REG_F6) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgFloat,F6,REG_F6)
#else
#define F6 (BaseReg->rF6)
#endif

#if defined(REG_D1) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgDouble,D1,REG_D1)
#else
#define D1 (BaseReg->rD1)
#endif

#if defined(REG_D2) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgDouble,D2,REG_D2)
#else
#define D2 (BaseReg->rD2)
#endif

#if defined(REG_D3) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgDouble,D3,REG_D3)
#else
#define D3 (BaseReg->rD3)
#endif

#if defined(REG_D4) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgDouble,D4,REG_D4)
#else
#define D4 (BaseReg->rD4)
#endif

#if defined(REG_D5) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgDouble,D5,REG_D5)
#else
#define D5 (BaseReg->rD5)
#endif

#if defined(REG_D6) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgDouble,D6,REG_D6)
#else
#define D6 (BaseReg->rD6)
#endif

#if defined(REG_XMM1) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord128,XMM1,REG_XMM1)
#else
#define XMM1 (BaseReg->rXMM1)
#endif

#if defined(REG_XMM2) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord128,XMM2,REG_XMM2)
#else
#define XMM2 (BaseReg->rXMM2)
#endif

#if defined(REG_XMM3) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord128,XMM3,REG_XMM3)
#else
#define XMM3 (BaseReg->rXMM3)
#endif

#if defined(REG_XMM4) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord128,XMM4,REG_XMM4)
#else
#define XMM4 (BaseReg->rXMM4)
#endif

#if defined(REG_XMM5) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord128,XMM5,REG_XMM5)
#else
#define XMM5 (BaseReg->rXMM5)
#endif

#if defined(REG_XMM6) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord128,XMM6,REG_XMM6)
#else
#define XMM6 (BaseReg->rXMM6)
#endif

#if defined(REG_YMM1) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord256,YMM1,REG_YMM1)
#else
#define YMM1 (BaseReg->rYMM1)
#endif

#if defined(REG_YMM2) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord256,YMM2,REG_YMM2)
#else
#define YMM2 (BaseReg->rYMM2)
#endif

#if defined(REG_YMM3) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord256,YMM3,REG_YMM3)
#else
#define YMM3 (BaseReg->rYMM3)
#endif

#if defined(REG_YMM4) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord256,YMM4,REG_YMM4)
#else
#define YMM4 (BaseReg->rYMM4)
#endif

#if defined(REG_YMM5) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord256,YMM5,REG_YMM5)
#else
#define YMM5 (BaseReg->rYMM5)
#endif

#if defined(REG_YMM6) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord256,YMM6,REG_YMM6)
#else
#define YMM6 (BaseReg->rYMM6)
#endif

#if defined(REG_ZMM1) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord512,ZMM1,REG_ZMM1)
#else
#define ZMM1 (BaseReg->rZMM1)
#endif

#if defined(REG_ZMM2) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord512,ZMM2,REG_ZMM2)
#else
#define ZMM2 (BaseReg->rZMM2)
#endif

#if defined(REG_ZMM3) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord512,ZMM3,REG_ZMM3)
#else
#define ZMM3 (BaseReg->rZMM3)
#endif

#if defined(REG_ZMM4) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord512,ZMM4,REG_ZMM4)
#else
#define ZMM4 (BaseReg->rZMM4)
#endif

#if defined(REG_ZMM5) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord512,ZMM5,REG_ZMM5)
#else
#define ZMM5 (BaseReg->rZMM5)
#endif

#if defined(REG_ZMM6) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord512,ZMM6,REG_ZMM6)
#else
#define ZMM6 (BaseReg->rZMM6)
#endif

#if defined(REG_L1) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgWord64,L1,REG_L1)
#else
#define L1 (BaseReg->rL1)
#endif

/*
 * If BaseReg isn't mapped to a machine register, just use the global
 * address of the current register table (CurrentRegTable in
 * concurrent Haskell, MainRegTable otherwise).
 */

/* A capability is a combination of a FunTable and a RegTable.  In STG
 * code, BaseReg normally points to the RegTable portion of this
 * structure, so that we can index both forwards and backwards to take
 * advantage of shorter instruction forms on some archs (eg. x86).
 * This is a cut-down version of the Capability structure; the full
 * version is defined in Capability.h.
 */
struct PartCapability_ {
    StgFunTable f;
    StgRegTable r;
};

/* No such thing as a MainCapability under THREADED_RTS - each thread must have
 * its own Capability.
 */
#if IN_STG_CODE && !(defined(THREADED_RTS) && !defined(NOSMP))
extern W_ MainCapability[];
#endif

/*
 * Assigning to BaseReg (the ASSIGN_BaseReg macro): this happens on
 * return from a "safe" foreign call, when the thread might be running
 * on a new Capability.  Obviously if BaseReg is not a register, then
 * we are restricted to a single Capability (this invariant is enforced
 * in Capability.c:initCapabilities), and assigning to BaseReg can be omitted.
 */

#if defined(REG_Base) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(StgRegTable *,BaseReg,REG_Base)
#define ASSIGN_BaseReg(e) (BaseReg = (e))
#else
#if defined(THREADED_RTS) && !defined(NOSMP)
#error BaseReg must be in a register for THREADED_RTS
#endif
#define BaseReg (&((struct PartCapability_ *)MainCapability)->r)
#define ASSIGN_BaseReg(e) (e)
#endif

#if defined(REG_Sp) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(P_,Sp,REG_Sp)
#else
#define Sp (BaseReg->rSp)
#endif

#if defined(REG_SpLim) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(P_,SpLim,REG_SpLim)
#else
#define SpLim (BaseReg->rSpLim)
#endif

#if defined(REG_Hp) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(P_,Hp,REG_Hp)
#else
#define Hp (BaseReg->rHp)
#endif

#if defined(REG_HpLim) && !defined(NO_GLOBAL_REG_DECLS)
#error HpLim cannot be in a register
#else
#define HpLim (BaseReg->rHpLim)
#endif

#if defined(REG_CCCS) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(struct CostCentreStack_ *,CCCS,REG_CCCS)
#else
#define CCCS (BaseReg->rCCCS)
#endif

#if defined(REG_CurrentTSO) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(struct _StgTSO *,CurrentTSO,REG_CurrentTSO)
#else
#define CurrentTSO (BaseReg->rCurrentTSO)
#endif

#if defined(REG_CurrentNursery) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(bdescr *,CurrentNursery,REG_CurrentNursery)
#else
#define CurrentNursery (BaseReg->rCurrentNursery)
#endif

#if defined(REG_HpAlloc) && !defined(NO_GLOBAL_REG_DECLS)
GLOBAL_REG_DECL(bdescr *,HpAlloc,REG_HpAlloc)
#else
#define HpAlloc (BaseReg->rHpAlloc)
#endif

/* -----------------------------------------------------------------------------
   Get absolute function pointers from the register table, to save
   code space.  On x86,

       jmp  *-12(%ebx)

   is shorter than

       jmp absolute_address

   as long as the offset is within the range of a signed byte
   (-128..+127).  So we pick some common absolute_addresses and put
   them in the register table.  As a bonus, linking time should also
   be reduced.

   Other possible candidates in order of importance:

     stg_upd_frame_info
     stg_CAF_BLACKHOLE_info
     stg_IND_STATIC_info

   anything else probably isn't worth the effort.

   -------------------------------------------------------------------------- */


#define FunReg ((StgFunTable *)((void *)BaseReg - STG_FIELD_OFFSET(struct PartCapability_, r)))

#define stg_EAGER_BLACKHOLE_info  (FunReg->stgEagerBlackholeInfo)
#define stg_gc_enter_1            (FunReg->stgGCEnter1)
#define stg_gc_fun                (FunReg->stgGCFun)

#endif /* IN_STG_CODE */

#endif /* REGS_H */
{-# START_FILE include/ghc-8.0.2/stg/RtsMachRegs.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2011
 *
 * Registers used in STG code.  Might or might not correspond to
 * actual machine registers.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef RTSMACHREGS_H
#define RTSMACHREGS_H

#ifdef UnregisterisedCompiler
#ifndef NO_REGS
#define NO_REGS
#endif
#endif

/*
 * Defining NO_REGS causes no global registers to be used.  NO_REGS is
 * typically defined by GHC, via a command-line option passed to gcc,
 * when the -funregisterised flag is given.
 *
 * NB. When NO_REGS is on, calling & return conventions may be
 * different.  For example, all function arguments will be passed on
 * the stack, and components of an unboxed tuple will be returned on
 * the stack rather than in registers.
 */
#ifdef NO_REGS

#define MACHREGS_NO_REGS 1

#else

#define MACHREGS_NO_REGS 0

#define MACHREGS_i386     i386_HOST_ARCH
#define MACHREGS_x86_64   x86_64_HOST_ARCH
#define MACHREGS_powerpc  (powerpc_HOST_ARCH || powerpc64_HOST_ARCH \
        || powerpc64le_HOST_ARCH || rs6000_HOST_ARCH)
#define MACHREGS_sparc    sparc_HOST_ARCH
#define MACHREGS_arm      arm_HOST_ARCH
#define MACHREGS_aarch64  aarch64_HOST_ARCH
#define MACHREGS_darwin   darwin_HOST_OS

#endif

#include "MachRegs.h"

#endif /* RTSMACHREGS_H */
{-# START_FILE include/ghc-8.0.2/stg/SMP.h #-}
/* ----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2005-2011
 *
 * Macros for multi-CPU support
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * -------------------------------------------------------------------------- */

#ifndef SMP_H
#define SMP_H

#if arm_HOST_ARCH && defined(arm_HOST_ARCH_PRE_ARMv6)
void arm_atomic_spin_lock(void);
void arm_atomic_spin_unlock(void);
#endif

#if defined(THREADED_RTS)

/* ----------------------------------------------------------------------------
   Atomic operations
   ------------------------------------------------------------------------- */

#if !IN_STG_CODE || IN_STGCRUN
// We only want the barriers, e.g. write_barrier(), declared in .hc
// files.  Defining the other inline functions here causes type
// mismatch errors from gcc, because the generated C code is assuming
// that there are no prototypes in scope.

/*
 * The atomic exchange operation: xchg(p,w) exchanges the value
 * pointed to by p with the value w, returning the old value.
 *
 * Used for locking closures during updates (see lockClosure() below)
 * and the MVar primops.
 */
EXTERN_INLINE StgWord xchg(StgPtr p, StgWord w);

/*
 * Compare-and-swap.  Atomically does this:
 *
 * cas(p,o,n) {
 *    r = *p;
 *    if (r == o) { *p = n };
 *    return r;
 * }
 */
EXTERN_INLINE StgWord cas(StgVolatilePtr p, StgWord o, StgWord n);

/*
 * Atomic addition by the provided quantity
 *
 * atomic_inc(p, n) {
 *   return ((*p) += n);
 * }
 */
EXTERN_INLINE StgWord atomic_inc(StgVolatilePtr p, StgWord n);


/*
 * Atomic decrement
 *
 * atomic_dec(p) {
 *   return --(*p);
 * }
 */
EXTERN_INLINE StgWord atomic_dec(StgVolatilePtr p);

/*
 * Busy-wait nop: this is a hint to the CPU that we are currently in a
 * busy-wait loop waiting for another CPU to change something.  On a
 * hypertreaded CPU it should yield to another thread, for example.
 */
EXTERN_INLINE void busy_wait_nop(void);

#endif // !IN_STG_CODE

/*
 * Various kinds of memory barrier.
 *  write_barrier: prevents future stores occurring before prededing stores.
 *  store_load_barrier: prevents future loads occurring before preceding stores.
 *  load_load_barrier: prevents future loads occurring before earlier stores.
 *
 * Reference for these: "The JSR-133 Cookbook for Compiler Writers"
 * http://gee.cs.oswego.edu/dl/jmm/cookbook.html
 *
 * To check whether you got these right, try the test in
 *   testsuite/tests/rts/testwsdeque.c
 * This tests the work-stealing deque implementation, which relies on
 * properly working store_load and load_load memory barriers.
 */
EXTERN_INLINE void write_barrier(void);
EXTERN_INLINE void store_load_barrier(void);
EXTERN_INLINE void load_load_barrier(void);

/* ----------------------------------------------------------------------------
   Implementations
   ------------------------------------------------------------------------- */

#if !IN_STG_CODE || IN_STGCRUN

EXTERN_INLINE StgWord
xchg(StgPtr p, StgWord w)
{
    StgWord result;
#if defined(NOSMP)
    result = *p;
    *p = w;
#elif i386_HOST_ARCH || x86_64_HOST_ARCH
    result = w;
    __asm__ __volatile__ (
        // NB: the xchg instruction is implicitly locked, so we do not
        // need a lock prefix here.
          "xchg %1,%0"
          :"+r" (result), "+m" (*p)
          : /* no input-only operands */
        );
#elif powerpc_HOST_ARCH || powerpc64_HOST_ARCH || powerpc64le_HOST_ARCH
    result = __sync_lock_test_and_set(p, w);
#elif sparc_HOST_ARCH
    result = w;
    __asm__ __volatile__ (
        "swap %1,%0"
        : "+r" (result), "+m" (*p)
        : /* no input-only operands */
      );
#elif arm_HOST_ARCH && defined(arm_HOST_ARCH_PRE_ARMv6)
    __asm__ __volatile__ ("swp %0, %1, [%2]"
                         : "=&r" (result)
                         : "r" (w), "r" (p) : "memory");
#elif arm_HOST_ARCH && !defined(arm_HOST_ARCH_PRE_ARMv6)
    // swp instruction which is used in pre-ARMv6 code above
    // is deprecated in AMRv6 and later. ARM, Ltd. *highly* recommends
    // to use ldrex/strex instruction pair for the same purpose
    // see chapter: Synchronization and semaphores in ARM Architecture
    // Reference manual
    StgWord tmp;
    __asm__ __volatile__ (
                          "1:    ldrex  %0, [%3]\n"
                          "      strex  %1, %2, [%3]\n"
                          "      teq    %1, #1\n"
                          "      beq    1b\n"
#if !defined(arm_HOST_ARCH_PRE_ARMv7)
                          "      dmb\n"
#endif
                          : "=&r" (result), "=&r" (tmp)
                          : "r" (w), "r" (p)
                          : "memory"
                          );
#elif aarch64_HOST_ARCH
    StgWord tmp; 
    __asm__ __volatile__ (
                          "1:    ldaxr  %0, [%3]\n"
                          "      stlxr  %w1, %2, [%3]\n"
                          "      cbnz   %w1, 1b\n"
                          "      dmb sy\n"
                          : "=&r" (result), "=&r" (tmp)
                          : "r" (w), "r" (p)
                          : "memory"
                          );
#else
#error xchg() unimplemented on this architecture
#endif
    return result;
}

/*
 * CMPXCHG - the single-word atomic compare-and-exchange instruction.  Used
 * in the STM implementation.
 */
EXTERN_INLINE StgWord
cas(StgVolatilePtr p, StgWord o, StgWord n)
{
#if defined(NOSMP)
    StgWord result;
    result = *p;
    if (result == o) {
        *p = n;
    }
    return result;
#elif i386_HOST_ARCH || x86_64_HOST_ARCH
    __asm__ __volatile__ (
          "lock\ncmpxchg %3,%1"
          :"=a"(o), "+m" (*(volatile unsigned int *)p)
          :"0" (o), "r" (n));
    return o;
#elif powerpc_HOST_ARCH || powerpc64_HOST_ARCH || powerpc64le_HOST_ARCH
    return __sync_val_compare_and_swap(p, o, n);
#elif sparc_HOST_ARCH
    __asm__ __volatile__ (
        "cas [%1], %2, %0"
        : "+r" (n)
        : "r" (p), "r" (o)
        : "memory"
    );
    return n;
#elif arm_HOST_ARCH && defined(arm_HOST_ARCH_PRE_ARMv6)
    StgWord r;
    arm_atomic_spin_lock();
    r  = *p;
    if (r == o) { *p = n; }
    arm_atomic_spin_unlock();
    return r;
#elif arm_HOST_ARCH && !defined(arm_HOST_ARCH_PRE_ARMv6)
    StgWord result,tmp;

    __asm__ __volatile__(
        "1:     ldrex   %1, [%2]\n"
        "       mov     %0, #0\n"
        "       teq     %1, %3\n"
        "       it      eq\n"
        "       strexeq %0, %4, [%2]\n"
        "       teq     %0, #1\n"
        "       it      eq\n"
        "       beq     1b\n"
#if !defined(arm_HOST_ARCH_PRE_ARMv7)
        "       dmb\n"
#endif
                : "=&r"(tmp), "=&r"(result)
                : "r"(p), "r"(o), "r"(n)
                : "cc","memory");

    return result;
#elif aarch64_HOST_ARCH
    // Don't think we actually use tmp here, but leaving
    // it for consistent numbering
    StgWord result,tmp;

    __asm__ __volatile__(
        "1:     ldxr %1, [%2]\n"
        "       mov %w0, #0\n"
        "       cmp %1, %3\n"
        "       b.ne 2f\n"
        "       stxr %w0, %4, [%2]\n"
        "       cbnz %w0, 1b\n"
        "2:     dmb sy\n"
                : "=&r"(tmp), "=&r"(result)
                : "r"(p), "r"(o), "r"(n)
                : "cc","memory");

    return result;
#else
#error cas() unimplemented on this architecture
#endif
}

// RRN: Generalized to arbitrary increments to enable fetch-and-add in
// Haskell code (fetchAddIntArray#).
// PT: add-and-fetch, returns new value
EXTERN_INLINE StgWord
atomic_inc(StgVolatilePtr p, StgWord incr)
{
#if defined(i386_HOST_ARCH) || defined(x86_64_HOST_ARCH)
    StgWord r;
    r = incr;
    __asm__ __volatile__ (
        "lock\nxadd %0,%1":
            "+r" (r), "+m" (*p):
    );
    return r + incr;
#elif powerpc_HOST_ARCH || powerpc64_HOST_ARCH || powerpc64le_HOST_ARCH
    return __sync_add_and_fetch(p, incr);
#else
    StgWord old, new_;
    do {
        old = *p;
        new_ = old + incr;
    } while (cas(p, old, new_) != old);
    return new_;
#endif
}

EXTERN_INLINE StgWord
atomic_dec(StgVolatilePtr p)
{
#if defined(i386_HOST_ARCH) || defined(x86_64_HOST_ARCH)
    StgWord r;
    r = (StgWord)-1;
    __asm__ __volatile__ (
        "lock\nxadd %0,%1":
            "+r" (r), "+m" (*p):
    );
    return r-1;
#elif powerpc_HOST_ARCH || powerpc64_HOST_ARCH || powerpc64le_HOST_ARCH
    return __sync_sub_and_fetch(p, (StgWord) 1);
#else
    StgWord old, new_;
    do {
        old = *p;
        new_ = old - 1;
    } while (cas(p, old, new_) != old);
    return new_;
#endif
}

/*
 * Some architectures have a way to tell the CPU that we're in a
 * busy-wait loop, and the processor should look for something else to
 * do (such as run another hardware thread).
 */
EXTERN_INLINE void
busy_wait_nop(void)
{
#if defined(i386_HOST_ARCH) || defined(x86_64_HOST_ARCH)
    // On Intel, the busy-wait-nop instruction is called "pause",
    // which is actually represented as a nop with the rep prefix.
    // On processors before the P4 this behaves as a nop; on P4 and
    // later it might do something clever like yield to another
    // hyperthread.  In any case, Intel recommends putting one
    // of these in a spin lock loop.
    __asm__ __volatile__ ("rep; nop");
#else
    // nothing
#endif
}

#endif // !IN_STG_CODE

/*
 * We need to tell both the compiler AND the CPU about the barriers.
 * It's no good preventing the CPU from reordering the operations if
 * the compiler has already done so - hence the "memory" restriction
 * on each of the barriers below.
 */
EXTERN_INLINE void
write_barrier(void) {
#if defined(NOSMP)
    return;
#elif i386_HOST_ARCH || x86_64_HOST_ARCH
    __asm__ __volatile__ ("" : : : "memory");
#elif powerpc_HOST_ARCH || powerpc64_HOST_ARCH || powerpc64le_HOST_ARCH
    __asm__ __volatile__ ("lwsync" : : : "memory");
#elif sparc_HOST_ARCH
    /* Sparc in TSO mode does not require store/store barriers. */
    __asm__ __volatile__ ("" : : : "memory");
#elif (arm_HOST_ARCH) || aarch64_HOST_ARCH
    __asm__ __volatile__ ("dmb  st" : : : "memory");
#else
#error memory barriers unimplemented on this architecture
#endif
}

EXTERN_INLINE void
store_load_barrier(void) {
#if defined(NOSMP)
    return;
#elif i386_HOST_ARCH
    __asm__ __volatile__ ("lock; addl $0,0(%%esp)" : : : "memory");
#elif x86_64_HOST_ARCH
    __asm__ __volatile__ ("lock; addq $0,0(%%rsp)" : : : "memory");
#elif powerpc_HOST_ARCH || powerpc64_HOST_ARCH || powerpc64le_HOST_ARCH
    __asm__ __volatile__ ("sync" : : : "memory");
#elif sparc_HOST_ARCH
    __asm__ __volatile__ ("membar #StoreLoad" : : : "memory");
#elif arm_HOST_ARCH
    __asm__ __volatile__ ("dmb" : : : "memory");
#elif aarch64_HOST_ARCH
    __asm__ __volatile__ ("dmb sy" : : : "memory");
#else
#error memory barriers unimplemented on this architecture
#endif
}

EXTERN_INLINE void
load_load_barrier(void) {
#if defined(NOSMP)
    return;
#elif i386_HOST_ARCH
    __asm__ __volatile__ ("" : : : "memory");
#elif x86_64_HOST_ARCH
    __asm__ __volatile__ ("" : : : "memory");
#elif powerpc_HOST_ARCH || powerpc64_HOST_ARCH || powerpc64le_HOST_ARCH
    __asm__ __volatile__ ("lwsync" : : : "memory");
#elif sparc_HOST_ARCH
    /* Sparc in TSO mode does not require load/load barriers. */
    __asm__ __volatile__ ("" : : : "memory");
#elif arm_HOST_ARCH
    __asm__ __volatile__ ("dmb" : : : "memory");
#elif aarch64_HOST_ARCH
    __asm__ __volatile__ ("dmb sy" : : : "memory");
#else
#error memory barriers unimplemented on this architecture
#endif
}

// Load a pointer from a memory location that might be being modified
// concurrently.  This prevents the compiler from optimising away
// multiple loads of the memory location, as it might otherwise do in
// a busy wait loop for example.
#define VOLATILE_LOAD(p) (*((StgVolatilePtr)(p)))

/* ---------------------------------------------------------------------- */
#else /* !THREADED_RTS */

EXTERN_INLINE void write_barrier(void);
EXTERN_INLINE void store_load_barrier(void);
EXTERN_INLINE void load_load_barrier(void);
EXTERN_INLINE void write_barrier     () {} /* nothing */
EXTERN_INLINE void store_load_barrier() {} /* nothing */
EXTERN_INLINE void load_load_barrier () {} /* nothing */

#if !IN_STG_CODE || IN_STGCRUN
INLINE_HEADER StgWord
xchg(StgPtr p, StgWord w)
{
    StgWord old = *p;
    *p = w;
    return old;
}

EXTERN_INLINE StgWord cas(StgVolatilePtr p, StgWord o, StgWord n);
EXTERN_INLINE StgWord
cas(StgVolatilePtr p, StgWord o, StgWord n)
{
    StgWord result;
    result = *p;
    if (result == o) {
        *p = n;
    }
    return result;
}

EXTERN_INLINE StgWord atomic_inc(StgVolatilePtr p, StgWord incr);
EXTERN_INLINE StgWord
atomic_inc(StgVolatilePtr p, StgWord incr)
{
    return ((*p) += incr);
}


INLINE_HEADER StgWord
atomic_dec(StgVolatilePtr p)
{
    return --(*p);
}
#endif

#define VOLATILE_LOAD(p) ((StgWord)*((StgWord*)(p)))

#endif /* !THREADED_RTS */

#endif /* SMP_H */
{-# START_FILE include/ghc-8.0.2/stg/Ticky.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 2009
 *
 * Declarations for counters used by ticky-ticky profiling.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * -------------------------------------------------------------------------- */

#ifndef TICKYCOUNTERS_H
#define TICKYCOUNTERS_H

/* These should probably be automatically generated in order to
   keep them consistent with the macros that use them (which are
   defined in Cmm.h) */

/* Here are all the counter declarations: */
/* If you change this list, make the corresponding change
   in RTS_TICKY_SYMBOLS in rts/Linker.c  */

/* These two are explicitly declared in rts/Ticky.c, and
   hence should not be extern'd except when using this header
   file from STG code; hence IN_STG_CODE */

#if IN_STG_CODE
extern W_ ticky_entry_ctrs[];
extern W_ top_ct[];
#endif

/* The rest are not explicity declared in rts/Ticky.c.  Instead
   we use the same trick as in the former StgTicky.h: recycle the 
   same declarations for both extern decls (which are included everywhere)
   and initializations (which only happen once) 
   TICKY_C is defined only in rts/Ticky.c */
#ifdef TICKY_C
#define INIT(ializer) = ializer
#define EXTERN
#else
#define INIT(ializer)
#define EXTERN extern
#endif

EXTERN StgInt ENT_VIA_NODE_ctr INIT(0);
EXTERN StgInt ENT_STATIC_THK_SINGLE_ctr INIT(0);
EXTERN StgInt ENT_DYN_THK_SINGLE_ctr INIT(0);
EXTERN StgInt ENT_STATIC_THK_MANY_ctr INIT(0);
EXTERN StgInt ENT_DYN_THK_MANY_ctr INIT(0);
EXTERN StgInt ENT_STATIC_FUN_DIRECT_ctr INIT(0);
EXTERN StgInt ENT_DYN_FUN_DIRECT_ctr INIT(0);
EXTERN StgInt ENT_STATIC_CON_ctr INIT(0);
EXTERN StgInt ENT_DYN_CON_ctr INIT(0);
EXTERN StgInt ENT_STATIC_IND_ctr INIT(0);
EXTERN StgInt ENT_DYN_IND_ctr INIT(0);
EXTERN StgInt ENT_PERM_IND_ctr INIT(0);
EXTERN StgInt ENT_PAP_ctr INIT(0);
EXTERN StgInt ENT_AP_ctr INIT(0);
EXTERN StgInt ENT_AP_STACK_ctr INIT(0);
EXTERN StgInt ENT_BH_ctr INIT(0);
EXTERN StgInt ENT_LNE_ctr INIT(0);

EXTERN StgInt UNKNOWN_CALL_ctr INIT(0);

EXTERN StgInt SLOW_CALL_fast_v16_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_v_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_f_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_d_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_l_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_n_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_p_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_pv_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_pp_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_ppv_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_ppp_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_pppv_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_pppp_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_ppppp_ctr INIT(0);
EXTERN StgInt SLOW_CALL_fast_pppppp_ctr INIT(0);
EXTERN StgInt VERY_SLOW_CALL_ctr INIT(0);

EXTERN StgInt ticky_slow_call_unevald;
EXTERN StgInt SLOW_CALL_ctr INIT(0);
EXTERN StgInt MULTI_CHUNK_SLOW_CALL_ctr INIT(0);
EXTERN StgInt MULTI_CHUNK_SLOW_CALL_CHUNKS_ctr INIT(0);
EXTERN StgInt KNOWN_CALL_ctr INIT(0);
EXTERN StgInt KNOWN_CALL_TOO_FEW_ARGS_ctr INIT(0);
EXTERN StgInt KNOWN_CALL_EXTRA_ARGS_ctr INIT(0);
EXTERN StgInt SLOW_CALL_FUN_TOO_FEW_ctr INIT(0);
EXTERN StgInt SLOW_CALL_FUN_CORRECT_ctr INIT(0);
EXTERN StgInt SLOW_CALL_FUN_TOO_MANY_ctr INIT(0);
EXTERN StgInt SLOW_CALL_PAP_TOO_FEW_ctr INIT(0);
EXTERN StgInt SLOW_CALL_PAP_CORRECT_ctr INIT(0);
EXTERN StgInt SLOW_CALL_PAP_TOO_MANY_ctr INIT(0);
EXTERN StgInt SLOW_CALL_UNEVALD_ctr INIT(0);


EXTERN StgInt UPDF_OMITTED_ctr INIT(0);
EXTERN StgInt UPDF_PUSHED_ctr INIT(0);
EXTERN StgInt CATCHF_PUSHED_ctr INIT(0);
EXTERN StgInt UPDF_RCC_PUSHED_ctr INIT(0);
EXTERN StgInt UPDF_RCC_OMITTED_ctr INIT(0);

EXTERN StgInt UPD_SQUEEZED_ctr INIT(0);
EXTERN StgInt UPD_CON_IN_NEW_ctr INIT(0);
EXTERN StgInt UPD_CON_IN_PLACE_ctr INIT(0);
EXTERN StgInt UPD_PAP_IN_NEW_ctr INIT(0);
EXTERN StgInt UPD_PAP_IN_PLACE_ctr INIT(0);

EXTERN StgInt ALLOC_HEAP_ctr INIT(0);
EXTERN StgInt ALLOC_HEAP_tot INIT(0);

EXTERN StgInt HEAP_CHK_ctr INIT(0);
EXTERN StgInt STK_CHK_ctr INIT(0);

EXTERN StgInt ALLOC_RTS_ctr INIT(0);
EXTERN StgInt ALLOC_RTS_tot INIT(0);

EXTERN StgInt ALLOC_FUN_ctr INIT(0);
EXTERN StgInt ALLOC_FUN_adm INIT(0);
EXTERN StgInt ALLOC_FUN_gds INIT(0);
EXTERN StgInt ALLOC_FUN_slp INIT(0);

EXTERN StgInt UPD_NEW_IND_ctr INIT(0);
EXTERN StgInt UPD_NEW_PERM_IND_ctr INIT(0);
EXTERN StgInt UPD_OLD_IND_ctr INIT(0);
EXTERN StgInt UPD_OLD_PERM_IND_ctr INIT(0);

EXTERN StgInt UPD_BH_UPDATABLE_ctr INIT(0);
EXTERN StgInt UPD_CAF_BH_UPDATABLE_ctr INIT(0);
EXTERN StgInt UPD_CAF_BH_SINGLE_ENTRY_ctr INIT(0);

EXTERN StgInt GC_SEL_ABANDONED_ctr INIT(0);
EXTERN StgInt GC_SEL_MINOR_ctr INIT(0);
EXTERN StgInt GC_SEL_MAJOR_ctr INIT(0);

EXTERN StgInt GC_FAILED_PROMOTION_ctr INIT(0);

EXTERN StgInt ALLOC_UP_THK_ctr INIT(0);
EXTERN StgInt ALLOC_SE_THK_ctr INIT(0);
EXTERN StgInt ALLOC_THK_adm INIT(0);
EXTERN StgInt ALLOC_THK_gds INIT(0);
EXTERN StgInt ALLOC_THK_slp INIT(0);

EXTERN StgInt ALLOC_CON_ctr INIT(0);
EXTERN StgInt ALLOC_CON_adm INIT(0);
EXTERN StgInt ALLOC_CON_gds INIT(0);
EXTERN StgInt ALLOC_CON_slp INIT(0);

EXTERN StgInt ALLOC_TUP_ctr INIT(0);
EXTERN StgInt ALLOC_TUP_adm INIT(0);
EXTERN StgInt ALLOC_TUP_gds INIT(0);
EXTERN StgInt ALLOC_TUP_slp INIT(0);

EXTERN StgInt ALLOC_BH_ctr INIT(0);
EXTERN StgInt ALLOC_BH_adm INIT(0);
EXTERN StgInt ALLOC_BH_gds INIT(0);
EXTERN StgInt ALLOC_BH_slp INIT(0);

EXTERN StgInt ALLOC_PRIM_ctr INIT(0);
EXTERN StgInt ALLOC_PRIM_adm INIT(0);
EXTERN StgInt ALLOC_PRIM_gds INIT(0);
EXTERN StgInt ALLOC_PRIM_slp INIT(0);

EXTERN StgInt ALLOC_PAP_ctr INIT(0);
EXTERN StgInt ALLOC_PAP_adm INIT(0);
EXTERN StgInt ALLOC_PAP_gds INIT(0);
EXTERN StgInt ALLOC_PAP_slp INIT(0);

EXTERN StgInt ALLOC_TSO_ctr INIT(0);
EXTERN StgInt ALLOC_TSO_adm INIT(0);
EXTERN StgInt ALLOC_TSO_gds INIT(0);
EXTERN StgInt ALLOC_TSO_slp INIT(0);

EXTERN StgInt RET_NEW_ctr INIT(0);
EXTERN StgInt RET_OLD_ctr INIT(0);
EXTERN StgInt RET_UNBOXED_TUP_ctr INIT(0);

EXTERN StgInt RET_SEMI_loads_avoided INIT(0);
/* End of counter declarations. */

/* How many bins in ticky's histograms */
#define TICKY_BIN_COUNT 9

/* Histogram declarations */
EXTERN StgInt RET_NEW_hst[TICKY_BIN_COUNT] INIT({0});
EXTERN StgInt RET_OLD_hst[TICKY_BIN_COUNT] INIT({0});
EXTERN StgInt RET_UNBOXED_TUP_hst[TICKY_BIN_COUNT] INIT({0});
/* End of histogram declarations */

/* This is ugly, but the story is:
   We got rid of StgTicky.h, which was previously
   defining these macros for the benefit of C code
   so, we define them here instead (to be no-ops).
   (since those macros are only defined in Cmm.h) 

   Note that these macros must be defined whether
   TICKY_TICKY is defined or not. */
  
#ifndef CMINUSMINUS
#define TICK_BUMP_BY(ctr,n) ctr = (StgInt) ctr + n
#define TICK_BUMP(ctr)      TICK_BUMP_BY(ctr,1)

#define TICK_ALLOC_PRIM(x,y,z)
#define TICK_UPD_OLD_IND()
#define TICK_UPD_NEW_IND()
#define TICK_UPD_SQUEEZED()
#define TICK_ALLOC_HEAP_NOCTR(bytes)
#define TICK_GC_FAILED_PROMOTION()
#define TICK_ALLOC_TSO()
#define TICK_ALLOC_STACK(g)
#define TICK_ALLOC_UP_THK(g,s)
#define TICK_ALLOC_SE_THK(g,s)

#endif


#endif /* TICKYCOUNTERS_H */
{-# START_FILE include/ghc-8.0.2/stg/Types.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2004
 *
 * Various C datatypes used in the run-time system.  This is the
 * lowest-level include file, after ghcconfig.h and RtsConfig.h.
 *
 * Do not #include this file directly: #include "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * NOTE: assumes #include "ghcconfig.h"
 *
 * Works with or without _POSIX_SOURCE.
 *
 * WARNING: Keep this file, MachDeps.h, and HsFFI.h in synch!
 *
 * ---------------------------------------------------------------------------*/

#ifndef STGTYPES_H
#define STGTYPES_H

/*
 * This module should define types *only*, all beginning with "Stg".
 *
 * Specifically:

        StgInt8,  16, 32, 64
        StgWord8, 16, 32, 64
        StgChar, StgFloat, StgDouble

        ***** All the same size (i.e. sizeof(void *)): *****
        StgPtr                  Basic pointer type
        StgWord                 Unit of heap allocation
        StgInt                  Signed version of StgWord
        StgAddr                 Generic address type

        StgBool, StgVoid, StgPtr, StgOffset,
        StgCode, StgStablePtr, StgFunPtr,
        StgUnion.
 */

/*
 * First, platform-dependent definitions of size-specific integers.
 */

typedef signed   char            StgInt8;
typedef unsigned char            StgWord8;

typedef signed   short           StgInt16;
typedef unsigned short           StgWord16;

#if SIZEOF_INT == 4
typedef signed   int             StgInt32;
typedef unsigned int             StgWord32;
#define FMT_Word32    "u"
#define FMT_HexWord32 "x"
#define FMT_Int32     "d"
#elif SIZEOF_LONG == 4
typedef signed   long            StgInt32;
typedef unsigned long            StgWord32;
#define FMT_Word32    "lu"
#define FMT_HexWord32 "lx"
#define FMT_Int32     "ld"
#else
#error GHC untested on this architecture: sizeof(int) != 4
#endif

#if SIZEOF_LONG == 8
typedef signed   long          StgInt64;
typedef unsigned long          StgWord64;
#define FMT_Word64    "lu"
#define FMT_HexWord64 "lx"
#define FMT_Int64     "ld"
#elif SIZEOF_LONG_LONG == 8
typedef signed long long int   StgInt64;
typedef unsigned long long int StgWord64;
#define FMT_Word64    "llu"
#define FMT_HexWord64 "llx"
#define FMT_Int64     "lld"
#else
#error cannot find a way to define StgInt64
#endif

typedef struct { StgWord64 h; StgWord64 l; } StgWord128;

typedef struct { StgWord128 h; StgWord128 l; } StgWord256;

typedef struct { StgWord256 h; StgWord256 l; } StgWord512;

/*
 * Define the standard word size we'll use on this machine: make it
 * big enough to hold a pointer.
 */

#if SIZEOF_VOID_P == 8
typedef StgInt64           StgInt;
typedef StgWord64          StgWord;
typedef StgInt32           StgHalfInt;
typedef StgWord32          StgHalfWord;
#define FMT_Word     FMT_Word64
#define FMT_HexWord  FMT_HexWord64
#define FMT_Int      FMT_Int64
#define strToStgWord       strtoull
#else
#if SIZEOF_VOID_P == 4
typedef StgInt32           StgInt;
typedef StgWord32          StgWord;
typedef StgInt16           StgHalfInt;
typedef StgWord16          StgHalfWord;
#define FMT_Word     FMT_Word32
#define FMT_HexWord  FMT_HexWord32
#define FMT_Int      FMT_Int32
#define strToStgWord       strtoul
#else
#error GHC untested on this architecture: sizeof(void *) != 4 or 8
#endif
#endif

#define W_MASK  (sizeof(W_)-1)

/*
 * Other commonly-used STG datatypes.
 */

typedef void*              StgAddr;
typedef StgWord32          StgChar;
typedef int                StgBool;
typedef float              StgFloat;
typedef double             StgDouble;
typedef StgWord*           StgPtr;           /* heap or stack pointer */
typedef StgWord volatile*  StgVolatilePtr;   /* pointer to volatile word   */
typedef StgWord            StgOffset;        /* byte offset within closure */
typedef StgWord8           StgCode;          /* close enough */
typedef void*              StgStablePtr;
typedef StgWord8*          StgByteArray;

/*
  Types for generated C functions when compiling via C.

  The C functions take no arguments, and return a pointer to the next
  function to be called use: Ptr to Fun that returns a Ptr to Fun
  which returns Ptr to void

  Note: Neither StgFunPtr not StgFun is quite right (that is,
  StgFunPtr != StgFun*).  So, the functions we define all have type
  StgFun but we always have to cast them to StgFunPtr when we assign
  them to something.
  The only way round this would be to write a recursive type but
  C only allows that if you're defining a struct or union.
*/

typedef void  *(*(*StgFunPtr)(void))(void);
typedef StgFunPtr StgFun(void);

#endif /* STGTYPES_H */
{-# START_FILE include/ghc-8.0.2/Stg.h #-}
/* -----------------------------------------------------------------------------
 *
 * (c) The GHC Team, 1998-2009
 *
 * Top-level include file for everything required when compiling .hc
 * code.  NOTE: in .hc files, Stg.h must be included *before* any
 * other headers, because we define some register variables which must
 * be done before any inline functions are defined (some system
 * headers have been known to define the odd inline function).
 *
 * We generally try to keep as little visible as possible when
 * compiling .hc files.  So for example the definitions of the
 * InfoTable structs, closure structs and other RTS types are not
 * visible here.  The compiler knows enough about the representations
 * of these types to generate code which manipulates them directly
 * with pointer arithmetic.
 *
 * In ordinary C code, do not #include this file directly: #include
 * "Rts.h" instead.
 *
 * To understand the structure of the RTS headers, see the wiki:
 *   http://ghc.haskell.org/trac/ghc/wiki/Commentary/SourceTree/Includes
 *
 * ---------------------------------------------------------------------------*/

#ifndef STG_H
#define STG_H

/*
 * If we are compiling a .hc file, then we want all the register
 * variables.  This is the what happens if you #include "Stg.h" first:
 * we assume this is a .hc file, and set IN_STG_CODE==1, which later
 * causes the register variables to be enabled in stg/Regs.h.
 *
 * If instead "Rts.h" is included first, then we are compiling a
 * vanilla C file.  Everything from Stg.h is provided, except that
 * IN_STG_CODE is not defined, and the register variables will not be
 * active.
 */
#ifndef IN_STG_CODE
# define IN_STG_CODE 1

// Turn on C99 for .hc code.  This gives us the INFINITY and NAN
// constants from math.h, which we occasionally need to use in .hc (#1861)
# define _ISOC99_SOURCE

// We need _BSD_SOURCE so that math.h defines things like gamma
// on Linux
# define _BSD_SOURCE

// On AIX we need _BSD defined, otherwise <math.h> includes <stdlib.h>
# if defined(_AIX)
#  define _BSD 1
# endif

// '_BSD_SOURCE' is deprecated since glibc-2.20
// in favour of '_DEFAULT_SOURCE'
# define _DEFAULT_SOURCE
#endif

#if IN_STG_CODE == 0 || defined(llvm_CC_FLAVOR)
// C compilers that use an LLVM back end (clang or llvm-gcc) do not
// correctly support global register variables so we make sure that
// we do not declare them for these compilers.
# define NO_GLOBAL_REG_DECLS    /* don't define fixed registers */
#endif

/* Configuration */
#include "ghcconfig.h"

/* The code generator calls the math functions directly in .hc code.
   NB. after configuration stuff above, because this sets #defines
   that depend on config info, such as __USE_FILE_OFFSET64 */
#include <math.h>

// On Solaris, we don't get the INFINITY and NAN constants unless we
// #define _STDC_C99, and we can't do that unless we also use -std=c99,
// because _STDC_C99 causes the headers to use C99 syntax (e.g. restrict).
// We aren't ready for -std=c99 yet, so define INFINITY/NAN by hand using
// the gcc builtins.
#if !defined(INFINITY)
#if defined(__GNUC__)
#define INFINITY __builtin_inf()
#else
#error No definition for INFINITY
#endif
#endif

#if !defined(NAN)
#if defined(__GNUC__)
#define NAN __builtin_nan("")
#else
#error No definition for NAN
#endif
#endif

/* -----------------------------------------------------------------------------
   Useful definitions
   -------------------------------------------------------------------------- */

/*
 * The C backend likes to refer to labels by just mentioning their
 * names.  However, when a symbol is declared as a variable in C, the
 * C compiler will implicitly dereference it when it occurs in source.
 * So we must subvert this behaviour for .hc files by declaring
 * variables as arrays, which eliminates the implicit dereference.
 */
#if IN_STG_CODE
#define RTS_VAR(x) (x)[]
#define RTS_DEREF(x) (*(x))
#else
#define RTS_VAR(x) x
#define RTS_DEREF(x) x
#endif

/* bit macros
 */
#define BITS_PER_BYTE 8
#define BITS_IN(x) (BITS_PER_BYTE * sizeof(x))

/* Compute offsets of struct fields
 */
#define STG_FIELD_OFFSET(s_type, field) ((StgWord)&(((s_type*)0)->field))

/*
 * 'Portable' inlining:
 * INLINE_HEADER is for inline functions in header files (macros)
 * STATIC_INLINE is for inline functions in source files
 * EXTERN_INLINE is for functions that we want to inline sometimes
 * (we also compile a static version of the function; see Inlines.c)
 */

// We generally assume C99 semantics albeit these two definitions work fine even
// when gnu90 semantics are active (i.e. when __GNUC_GNU_INLINE__ is defined or
// when a GCC older than 4.2 is used)
//
// The problem, however, is with 'extern inline' whose semantics significantly
// differs between gnu90 and C99
#define INLINE_HEADER static inline
#define INLINE_ME inline
#define STATIC_INLINE static inline

// Figure out whether `__attributes__((gnu_inline))` is needed
// to force gnu90-style 'external inline' semantics.
#if defined(FORCE_GNU_INLINE)
// disable auto-detection since HAVE_GNU_INLINE has been defined externally
#elif __GNUC_GNU_INLINE__ && __GNUC__ == 4 && __GNUC_MINOR__ == 2
// GCC 4.2.x didn't properly support C99 inline semantics (GCC 4.3 was the first
// release to properly support C99 inline semantics), and therefore warned when
// using 'extern inline' while in C99 mode unless `__attributes__((gnu_inline))`
// was explicitly set.
# define FORCE_GNU_INLINE 1
#endif

#if FORCE_GNU_INLINE
// Force compiler into gnu90 semantics
# if defined(KEEP_INLINES)
#  define EXTERN_INLINE inline __attribute__((gnu_inline))
# else
#  define EXTERN_INLINE extern inline __attribute__((gnu_inline))
# endif
#elif __GNUC_GNU_INLINE__
// we're currently in gnu90 inline mode by default and
// __attribute__((gnu_inline)) may not be supported, so better leave it off
# if defined(KEEP_INLINES)
#  define EXTERN_INLINE inline
# else
#  define EXTERN_INLINE extern inline
# endif
#else
// Assume C99 semantics (yes, this curiously results in swapped definitions!)
// This is the preferred branch, and at some point we may drop support for
// compilers not supporting C99 semantics altogether.
# if defined(KEEP_INLINES)
#  define EXTERN_INLINE extern inline
# else
#  define EXTERN_INLINE inline
# endif
#endif


/*
 * GCC attributes
 */
#if defined(__GNUC__)
#define GNU_ATTRIBUTE(at) __attribute__((at))
#else
#define GNU_ATTRIBUTE(at)
#endif

#if __GNUC__ >= 3
#define GNUC3_ATTRIBUTE(at) __attribute__((at))
#else
#define GNUC3_ATTRIBUTE(at)
#endif

#if __GNUC__ > 4 || __GNUC__ == 4 && __GNUC_MINOR__ >= 3
#define GNUC_ATTR_HOT __attribute__((hot))
#else
#define GNUC_ATTR_HOT /* nothing */
#endif

#define STG_UNUSED    GNUC3_ATTRIBUTE(__unused__)

/* -----------------------------------------------------------------------------
   Global type definitions
   -------------------------------------------------------------------------- */

#include "MachDeps.h"
#include "stg/Types.h"

/* -----------------------------------------------------------------------------
   Shorthand forms
   -------------------------------------------------------------------------- */

typedef StgChar      C_;
typedef StgWord      W_;
typedef StgWord*  P_;
typedef StgInt    I_;
typedef StgWord StgWordArray[];
typedef StgFunPtr       F_;

#define EI_(X)          extern StgWordArray (X) GNU_ATTRIBUTE(aligned (8))
#define II_(X)          static StgWordArray (X) GNU_ATTRIBUTE(aligned (8))
#define IF_(f)    static StgFunPtr GNUC3_ATTRIBUTE(used) f(void)
#define FN_(f)    StgFunPtr f(void)
#define EF_(f)    StgFunPtr f(void) /* External Cmm functions */
#define EFF_(f)   void f() /* See Note [External function prototypes] */

/* Note [External function prototypes]  See Trac #8965, #11395
   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
In generated C code we need to distinct between two types
of external symbols:
1.  Cmm functions declared by 'EF_' macro (External Functions)
2.    C functions declared by 'EFF_' macro (External Foreign Functions)

Cmm functions are simple as they are internal to GHC.

C functions are trickier:

The external-function macro EFF_(F) used to be defined as
    extern StgFunPtr f(void)
i.e a function of zero arguments.  On most platforms this doesn't
matter very much: calls to these functions put the parameters in the
usual places anyway, and (with the exception of varargs) things just
work.

However, the ELFv2 ABI on ppc64 optimises stack allocation
(http://gcc.gnu.org/ml/gcc-patches/2013-11/msg01149.html): a call to a
function that has a prototype, is not varargs, and receives all parameters
in registers rather than on the stack does not require the caller to
allocate an argument save area.  The incorrect prototypes cause GCC to
believe that all functions declared this way can be called without an
argument save area, but if the callee has sufficiently many arguments then
it will expect that area to be present, and will thus corrupt the caller's
stack.  This happens in particular with calls to runInteractiveProcess in
libraries/process/cbits/runProcess.c, and led to Trac #8965.

The simplest fix appears to be to declare these external functions with an
unspecified argument list rather than a void argument list.  This is no
worse for platforms that don't care either way, and allows a successful
bootstrap of GHC 7.8 on little-endian Linux ppc64 (which uses the ELFv2
ABI).

Another case is m68k ABI where 'void*' return type is returned by 'a0'
register while 'long' return type is returned by 'd0'. Thus we trick
external prototype return neither of these types to workaround #11395.
*/


/* -----------------------------------------------------------------------------
   Tail calls
   -------------------------------------------------------------------------- */

#define JMP_(cont) return((StgFunPtr)(cont))

/* -----------------------------------------------------------------------------
   Other Stg stuff...
   -------------------------------------------------------------------------- */

#include "stg/DLL.h"
#include "stg/RtsMachRegs.h"
#include "stg/Regs.h"
#include "stg/Ticky.h"

#if IN_STG_CODE
/*
 * This is included later for RTS sources, after definitions of
 * StgInfoTable, StgClosure and so on.
 */
#include "stg/MiscClosures.h"
#endif

#include "stg/Prim.h" /* ghc-prim fallbacks */
#include "stg/SMP.h" // write_barrier() inline is required

/* -----------------------------------------------------------------------------
   Moving Floats and Doubles

   ASSIGN_FLT is for assigning a float to memory (usually the
              stack/heap).  The memory address is guaranteed to be
         StgWord aligned (currently == sizeof(void *)).

   PK_FLT     is for pulling a float out of memory.  The memory is
              guaranteed to be StgWord aligned.
   -------------------------------------------------------------------------- */

INLINE_HEADER void     ASSIGN_FLT (W_ [], StgFloat);
INLINE_HEADER StgFloat    PK_FLT     (W_ []);

#if ALIGNMENT_FLOAT <= ALIGNMENT_VOID_P

INLINE_HEADER void     ASSIGN_FLT(W_ p_dest[], StgFloat src) { *(StgFloat *)p_dest = src; }
INLINE_HEADER StgFloat PK_FLT    (W_ p_src[])                { return *(StgFloat *)p_src; }

#else  /* ALIGNMENT_FLOAT > ALIGNMENT_UNSIGNED_INT */

INLINE_HEADER void ASSIGN_FLT(W_ p_dest[], StgFloat src)
{
    float_thing y;
    y.f = src;
    *p_dest = y.fu;
}

INLINE_HEADER StgFloat PK_FLT(W_ p_src[])
{
    float_thing y;
    y.fu = *p_src;
    return(y.f);
}

#endif /* ALIGNMENT_FLOAT > ALIGNMENT_VOID_P */

#if ALIGNMENT_DOUBLE <= ALIGNMENT_VOID_P

INLINE_HEADER void     ASSIGN_DBL (W_ [], StgDouble);
INLINE_HEADER StgDouble   PK_DBL     (W_ []);

INLINE_HEADER void      ASSIGN_DBL(W_ p_dest[], StgDouble src) { *(StgDouble *)p_dest = src; }
INLINE_HEADER StgDouble PK_DBL    (W_ p_src[])                 { return *(StgDouble *)p_src; }

#else /* ALIGNMENT_DOUBLE > ALIGNMENT_VOID_P */

/* Sparc uses two floating point registers to hold a double.  We can
 * write ASSIGN_DBL and PK_DBL by directly accessing the registers
 * independently - unfortunately this code isn't writable in C, we
 * have to use inline assembler.
 */
#if sparc_HOST_ARCH

#define ASSIGN_DBL(dst0,src) \
    { StgPtr dst = (StgPtr)(dst0); \
      __asm__("st %2,%0\n\tst %R2,%1" : "=m" (((P_)(dst))[0]), \
   "=m" (((P_)(dst))[1]) : "f" (src)); \
    }

#define PK_DBL(src0) \
    ( { StgPtr src = (StgPtr)(src0); \
        register double d; \
      __asm__("ld %1,%0\n\tld %2,%R0" : "=f" (d) : \
   "m" (((P_)(src))[0]), "m" (((P_)(src))[1])); d; \
    } )

#else /* ! sparc_HOST_ARCH */

INLINE_HEADER void     ASSIGN_DBL (W_ [], StgDouble);
INLINE_HEADER StgDouble   PK_DBL     (W_ []);

typedef struct
  { StgWord dhi;
    StgWord dlo;
  } unpacked_double;

typedef union
  { StgDouble d;
    unpacked_double du;
  } double_thing;

INLINE_HEADER void ASSIGN_DBL(W_ p_dest[], StgDouble src)
{
    double_thing y;
    y.d = src;
    p_dest[0] = y.du.dhi;
    p_dest[1] = y.du.dlo;
}

/* GCC also works with this version, but it generates
   the same code as the previous one, and is not ANSI

#define ASSIGN_DBL( p_dest, src ) \
   *p_dest = ((double_thing) src).du.dhi; \
   *(p_dest+1) = ((double_thing) src).du.dlo \
*/

INLINE_HEADER StgDouble PK_DBL(W_ p_src[])
{
    double_thing y;
    y.du.dhi = p_src[0];
    y.du.dlo = p_src[1];
    return(y.d);
}

#endif /* ! sparc_HOST_ARCH */

#endif /* ALIGNMENT_DOUBLE > ALIGNMENT_UNSIGNED_INT */


/* -----------------------------------------------------------------------------
   Moving 64-bit quantities around

   ASSIGN_Word64      assign an StgWord64/StgInt64 to a memory location
   PK_Word64          load an StgWord64/StgInt64 from a amemory location

   In both cases the memory location might not be 64-bit aligned.
   -------------------------------------------------------------------------- */

#if SIZEOF_HSWORD == 4

typedef struct
  { StgWord dhi;
    StgWord dlo;
  } unpacked_double_word;

typedef union
  { StgInt64 i;
    unpacked_double_word iu;
  } int64_thing;

typedef union
  { StgWord64 w;
    unpacked_double_word wu;
  } word64_thing;

INLINE_HEADER void ASSIGN_Word64(W_ p_dest[], StgWord64 src)
{
    word64_thing y;
    y.w = src;
    p_dest[0] = y.wu.dhi;
    p_dest[1] = y.wu.dlo;
}

INLINE_HEADER StgWord64 PK_Word64(W_ p_src[])
{
    word64_thing y;
    y.wu.dhi = p_src[0];
    y.wu.dlo = p_src[1];
    return(y.w);
}

INLINE_HEADER void ASSIGN_Int64(W_ p_dest[], StgInt64 src)
{
    int64_thing y;
    y.i = src;
    p_dest[0] = y.iu.dhi;
    p_dest[1] = y.iu.dlo;
}

INLINE_HEADER StgInt64 PK_Int64(W_ p_src[])
{
    int64_thing y;
    y.iu.dhi = p_src[0];
    y.iu.dlo = p_src[1];
    return(y.i);
}

#elif SIZEOF_VOID_P == 8

INLINE_HEADER void ASSIGN_Word64(W_ p_dest[], StgWord64 src)
{
   p_dest[0] = src;
}

INLINE_HEADER StgWord64 PK_Word64(W_ p_src[])
{
    return p_src[0];
}

INLINE_HEADER void ASSIGN_Int64(W_ p_dest[], StgInt64 src)
{
    p_dest[0] = src;
}

INLINE_HEADER StgInt64 PK_Int64(W_ p_src[])
{
    return p_src[0];
}

#endif /* SIZEOF_HSWORD == 4 */

/* -----------------------------------------------------------------------------
   Split markers
   -------------------------------------------------------------------------- */

#if defined(USE_SPLIT_MARKERS)
#if defined(LEADING_UNDERSCORE)
#define __STG_SPLIT_MARKER __asm__("\n___stg_split_marker:");
#else
#define __STG_SPLIT_MARKER __asm__("\n__stg_split_marker:");
#endif
#else
#define __STG_SPLIT_MARKER /* nothing */
#endif

/* -----------------------------------------------------------------------------
   Integer multiply with overflow
   -------------------------------------------------------------------------- */

/* Multiply with overflow checking.
 *
 * This is tricky - the usual sign rules for add/subtract don't apply.
 *
 * On 32-bit machines we use gcc's 'long long' types, finding
 * overflow with some careful bit-twiddling.
 *
 * On 64-bit machines where gcc's 'long long' type is also 64-bits,
 * we use a crude approximation, testing whether either operand is
 * larger than 32-bits; if neither is, then we go ahead with the
 * multiplication.
 *
 * Return non-zero if there is any possibility that the signed multiply
 * of a and b might overflow.  Return zero only if you are absolutely sure
 * that it won't overflow.  If in doubt, return non-zero.
 */

#if SIZEOF_VOID_P == 4

#ifdef WORDS_BIGENDIAN
#define RTS_CARRY_IDX__ 0
#define RTS_REM_IDX__  1
#else
#define RTS_CARRY_IDX__ 1
#define RTS_REM_IDX__ 0
#endif

typedef union {
    StgInt64 l;
    StgInt32 i[2];
} long_long_u ;

#define mulIntMayOflo(a,b)       \
({                                              \
  StgInt32 r, c;           \
  long_long_u z;           \
  z.l = (StgInt64)a * (StgInt64)b;     \
  r = z.i[RTS_REM_IDX__];        \
  c = z.i[RTS_CARRY_IDX__];         \
  if (c == 0 || c == -1) {       \
    c = ((StgWord)((a^b) ^ r))         \
      >> (BITS_IN (I_) - 1);        \
  }                  \
  c;                                            \
})

/* Careful: the carry calculation above is extremely delicate.  Make sure
 * you test it thoroughly after changing it.
 */

#else

/* Approximate version when we don't have long arithmetic (on 64-bit archs) */

/* If we have n-bit words then we have n-1 bits after accounting for the
 * sign bit, so we can fit the result of multiplying 2 (n-1)/2-bit numbers */
#define HALF_POS_INT  (((I_)1) << ((BITS_IN (I_) - 1) / 2))
#define HALF_NEG_INT  (-HALF_POS_INT)

#define mulIntMayOflo(a,b)       \
({                                              \
  I_ c;              \
  if ((I_)a <= HALF_NEG_INT || a >= HALF_POS_INT    \
      || (I_)b <= HALF_NEG_INT || b >= HALF_POS_INT) {\
    c = 1;              \
  } else {              \
    c = 0;              \
  }                  \
  c;                                            \
})
#endif

#endif /* STG_H */
{-# START_FILE <%name%>.cabal #-}
name:                <%name%>
version:             0.1.0.0
-- synopsis:            
-- description:         
license:             BSD3
license-file:        LICENSE
author:              <%author-name%><%^author-name%>Author name here<%/author-name%>
maintainer:          <%author-email%><%^author-email%>example@example.com<%/author-email%>
-- copyright:
category:            Game
build-type:          Simple
cabal-version:       >=1.10

flag target-mac
  description: Build for Mac
  default: False
  manual: True

flag target-android
  description: Build for Android
  default: False
  manual: True

executable <%name%>
  -- exposed-modules:     
  -- other-modules:       
  -- other-extensions:    
  hs-source-dirs:      hs-src
  main-is:             <%name-as-module%>.hs
  build-depends:       base >=4.8 && <5
                     , colour
                     , reflex
                     , reflex-cocos2d
                     , diagrams-lib
  default-language:    Haskell2010

  -- ### stubdir controls where the stub file is put
  ghc-options:         -Wall -threaded -stubdir Classes -fno-warn-name-shadowing -no-hs-main
  if flag(target-mac)
    -- ### additional Mac options (to compile it as a single lib that exports the main haskell entry)
    ghc-options: -o <%name%> -staticlib -pgmlibtool libtool-quiet
  else
    if flag(target-android)
      -- ### additional android options
      ghc-options: -fPIC
      ld-options:  -shared -Wl,-soname,lib<%name-as-varid%>.so
{-# START_FILE proj.android-studio/app/AndroidManifest.xml #-}
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
      package="org.cocos.<%name-as-varid%>"
      android:versionCode="1"
      android:versionName="1.0"
      android:installLocation="auto">

    <uses-sdk android:minSdkVersion="9"/>
    <uses-feature android:glEsVersion="0x00020000" />

    <application android:label="@string/app_name"
                 android:icon="@drawable/icon">
					 
        <!-- Tell Cocos2dxActivity the name of our .so -->
        <meta-data android:name="android.app.lib_name"
	              android:value="cocos2dcpp" />

        <activity android:name="org.cocos2dx.cpp.AppActivity"
                  android:label="@string/app_name"
                  android:screenOrientation="landscape"
                  android:theme="@android:style/Theme.NoTitleBar.Fullscreen"
                  android:configChanges="orientation|keyboardHidden|screenSize">

            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>
    </application>

    <supports-screens android:anyDensity="true"
                      android:smallScreens="true"
                      android:normalScreens="true"
                      android:largeScreens="true"
                      android:xlargeScreens="true"/>

    <uses-permission android:name="android.permission.INTERNET"/>
</manifest> 
{-# START_FILE proj.android-studio/app/build.gradle #-}
apply plugin: 'com.android.application'
android {
    compileSdkVersion 22
    buildToolsVersion "23.0.1"

    defaultConfig {
        applicationId "org.cocos.<%name-as-varid%>"
        minSdkVersion 9
        targetSdkVersion 9

        // ndk {
        //     moduleName "cocos2dcpp_shared"
        // }
    }

    sourceSets.main {
        java.srcDir "src"
        aidl.srcDir "src"
        res.srcDir "res"
        jniLibs.srcDir "libs"
        manifest.srcFile "AndroidManifest.xml"
        assets.srcDir "assets"
    }

    signingConfigs {

       release {
            if (project.hasProperty("RELEASE_STORE_FILE")) {
                storeFile file(RELEASE_STORE_FILE)
                storePassword RELEASE_STORE_PASSWORD
                keyAlias RELEASE_KEY_ALIAS
                keyPassword RELEASE_KEY_PASSWORD
            }
        }
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
            if (project.hasProperty("RELEASE_STORE_FILE")) {
                signingConfig signingConfigs.release
            }
        }
    }


    applicationVariants.all { variant ->
        task "open${variant.name.capitalize()}" {
            dependsOn "install${variant.name.capitalize()}"
            doLast {
                exec {
                    commandLine "adb shell monkey -p ${variant.applicationId} -c android.intent.category.LAUNCHER 1".split(" ")
                }
            }
        }
    }
}

dependencies {
    compile files('jars/android-async-http-1.4.8.jar')
}
{-# START_FILE proj.android-studio/app/build.xml #-}
<?xml version="1.0" encoding="UTF-8"?>
<project name="AppActivity" default="help">

    <!-- The local.properties file is created and updated by the 'android' tool.
         It contains the path to the SDK. It should *NOT* be checked into
         Version Control Systems. -->
    <property file="local.properties" />

    <!-- The ant.properties file can be created by you. It is only edited by the
         'android' tool to add properties to it.
         This is the place to change some Ant specific build properties.
         Here are some properties you may want to change/update:

         source.dir
             The name of the source directory. Default is 'src'.
         out.dir
             The name of the output directory. Default is 'bin'.

         For other overridable properties, look at the beginning of the rules
         files in the SDK, at tools/ant/build.xml

         Properties related to the SDK location or the project target should
         be updated using the 'android' tool with the 'update' action.

         This file is an integral part of the build system for your
         application and should be checked into Version Control Systems.

         -->
    <property file="ant.properties" />

    <!-- if sdk.dir was not set from one of the property file, then
         get it from the ANDROID_HOME env var.
         This must be done before we load project.properties since
         the proguard config can use sdk.dir -->
    <property environment="env" />
    <condition property="sdk.dir" value="${env.ANDROID_HOME}">
        <isset property="env.ANDROID_HOME" />
    </condition>

    <!-- The project.properties file is created and updated by the 'android'
         tool, as well as ADT.

         This contains project specific properties such as project target, and library
         dependencies. Lower level build properties are stored in ant.properties
         (or in .classpath for Eclipse projects).

         This file is an integral part of the build system for your
         application and should be checked into Version Control Systems. -->
    <loadproperties srcFile="project.properties" />

    <!-- quick check on sdk.dir -->
    <fail
            message="sdk.dir is missing. Make sure to generate local.properties using 'android update project' or to inject it through the ANDROID_HOME environment variable."
            unless="sdk.dir"
    />

    <!--
        Import per project custom build rules if present at the root of the project.
        This is the place to put custom intermediary targets such as:
            -pre-build
            -pre-compile
            -post-compile (This is typically used for code obfuscation.
                           Compiled code location: ${out.classes.absolute.dir}
                           If this is not done in place, override ${out.dex.input.absolute.dir})
            -post-package
            -post-build
            -pre-clean
    -->
    <import file="custom_rules.xml" optional="true" />

    <!-- Import the actual build file.

         To customize existing targets, there are two options:
         - Customize only one target:
             - copy/paste the target into this file, *before* the
               <import> task.
             - customize it to your needs.
         - Customize the whole content of build.xml
             - copy/paste the content of the rules files (minus the top node)
               into this file, replacing the <import> task.
             - customize to your needs.

         ***********************
         ****** IMPORTANT ******
         ***********************
         In all cases you must update the value of version-tag below to read 'custom' instead of an integer,
         in order to avoid having your file be overridden by tools such as "android update project"
    -->
    <!-- version-tag: 1 -->
    <import file="${sdk.dir}/tools/ant/build.xml" />

</project>
{-# START_FILE proj.android-studio/app/jni/Android.mk #-}
LOCAL_PATH := $(call my-dir)

include $(CLEAR_VARS)





LOCAL_MODULE := cocos2dcpp_shared

LOCAL_MODULE_FILENAME := libcocos2dcpp

LOCAL_SRC_FILES := hellocpp/main.cpp \
                   ../../../Classes/AppDelegate.cpp

LOCAL_C_INCLUDES := $(LOCAL_PATH)/../../../Classes
# we are cross-compiling against 7.10.2
LOCAL_C_INCLUDES += $(LOCAL_PATH)/../../../include/ghc-7.10.2

# _COCOS_HEADER_ANDROID_BEGIN
# _COCOS_HEADER_ANDROID_END


LOCAL_STATIC_LIBRARIES := cocos2dx_static
LOCAL_SHARED_LIBRARIES := haskell_shared

# _COCOS_LIB_ANDROID_BEGIN
# _COCOS_LIB_ANDROID_END

include $(BUILD_SHARED_LIBRARY)

#================================

include $(CLEAR_VARS)
LOCAL_MODULE := haskell_shared
LOCAL_SRC_FILES := lib<%name-as-varid%>.so
include $(PREBUILT_SHARED_LIBRARY)

#================================

$(call import-module,./prebuilt-mk)

# _COCOS_LIB_IMPORT_ANDROID_BEGIN
# _COCOS_LIB_IMPORT_ANDROID_END
{-# START_FILE proj.android-studio/app/jni/Application.mk #-}
APP_STL := gnustl_static

APP_CPPFLAGS := -frtti -DCC_ENABLE_CHIPMUNK_INTEGRATION=1 -std=c++11 -fsigned-char
APP_LDFLAGS := -latomic


ifeq ($(NDK_DEBUG),1)
  APP_CPPFLAGS += -DCOCOS2D_DEBUG=1
  APP_OPTIM := debug
else
  APP_CPPFLAGS += -DNDEBUG
  APP_OPTIM := release
endif
{-# START_FILE proj.android-studio/app/jni/hellocpp/main.cpp #-}
#include "AppDelegate.h"
#include "cocos2d.h"
#include "platform/android/jni/JniHelper.h"
#include <jni.h>
#include <android/log.h>

#define  LOG_TAG    "main"
#define  LOGD(...)  __android_log_print(ANDROID_LOG_DEBUG,LOG_TAG,__VA_ARGS__)

using namespace cocos2d;

void cocos_android_app_init (JNIEnv* env) {
    LOGD("cocos_android_app_init");
    AppDelegate *pAppDelegate = new AppDelegate();
}
{-# START_FILE proj.android-studio/app/project.properties #-}
# This file is automatically generated by Android Tools.
# Do not modify this file -- YOUR CHANGES WILL BE ERASED!
#
# This file must be checked in Version Control Systems.
#
# To customize properties used by the Ant build system use,
# "ant.properties", and override values to adapt the script to your
# project structure.

# Project target.
target=android-22
{-# START_FILE proj.android-studio/app/res/values/strings.xml #-}
<?xml version="1.0" encoding="utf-8"?>
<resources>
    <string name="app_name"><%name%></string>
</resources>
{-# START_FILE proj.android-studio/app/src/com/chukong/cocosplay/client/CocosPlayClient.java #-}
/****************************************************************************
Copyright (c) 2015 Chukong Technologies Inc.

http://www.cocos2d-x.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 ****************************************************************************/
package com.chukong.cocosplay.client;

import android.app.Activity;

public class CocosPlayClient {
    
    public static boolean init(Activity activity, boolean isDemo) {
        return false;
    }
    
    public static boolean isEnabled() {
        return false;
    }
    
    public static boolean isDemo() {
        return false;
    }
    
    public static boolean isNotifyFileLoadedEnabled() {
        return false;
    }
    
    public static void notifyFileLoaded(String filePath) {
        
    }
    
    public static void updateAssets(String filePath) {
        
    }
    
    public static String getGameRoot() {
        return "";
    }
    
    public static native String[] getSearchPaths();
}
{-# START_FILE proj.android-studio/app/src/com/enhance/gameservice/IGameTuningService.aidl #-}
package com.enhance.gameservice;

interface IGameTuningService
{
    int setPreferredResolution(int resolution);
    int setFramePerSecond(int fps);
    int boostUp(int seconds);
    int getAbstractTemperature();
    int setGamePowerSaving(boolean enable);
}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/cpp/AppActivity.java #-}
/****************************************************************************
Copyright (c) 2008-2010 Ricardo Quesada
Copyright (c) 2010-2012 cocos2d-x.org
Copyright (c) 2011      Zynga Inc.
Copyright (c) 2013-2014 Chukong Technologies Inc.
 
http://www.cocos2d-x.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
****************************************************************************/
package org.cocos2dx.cpp;

import org.cocos2dx.lib.Cocos2dxActivity;

public class AppActivity extends Cocos2dxActivity {
}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/Cocos2dxAccelerometer.java #-}
/****************************************************************************
Copyright (c) 2010-2011 cocos2d-x.org

http://www.cocos2d-x.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 ****************************************************************************/
package org.cocos2dx.lib;

import android.content.Context;
import android.content.res.Configuration;
import android.hardware.Sensor;
import android.hardware.SensorEvent;
import android.hardware.SensorEventListener;
import android.hardware.SensorManager;
import android.view.Display;
import android.view.Surface;
import android.view.WindowManager;

public class Cocos2dxAccelerometer implements SensorEventListener {
    // ===========================================================
    // Constants
    // ===========================================================

    private static final String TAG = Cocos2dxAccelerometer.class.getSimpleName();

    // ===========================================================
    // Fields
    // ===========================================================

    private final Context mContext;
    private final SensorManager mSensorManager;
    private final Sensor mAccelerometer;
    private final int mNaturalOrientation;

    // ===========================================================
    // Constructors
    // ===========================================================

    public Cocos2dxAccelerometer(final Context context) {
        this.mContext = context;

        this.mSensorManager = (SensorManager) this.mContext.getSystemService(Context.SENSOR_SERVICE);
        this.mAccelerometer = this.mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER);

        final Display display = ((WindowManager) this.mContext.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
        this.mNaturalOrientation = display.getOrientation();
    }

    // ===========================================================
    // Getter & Setter
    // ===========================================================

    public void enable() {
        this.mSensorManager.registerListener(this, this.mAccelerometer, SensorManager.SENSOR_DELAY_GAME);
    }

        public void setInterval(float interval) {
            // Honeycomb version is 11
            if(android.os.Build.VERSION.SDK_INT < 11) {
            this.mSensorManager.registerListener(this, this.mAccelerometer, SensorManager.SENSOR_DELAY_GAME);
        } else {
            //convert seconds to microseconds
            this.mSensorManager.registerListener(this, this.mAccelerometer, (int)(interval*100000));
        }
    }
      
    public void disable() {
        this.mSensorManager.unregisterListener(this);
    }

    // ===========================================================
    // Methods for/from SuperClass/Interfaces
    // ===========================================================

    @Override
    public void onSensorChanged(final SensorEvent sensorEvent) {
        if (sensorEvent.sensor.getType() != Sensor.TYPE_ACCELEROMETER) {
            return;
        }

        float x = sensorEvent.values[0];
        float y = sensorEvent.values[1];
        final float z = sensorEvent.values[2];

        /*
         * Because the axes are not swapped when the device's screen orientation
         * changes. So we should swap it here. In tablets such as Motorola Xoom,
         * the default orientation is landscape, so should consider this.
         */
        final int orientation = this.mContext.getResources().getConfiguration().orientation;

        if ((orientation == Configuration.ORIENTATION_LANDSCAPE) && (this.mNaturalOrientation != Surface.ROTATION_0)) {
            final float tmp = x;
            x = -y;
            y = tmp;
        } else if ((orientation == Configuration.ORIENTATION_PORTRAIT) && (this.mNaturalOrientation != Surface.ROTATION_0)) {
            final float tmp = x;
            x = y;
            y = -tmp;
        }       
        
        Cocos2dxGLSurfaceView.queueAccelerometer(x,y,z,sensorEvent.timestamp);
        
        /*
        if(BuildConfig.DEBUG) {
            Log.d(TAG, "x = " + sensorEvent.values[0] + " y = " + sensorEvent.values[1] + " z = " + pSensorEvent.values[2]);
        }
        */
    }

    @Override
    public void onAccuracyChanged(final Sensor sensor, final int accuracy) {
    }

    // ===========================================================
    // Methods
        // Native method called from Cocos2dxGLSurfaceView (To be in the same thread)
    // ===========================================================
    
    public static native void onSensorChanged(final float x, final float y, final float z, final long timestamp);

    // ===========================================================
    // Inner and Anonymous Classes
    // ===========================================================
}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/Cocos2dxActivity.java #-}
/****************************************************************************
Copyright (c) 2010-2013 cocos2d-x.org

http://www.cocos2d-x.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 ****************************************************************************/
package org.cocos2dx.lib;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.graphics.PixelFormat;
import android.opengl.GLSurfaceView;
import android.os.Build;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.preference.PreferenceManager.OnActivityResultListener;
import android.util.AttributeSet;
import android.util.Log;
import android.view.ViewGroup;
import android.view.Window;
import android.view.WindowManager;
import android.widget.FrameLayout;

import com.chukong.cocosplay.client.CocosPlayClient;

import org.cocos2dx.lib.Cocos2dxHelper.Cocos2dxHelperListener;

import javax.microedition.khronos.egl.EGL10;
import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.egl.EGLDisplay;

class ResizeLayout extends FrameLayout{
    private  boolean mEnableForceDoLayout = false;

    public ResizeLayout(Context context){
        super(context);
    }

    public ResizeLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public void setEnableForceDoLayout(boolean flag){
        mEnableForceDoLayout = flag;
    }

    @Override
    protected void onLayout(boolean changed, int l, int t, int r, int b) {
        super.onLayout(changed, l, t, r, b);
        if(mEnableForceDoLayout){
            /*This is a hot-fix for some android devices which don't do layout when the main window
            * is paned.  We refersh the layout in 24 frames per seconds.
            * When the editBox is lose focus or when user begin to type, the do layout is disabled.
            */
            final Handler handler = new Handler();
            handler.postDelayed(new Runnable() {
                @Override
                public void run() {
                    //Do something after 100ms
                    requestLayout();
                    invalidate();
                }
            }, 1000 / 24);

        }

    }

}


public abstract class Cocos2dxActivity extends Activity implements Cocos2dxHelperListener {
    // ===========================================================
    // Constants
    // ===========================================================

    private final static String TAG = Cocos2dxActivity.class.getSimpleName();

    // ===========================================================
    // Fields
    // ===========================================================
    
    private Cocos2dxGLSurfaceView mGLSurfaceView = null;
    private int[] mGLContextAttrs = null;
    private Cocos2dxHandler mHandler = null;   
    private static Cocos2dxActivity sContext = null;
    private Cocos2dxVideoHelper mVideoHelper = null;
    private Cocos2dxWebViewHelper mWebViewHelper = null;
    private Cocos2dxEditBoxHelper mEditBoxHelper = null;
    private boolean hasFocus = false;

    public Cocos2dxGLSurfaceView getGLSurfaceView(){
        return  mGLSurfaceView;
    }

    public class Cocos2dxEGLConfigChooser implements GLSurfaceView.EGLConfigChooser
    {
        protected int[] configAttribs;
        public Cocos2dxEGLConfigChooser(int redSize, int greenSize, int blueSize, int alphaSize, int depthSize, int stencilSize)
        {
            configAttribs = new int[] {redSize, greenSize, blueSize, alphaSize, depthSize, stencilSize};
        }
        public Cocos2dxEGLConfigChooser(int[] attribs)
        {
            configAttribs = attribs;
        }

        private int findConfigAttrib(EGL10 egl, EGLDisplay display,
                EGLConfig config, int attribute, int defaultValue) {
            int[] value = new int[1];
            if (egl.eglGetConfigAttrib(display, config, attribute, value)) {
                return value[0];
            }
            return defaultValue;
        }

        class ConfigValue implements Comparable<ConfigValue> {

            public EGLConfig config = null;
            public int[] configAttribs = null;
            public int value = 0;
            private void calcValue() {
                // depth factor 29bit and [6,12)bit
                if (configAttribs[4] > 0) {
                    value = value + (1 << 29) + ((configAttribs[4]%64) << 6);
                }
                // stencil factor 28bit and [0, 6)bit
                if (configAttribs[5] > 0) {
                    value = value + (1 << 28) + ((configAttribs[5]%64));
                }
                // alpha factor 30bit and [24, 28)bit
                if (configAttribs[3] > 0) {
                    value = value + (1 << 30) + ((configAttribs[3]%16) << 24);
                }
                // green factor [20, 24)bit
                if (configAttribs[1] > 0) {
                    value = value + ((configAttribs[1]%16) << 20);
                }
                // blue factor [16, 20)bit
                if (configAttribs[2] > 0) {
                    value = value + ((configAttribs[2]%16) << 16);
                }
                // red factor [12, 16)bit
                if (configAttribs[0] > 0) {
                    value = value + ((configAttribs[0]%16) << 12);
                }
            }

            public ConfigValue(int[] attribs) {
                configAttribs = attribs;
                calcValue();
            }

            public ConfigValue(EGL10 egl, EGLDisplay display, EGLConfig config) {
                this.config = config;
                configAttribs = new int[6];
                configAttribs[0] = findConfigAttrib(egl, display, config, EGL10.EGL_RED_SIZE, 0);
                configAttribs[1] = findConfigAttrib(egl, display, config, EGL10.EGL_GREEN_SIZE, 0);
                configAttribs[2] = findConfigAttrib(egl, display, config, EGL10.EGL_BLUE_SIZE, 0);
                configAttribs[3] = findConfigAttrib(egl, display, config, EGL10.EGL_ALPHA_SIZE, 0);
                configAttribs[4] = findConfigAttrib(egl, display, config, EGL10.EGL_DEPTH_SIZE, 0);
                configAttribs[5] = findConfigAttrib(egl, display, config, EGL10.EGL_STENCIL_SIZE, 0);
                calcValue();
            }

            @Override
            public int compareTo(ConfigValue another) {
                if (value < another.value) {
                    return -1;
                } else if (value > another.value) {
                    return 1;
                } else {
                    return 0;
                }
            }

            @Override
            public String toString() {
                return "{ color: " + configAttribs[3] + configAttribs[2] + configAttribs[1] + configAttribs[0] +
                        "; depth: " + configAttribs[4] + "; stencil: " + configAttribs[5] + ";}";
            }
        }

        @Override
        public EGLConfig chooseConfig(EGL10 egl, EGLDisplay display) 
        {
            int[] EGLattribs = {
                    EGL10.EGL_RED_SIZE, configAttribs[0],
                    EGL10.EGL_GREEN_SIZE, configAttribs[1],
                    EGL10.EGL_BLUE_SIZE, configAttribs[2],
                    EGL10.EGL_ALPHA_SIZE, configAttribs[3],
                    EGL10.EGL_DEPTH_SIZE, configAttribs[4],
                    EGL10.EGL_STENCIL_SIZE,configAttribs[5],
                    EGL10.EGL_RENDERABLE_TYPE, 4, //EGL_OPENGL_ES2_BIT
                    EGL10.EGL_NONE
            };
            EGLConfig[] configs = new EGLConfig[1];
            int[] numConfigs = new int[1];
            boolean eglChooseResult = egl.eglChooseConfig(display, EGLattribs, configs, 1, numConfigs);
            if (eglChooseResult && numConfigs[0] > 0)
            {
                return configs[0];
            }

            // there's no config match the specific configAttribs, we should choose a closest one
            int[] EGLV2attribs = {
                    EGL10.EGL_RENDERABLE_TYPE, 4, //EGL_OPENGL_ES2_BIT
                    EGL10.EGL_NONE
            };
            eglChooseResult = egl.eglChooseConfig(display, EGLV2attribs, null, 0, numConfigs);
            if(eglChooseResult && numConfigs[0] > 0) {
                int num = numConfigs[0];
                ConfigValue[] cfgVals = new ConfigValue[num];

                // convert all config to ConfigValue
                configs = new EGLConfig[num];
                egl.eglChooseConfig(display, EGLV2attribs, configs, num, numConfigs);
                for (int i = 0; i < num; ++i) {
                    cfgVals[i] = new ConfigValue(egl, display, configs[i]);
                }

                ConfigValue e = new ConfigValue(configAttribs);
                // bin search
                int lo = 0;
                int hi = num;
                int mi;
                while (lo < hi - 1) {
                    mi = (lo + hi) / 2;
                    if (e.compareTo(cfgVals[mi]) < 0) {
                        hi = mi;
                    } else {
                        lo = mi;
                    }
                }
                if (lo != num - 1) {
                    lo = lo + 1;
                }
                Log.w("cocos2d", "Can't find EGLConfig match: " + e + ", instead of closest one:" + cfgVals[lo]);
                return cfgVals[lo].config;
            }

            Log.e(DEVICE_POLICY_SERVICE, "Can not select an EGLConfig for rendering.");
            return null;
        }

    }
    
    public static Context getContext() {
        return sContext;
    }
    
    public void setKeepScreenOn(boolean value) {
        final boolean newValue = value;
        runOnUiThread(new Runnable() {
            @Override
            public void run() {
                mGLSurfaceView.setKeepScreenOn(newValue);
            }
        });
    }
    
    protected void onLoadNativeLibraries() {
        try {
            ApplicationInfo ai = getPackageManager().getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA);
            Bundle bundle = ai.metaData;
            String libName = bundle.getString("android.app.lib_name");
            System.loadLibrary(libName);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    // ===========================================================
    // Constructors
    // ===========================================================

    @Override
    protected void onCreate(final Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        CocosPlayClient.init(this, false);

        onLoadNativeLibraries();

        sContext = this;
        this.mHandler = new Cocos2dxHandler(this);
        
        Cocos2dxHelper.init(this);
        
        this.mGLContextAttrs = getGLContextAttrs();
        this.init();

        if (mVideoHelper == null) {
            mVideoHelper = new Cocos2dxVideoHelper(this, mFrameLayout);
        }
        
        if(mWebViewHelper == null){
            mWebViewHelper = new Cocos2dxWebViewHelper(mFrameLayout);
        }

        if(mEditBoxHelper == null){
            mEditBoxHelper = new Cocos2dxEditBoxHelper(mFrameLayout);
        }

        Window window = this.getWindow();
        window.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN);
    }

    //native method,call GLViewImpl::getGLContextAttrs() to get the OpenGL ES context attributions
    private static native int[] getGLContextAttrs();
    
    // ===========================================================
    // Getter & Setter
    // ===========================================================

    // ===========================================================
    // Methods for/from SuperClass/Interfaces
    // ===========================================================

    @Override
    protected void onResume() {
    	Log.d(TAG, "onResume()");
        super.onResume();
       	resumeIfHasFocus();
    }
    
    @Override
    public void onWindowFocusChanged(boolean hasFocus) {
    	Log.d(TAG, "onWindowFocusChanged() hasFocus=" + hasFocus);
        super.onWindowFocusChanged(hasFocus);
        
        this.hasFocus = hasFocus;
        resumeIfHasFocus();
    }
    
    private void resumeIfHasFocus() {
        if(hasFocus) {
        	Cocos2dxHelper.onResume();
        	mGLSurfaceView.onResume();
        }
    }

    @Override
    protected void onPause() {
    	Log.d(TAG, "onPause()");
        super.onPause();
        Cocos2dxHelper.onPause();
        mGLSurfaceView.onPause();
    }
    
    @Override
    protected void onDestroy() {
        super.onDestroy();
    }

    @Override
    public void showDialog(final String pTitle, final String pMessage) {
        Message msg = new Message();
        msg.what = Cocos2dxHandler.HANDLER_SHOW_DIALOG;
        msg.obj = new Cocos2dxHandler.DialogMessage(pTitle, pMessage);
        this.mHandler.sendMessage(msg);
    }
    
    @Override
    public void runOnGLThread(final Runnable pRunnable) {
        this.mGLSurfaceView.queueEvent(pRunnable);
    }
    
    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data)
    {
        for (OnActivityResultListener listener : Cocos2dxHelper.getOnActivityResultListeners()) {
            listener.onActivityResult(requestCode, resultCode, data);
        }

        super.onActivityResult(requestCode, resultCode, data);
    }


    protected ResizeLayout mFrameLayout = null;
    // ===========================================================
    // Methods
    // ===========================================================
    public void init() {
        
        // FrameLayout
        ViewGroup.LayoutParams framelayout_params =
            new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
                                       ViewGroup.LayoutParams.MATCH_PARENT);

        mFrameLayout = new ResizeLayout(this);

        mFrameLayout.setLayoutParams(framelayout_params);

        // Cocos2dxEditText layout
        ViewGroup.LayoutParams edittext_layout_params =
            new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,
                                       ViewGroup.LayoutParams.WRAP_CONTENT);
        Cocos2dxEditBox edittext = new Cocos2dxEditBox(this);
        edittext.setLayoutParams(edittext_layout_params);


        mFrameLayout.addView(edittext);

        // Cocos2dxGLSurfaceView
        this.mGLSurfaceView = this.onCreateView();

        // ...add to FrameLayout
        mFrameLayout.addView(this.mGLSurfaceView);

        // Switch to supported OpenGL (ARGB888) mode on emulator
        if (isAndroidEmulator())
           this.mGLSurfaceView.setEGLConfigChooser(8, 8, 8, 8, 16, 0);

        this.mGLSurfaceView.setCocos2dxRenderer(new Cocos2dxRenderer());
        this.mGLSurfaceView.setCocos2dxEditText(edittext);

        // Set framelayout as the content view
        setContentView(mFrameLayout);
    }

    
    public Cocos2dxGLSurfaceView onCreateView() {
        Cocos2dxGLSurfaceView glSurfaceView = new Cocos2dxGLSurfaceView(this);
        //this line is need on some device if we specify an alpha bits
        if(this.mGLContextAttrs[3] > 0) glSurfaceView.getHolder().setFormat(PixelFormat.TRANSLUCENT);

        Cocos2dxEGLConfigChooser chooser = new Cocos2dxEGLConfigChooser(this.mGLContextAttrs);
        glSurfaceView.setEGLConfigChooser(chooser);

        return glSurfaceView;
    }

   private final static boolean isAndroidEmulator() {
      String model = Build.MODEL;
      Log.d(TAG, "model=" + model);
      String product = Build.PRODUCT;
      Log.d(TAG, "product=" + product);
      boolean isEmulator = false;
      if (product != null) {
         isEmulator = product.equals("sdk") || product.contains("_sdk") || product.contains("sdk_");
      }
      Log.d(TAG, "isEmulator=" + isEmulator);
      return isEmulator;
   }

    // ===========================================================
    // Inner and Anonymous Classes
    // ===========================================================
}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/Cocos2dxBitmap.java #-}
/****************************************************************************
Copyright (c) 2010-2012 cocos2d-x.org
Copyright (c) 2013-2015 Chukong Technologies Inc.

http://www.cocos2d-x.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 ****************************************************************************/
package org.cocos2dx.lib;

import android.content.Context;
import android.graphics.Bitmap;
import android.graphics.Canvas;
import android.graphics.Rect;
import android.graphics.Typeface;
import android.text.Layout;
import android.text.StaticLayout;
import android.text.TextPaint;
import android.text.TextUtils;
import android.util.Log;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;

public final class Cocos2dxBitmap {
    // ===========================================================
    // Constants
    // ===========================================================

    /* The values are the same as cocos2dx/platform/CCImage.h. */
    private static final int HORIZONTAL_ALIGN_LEFT = 1;
    private static final int HORIZONTAL_ALIGN_RIGHT = 2;
    private static final int HORIZONTAL_ALIGN_CENTER = 3;
    private static final int VERTICAL_ALIGN_TOP = 1;
    private static final int VERTICAL_ALIGN_BOTTOM = 2;
    private static final int VERTICAL_ALIGN_CENTER = 3;

    // ===========================================================
    // Fields
    // ===========================================================

    private static Context sContext;

    // ===========================================================
    // Getter & Setter
    // ===========================================================

    public static void setContext(final Context context) {
        Cocos2dxBitmap.sContext = context;
    }

    // ===========================================================
    // Methods for/from SuperClass/Interfaces
    // ===========================================================

    // ===========================================================
    // Methods
    // ===========================================================

    private static native void nativeInitBitmapDC(final int width,
            final int height, final byte[] pixels);

    public static boolean createTextBitmapShadowStroke(byte[] bytes,  final String fontName, int fontSize,
                                                    int fontTintR, int fontTintG, int fontTintB, int fontTintA,
                                                    int alignment, int width, int height, 
                                                    boolean shadow, float shadowDX, float shadowDY, float shadowBlur, float shadowOpacity, 
                                                    boolean stroke, int strokeR, int strokeG, int strokeB, int strokeA, float strokeSize) {
        String string;
        if (bytes == null || bytes.length == 0) {
          return false;
        } else {
          string = new String(bytes);
        }

        Layout.Alignment hAlignment = Layout.Alignment.ALIGN_NORMAL;
        int horizontalAlignment = alignment & 0x0F;
        switch (horizontalAlignment) {
            case HORIZONTAL_ALIGN_CENTER:
                hAlignment = Layout.Alignment.ALIGN_CENTER;
                break;
            case HORIZONTAL_ALIGN_RIGHT:
                hAlignment = Layout.Alignment.ALIGN_OPPOSITE;
                break;
            case HORIZONTAL_ALIGN_LEFT:
                break;
            default:
                break;
        }

        TextPaint paint = Cocos2dxBitmap.newPaint(fontName, fontSize);
        if (stroke) {
            paint.setStyle(TextPaint.Style.STROKE);
            paint.setStrokeWidth(strokeSize);
        }

        int maxWidth = width;
        if (maxWidth <= 0) {
            maxWidth = (int)Math.ceil( StaticLayout.getDesiredWidth(string, paint));
        }
        StaticLayout staticLayout = new StaticLayout(string, paint, maxWidth , hAlignment,1.0f,0.0f,false);
        int layoutWidth = staticLayout.getWidth();
        int layoutHeight = staticLayout.getLineTop(staticLayout.getLineCount());

        int bitmapWidth = Math.max(layoutWidth, width);
        int bitmapHeight = layoutHeight;
        if (height > 0) {
            bitmapHeight = height;
        }

        if (bitmapWidth == 0 || bitmapHeight == 0) {
            return false;
        }

        int offsetX = 0;
        if (horizontalAlignment == HORIZONTAL_ALIGN_CENTER) {
            offsetX = (bitmapWidth - layoutWidth) / 2;
        }
        else if (horizontalAlignment == HORIZONTAL_ALIGN_RIGHT) {
            offsetX = bitmapWidth - layoutWidth;
        }

        int offsetY = 0;
        int verticalAlignment   = (alignment >> 4) & 0x0F;
        switch (verticalAlignment)
        {
            case VERTICAL_ALIGN_CENTER:
                offsetY = (bitmapHeight - layoutHeight) / 2;
                break;
            case VERTICAL_ALIGN_BOTTOM:
                offsetY = bitmapHeight - layoutHeight;
                break;
        }

        Bitmap bitmap = Bitmap.createBitmap(bitmapWidth, bitmapHeight, Bitmap.Config.ARGB_8888);
        Canvas canvas = new Canvas(bitmap);
        canvas.translate(offsetX, offsetY);
        if ( stroke )
        {
            paint.setARGB(strokeA, strokeR, strokeG, strokeB);
            staticLayout.draw(canvas);
        }
        paint.setStyle(TextPaint.Style.FILL);
        paint.setARGB(fontTintA, fontTintR, fontTintG, fontTintB);
        staticLayout.draw(canvas);

        Cocos2dxBitmap.initNativeObject(bitmap);
        return true;
    }

    private static TextPaint newPaint(final String fontName, final int fontSize) {
        final TextPaint paint = new TextPaint();
        paint.setTextSize(fontSize);
        paint.setAntiAlias(true);

        // Set type face for paint, now it support .ttf file.
        if (fontName.endsWith(".ttf")) {
            try {
                final Typeface typeFace = Cocos2dxTypefaces.get(
                        Cocos2dxBitmap.sContext, fontName);
                paint.setTypeface(typeFace);
            } catch (final Exception e) {
                Log.e("Cocos2dxBitmap", "error to create ttf type face: "
                        + fontName);

                // The file may not find, use system font.
                paint.setTypeface(Typeface.create(fontName, Typeface.NORMAL));
            }
        } else {
            paint.setTypeface(Typeface.create(fontName, Typeface.NORMAL));
        }

        return paint;
    }

    private static void initNativeObject(final Bitmap bitmap) {
        final byte[] pixels = Cocos2dxBitmap.getPixels(bitmap);
        if (pixels == null) {
            return;
        }

        Cocos2dxBitmap.nativeInitBitmapDC(bitmap.getWidth(),
                bitmap.getHeight(), pixels);
    }

    private static byte[] getPixels(final Bitmap bitmap) {
        if (bitmap != null) {
            final byte[] pixels = new byte[bitmap.getWidth()
                    * bitmap.getHeight() * 4];
            final ByteBuffer buf = ByteBuffer.wrap(pixels);
            buf.order(ByteOrder.nativeOrder());
            bitmap.copyPixelsToBuffer(buf);
            return pixels;
        }

        return null;
    }

    public static int getFontSizeAccordingHeight(int height) {
        TextPaint paint = new TextPaint();
        Rect bounds = new Rect();

        paint.setTypeface(Typeface.DEFAULT);
        int text_size = 1;
        boolean found_desired_size = false;

        while (!found_desired_size) {
            paint.setTextSize(text_size);
            String text = "SghMNy";
            paint.getTextBounds(text, 0, text.length(), bounds);

            text_size++;

            if (height - bounds.height() <= 2) {
                found_desired_size = true;
            }
        }
        return text_size;
    }

    private static String getStringWithEllipsis(String string, float width,
                                                float fontSize) {
        if (TextUtils.isEmpty(string)) {
            return "";
        }

        TextPaint paint = new TextPaint();
        paint.setTypeface(Typeface.DEFAULT);
        paint.setTextSize(fontSize);

        return TextUtils.ellipsize(string, paint, width,
                TextUtils.TruncateAt.END).toString();
    }
}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/Cocos2dxDownloader.java #-}
package org.cocos2dx.lib;

import com.loopj.android.http.AsyncHttpClient;
import com.loopj.android.http.AsyncHttpResponseHandler;
import com.loopj.android.http.BinaryHttpResponseHandler;
import com.loopj.android.http.FileAsyncHttpResponseHandler;
import com.loopj.android.http.RequestHandle;

import org.apache.http.Header;
import org.apache.http.message.BasicHeader;

import java.io.File;
import java.util.*;

class DataTaskHandler extends BinaryHttpResponseHandler {
    int _id;
    private Cocos2dxDownloader _downloader;
    private long _lastBytesWritten;

    void LogD(String msg) {
        android.util.Log.d("Cocos2dxDownloader", msg);
    }

    public DataTaskHandler(Cocos2dxDownloader downloader, int id) {
        super(new String[]{".*"});
        _downloader = downloader;
        _id = id;
        _lastBytesWritten = 0;
    }

    @Override
    public void onProgress(long bytesWritten, long totalSize) {
        //LogD("onProgress(bytesWritten:" + bytesWritten + " totalSize:" + totalSize);
        long dlBytes = bytesWritten - _lastBytesWritten;
        long dlNow = bytesWritten;
        long dlTotal = totalSize;
        _downloader.onProgress(_id, dlBytes, dlNow, dlTotal);
        _lastBytesWritten = bytesWritten;
    }

    @Override
    public void onStart() {
        _downloader.onStart(_id);
    }

    @Override
    public void onFailure(int i, Header[] headers, byte[] errorResponse, Throwable throwable) {
        LogD("onFailure(i:" + i + " headers:" + headers + " throwable:" + throwable);
        String errStr = "";
        if (null != throwable) {
            errStr = throwable.toString();
        }
        _downloader.onFinish(_id, i, errStr, null);
    }

    @Override
    public void onSuccess(int i, Header[] headers, byte[] binaryData) {
        LogD("onSuccess(i:" + i + " headers:" + headers);
        _downloader.onFinish(_id, 0, null, binaryData);
    }
}

class FileTaskHandler extends FileAsyncHttpResponseHandler {
    int _id;
    File _finalFile;

    private long _initFileLen;
    private long _lastBytesWritten;
    private Cocos2dxDownloader _downloader;

    void LogD(String msg) {
        android.util.Log.d("Cocos2dxDownloader", msg);
    }

    public FileTaskHandler(Cocos2dxDownloader downloader, int id, File temp, File finalFile) {
        super(temp, true);
        _finalFile = finalFile;
        _downloader = downloader;
        _id = id;
        _initFileLen = getTargetFile().length();
        _lastBytesWritten = 0;
    }

    @Override
    public void onProgress(long bytesWritten, long totalSize) {
        //LogD("onProgress(bytesWritten:" + bytesWritten + " totalSize:" + totalSize);
        long dlBytes = bytesWritten - _lastBytesWritten;
        long dlNow = bytesWritten + _initFileLen;
        long dlTotal = totalSize + _initFileLen;
        _downloader.onProgress(_id, dlBytes, dlNow, dlTotal);
        _lastBytesWritten = bytesWritten;
    }

    @Override
    public void onStart() {
        _downloader.onStart(_id);
    }

    @Override
    public void onFinish() {
        // onFinish called after onSuccess/onFailure
    }

    @Override
    public void onFailure(int i, Header[] headers, Throwable throwable, File file) {
        LogD("onFailure(i:" + i + " headers:" + headers + " throwable:" + throwable + " file:" + file);
        String errStr = "";
        if (null != throwable) {
            errStr = throwable.toString();
        }
        _downloader.onFinish(_id, i, errStr, null);
    }

    @Override
    public void onSuccess(int i, Header[] headers, File file) {
        LogD("onSuccess(i:" + i + " headers:" + headers + " file:" + file);
        String errStr = null;
        do {
            // rename temp file to final file
            // if final file exist, remove it
            if (_finalFile.exists()) {
                if (_finalFile.isDirectory()) {
                    errStr = "Dest file is directory:" + _finalFile.getAbsolutePath();
                    break;
                }
                if (false == _finalFile.delete()) {
                    errStr = "Can't remove old file:" + _finalFile.getAbsolutePath();
                    break;
                }
            }

            File tempFile = getTargetFile();
            tempFile.renameTo(_finalFile);
        } while (false);
        _downloader.onFinish(_id, 0, errStr, null);
    }
}

class DownloadTask {

    DownloadTask() {
        handle = null;
        handler = null;
        resetStatus();
    }

    void resetStatus() {
        bytesReceived = 0;
        totalBytesReceived = 0;
        totalBytesExpected = 0;
        data = null;
    }

    RequestHandle handle;
    AsyncHttpResponseHandler handler;

    // progress
    long bytesReceived;
    long totalBytesReceived;
    long totalBytesExpected;
    byte[] data;

}

public class Cocos2dxDownloader {
    private int _id;
    private AsyncHttpClient _httpClient = new AsyncHttpClient();
    private String _tempFileNameSufix;
    private HashMap _taskMap = new HashMap();

    void onProgress(final int id, final long downloadBytes, final long downloadNow, final long downloadTotal) {
        DownloadTask task = (DownloadTask)_taskMap.get(id);
        if (null != task) {
            task.bytesReceived = downloadBytes;
            task.totalBytesReceived = downloadNow;
            task.totalBytesExpected = downloadTotal;
        }
        Cocos2dxHelper.runOnGLThread(new Runnable() {
            @Override
            public void run() {
                nativeOnProgress(_id, id, downloadBytes, downloadNow, downloadTotal);
            }
        });
    }

    public void onStart(int id) {
        DownloadTask task = (DownloadTask)_taskMap.get(id);
        if (null != task) {
            task.resetStatus();
        }
    }

    public void onFinish(final int id, final int errCode, final String errStr, final byte[] data) {
        DownloadTask task = (DownloadTask)_taskMap.get(id);
        if (null == task) return;
        _taskMap.remove(id);
        Cocos2dxHelper.runOnGLThread(new Runnable() {
            @Override
            public void run() {
                nativeOnFinish(_id, id, errCode, errStr, data);
            }
        });
    }

    public static Cocos2dxDownloader createDownloader(int id, int timeoutInSeconds, String tempFileNameSufix) {
        Cocos2dxDownloader downloader = new Cocos2dxDownloader();
        downloader._id = id;

        downloader._httpClient.setEnableRedirects(true);
        if (timeoutInSeconds > 0) {
            downloader._httpClient.setTimeout(timeoutInSeconds * 1000);
        }
        // downloader._httpClient.setMaxRetriesAndTimeout(3, timeoutInSeconds * 1000);
        downloader._httpClient.allowRetryExceptionClass(javax.net.ssl.SSLException.class);

        downloader._tempFileNameSufix = tempFileNameSufix;
        return downloader;
    }

    public static void createTask(final Cocos2dxDownloader downloader, int id_, String url_, String path_) {
        final int id = id_;
        final String url = url_;
        final String path = path_;

        Cocos2dxHelper.getActivity().runOnUiThread(new Runnable() {
            @Override
            public void run() {
                DownloadTask task = new DownloadTask();
                if (0 == path.length()) {
                    // data task
                    task.handler = new DataTaskHandler(downloader, id);
                    task.handle = downloader._httpClient.get(Cocos2dxHelper.getActivity(), url, task.handler);
                }

                do {
                    if (0 == path.length()) break;
                    // file task
                    File tempFile = new File(path + downloader._tempFileNameSufix);
                    if (tempFile.isDirectory()) break;

                    File parent = tempFile.getParentFile();
                    if (!parent.isDirectory() && !parent.mkdirs()) break;

                    File finalFile = new File(path);
                    if (tempFile.isDirectory()) break;

                    task.handler = new FileTaskHandler(downloader, id, tempFile, finalFile);
                    Header[] headers = null;
                    long fileLen = tempFile.length();
                    if (fileLen > 0) {
                        // continue download
                        List<Header> list = new ArrayList<Header>();
                        list.add(new BasicHeader("Range", "bytes=" + fileLen + "-"));
                        headers = list.toArray(new Header[list.size()]);
                    }
                    task.handle = downloader._httpClient.get(Cocos2dxHelper.getActivity(), url, headers, null, task.handler);
                    //task.handle = downloader._httpClient.get(url, task.handler);
                } while (false);

                if (null == task.handle) {
                    final String errStr = "Can't create DownloadTask for " + url;
                    Cocos2dxHelper.runOnGLThread(new Runnable() {
                        @Override
                        public void run() {
                            downloader.nativeOnFinish(downloader._id, id, 0, errStr, null);
                        }
                    });
                } else {
                    downloader._taskMap.put(id, task);
                }
            }
        });
    }

    public static void cancelAllRequests(final Cocos2dxDownloader downloader) {
        Cocos2dxHelper.getActivity().runOnUiThread(new Runnable() {
            @Override
            public void run() {

                //downloader._httpClient.cancelAllRequests(true);
                Iterator iter = downloader._taskMap.entrySet().iterator();
                while (iter.hasNext()) {
                    Map.Entry entry = (Map.Entry) iter.next();
                    //Object key = entry.getKey();
                    DownloadTask task = (DownloadTask) entry.getValue();
                    if (null != task.handle) {
                        task.handle.cancel(true);
                    }
                }
            }
        });
    }

    native void nativeOnProgress(int id, int taskId, long dl, long dlnow, long dltotal);
    native void nativeOnFinish(int id, int taskId, int errCode, String errStr, final byte[] data);
}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/Cocos2dxEditBox.java #-}
/****************************************************************************
Copyright (c) 2010-2012 cocos2d-x.org
Copyright (c) 2013-2015 Chukong Technologies Inc.

http://www.cocos2d-x.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 ****************************************************************************/
package org.cocos2dx.lib;

import android.content.Context;
import android.graphics.Color;
import android.graphics.Typeface;
import android.text.InputFilter;
import android.text.InputType;
import android.text.method.PasswordTransformationMethod;
import android.util.Log;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.View;
import android.view.inputmethod.EditorInfo;
import android.widget.EditText;
import android.widget.FrameLayout;

public class Cocos2dxEditBox extends EditText {
    /**
     * The user is allowed to enter any text, including line breaks.
     */
    private final int kEditBoxInputModeAny = 0;

    /**
     * The user is allowed to enter an e-mail address.
     */
    private final int kEditBoxInputModeEmailAddr = 1;

    /**
     * The user is allowed to enter an integer value.
     */
    private final int kEditBoxInputModeNumeric = 2;

    /**
     * The user is allowed to enter a phone number.
     */
    private final int kEditBoxInputModePhoneNumber = 3;

    /**
     * The user is allowed to enter a URL.
     */
    private final int kEditBoxInputModeUrl = 4;

    /**
     * The user is allowed to enter a real number value. This extends kEditBoxInputModeNumeric by allowing a decimal point.
     */
    private final int kEditBoxInputModeDecimal = 5;

    /**
     * The user is allowed to enter any text, except for line breaks.
     */
    private final int kEditBoxInputModeSingleLine = 6;

    /**
     * Indicates that the text entered is confidential data that should be obscured whenever possible. This implies EDIT_BOX_INPUT_FLAG_SENSITIVE.
     */
    private final int kEditBoxInputFlagPassword = 0;

    /**
     * Indicates that the text entered is sensitive data that the implementation must never store into a dictionary or table for use in predictive, auto-completing, or other accelerated input schemes. A credit card number is an example of sensitive data.
     */
    private final int kEditBoxInputFlagSensitive = 1;

    /**
     * This flag is a hint to the implementation that during text editing, the initial letter of each word should be capitalized.
     */
    private final int kEditBoxInputFlagInitialCapsWord = 2;

    /**
     * This flag is a hint to the implementation that during text editing, the initial letter of each sentence should be capitalized.
     */
    private final int kEditBoxInputFlagInitialCapsSentence = 3;

    /**
     * Capitalize all characters automatically.
     */
    private final int kEditBoxInputFlagInitialCapsAllCharacters = 4;

    private final int kKeyboardReturnTypeDefault = 0;
    private final int kKeyboardReturnTypeDone = 1;
    private final int kKeyboardReturnTypeSend = 2;
    private final int kKeyboardReturnTypeSearch = 3;
    private final int kKeyboardReturnTypeGo = 4;

    private int mInputFlagConstraints;
    private int mInputModeConstraints;
    private  int mMaxLength;

    //OpenGL view scaleX
    private  float mScaleX;




    public  Cocos2dxEditBox(Context context){
        super(context);
    }

    public void setEditBoxViewRect(int left, int top, int maxWidth, int maxHeight) {
        FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT,
                                                                            FrameLayout.LayoutParams.WRAP_CONTENT);
        layoutParams.leftMargin = left;
        layoutParams.topMargin = top;
        layoutParams.width = maxWidth;
        layoutParams.height = maxHeight;
        layoutParams.gravity = Gravity.TOP | Gravity.LEFT;
        this.setLayoutParams(layoutParams);
    }

    public float getOpenGLViewScaleX() {
        return mScaleX;
    }

    public void setOpenGLViewScaleX(float mScaleX) {
        this.mScaleX = mScaleX;
    }


    public  void setMaxLength(int maxLength){
        this.mMaxLength = maxLength;

        this.setFilters(new InputFilter[]{new InputFilter.LengthFilter(this.mMaxLength) });
    }

    public void setMultilineEnabled(boolean flag){
        this.mInputModeConstraints |= InputType.TYPE_TEXT_FLAG_MULTI_LINE;
    }

    public void setReturnType(int returnType) {
        switch (returnType) {
            case kKeyboardReturnTypeDefault:
                this.setImeOptions(EditorInfo.IME_ACTION_NONE | EditorInfo.IME_FLAG_NO_EXTRACT_UI);
                break;
            case kKeyboardReturnTypeDone:
                this.setImeOptions(EditorInfo.IME_ACTION_DONE | EditorInfo.IME_FLAG_NO_EXTRACT_UI);
                break;
            case kKeyboardReturnTypeSend:
                this.setImeOptions(EditorInfo.IME_ACTION_SEND | EditorInfo.IME_FLAG_NO_EXTRACT_UI);
                break;
            case kKeyboardReturnTypeSearch:
                this.setImeOptions(EditorInfo.IME_ACTION_SEARCH | EditorInfo.IME_FLAG_NO_EXTRACT_UI);
                break;
            case kKeyboardReturnTypeGo:
                this.setImeOptions(EditorInfo.IME_ACTION_GO | EditorInfo.IME_FLAG_NO_EXTRACT_UI);
                break;
            default:
                this.setImeOptions(EditorInfo.IME_ACTION_NONE | EditorInfo.IME_FLAG_NO_EXTRACT_UI);
                break;
        }
    }

    public  void setInputMode(int inputMode){

        switch (inputMode) {
            case kEditBoxInputModeAny:
                this.mInputModeConstraints = InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_FLAG_MULTI_LINE;
                break;
            case kEditBoxInputModeEmailAddr:
                this.mInputModeConstraints = InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_EMAIL_ADDRESS;
                break;
            case kEditBoxInputModeNumeric:
                this.mInputModeConstraints = InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_SIGNED;
                break;
            case kEditBoxInputModePhoneNumber:
                this.mInputModeConstraints = InputType.TYPE_CLASS_PHONE;
                break;
            case kEditBoxInputModeUrl:
                this.mInputModeConstraints = InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_URI;
                break;
            case kEditBoxInputModeDecimal:
                this.mInputModeConstraints = InputType.TYPE_CLASS_NUMBER | InputType.TYPE_NUMBER_FLAG_DECIMAL | InputType.TYPE_NUMBER_FLAG_SIGNED;
                break;
            case kEditBoxInputModeSingleLine:
                this.mInputModeConstraints = InputType.TYPE_CLASS_TEXT;
                break;
            default:

                break;
        }

        this.setInputType(this.mInputModeConstraints | this.mInputFlagConstraints);

    }

    @Override
    public boolean onKeyDown(final int pKeyCode, final KeyEvent pKeyEvent) {
        switch (pKeyCode) {
            case KeyEvent.KEYCODE_BACK:
                Cocos2dxActivity activity = (Cocos2dxActivity)this.getContext();
                //To prevent program from going to background
                activity.getGLSurfaceView().requestFocus();
                return true;
            default:
                return super.onKeyDown(pKeyCode, pKeyEvent);
        }
    }

    @Override
    public boolean onKeyPreIme(int keyCode, KeyEvent event) {
        return super.onKeyPreIme(keyCode, event);
    }

    public void setInputFlag(int inputFlag) {

        switch (inputFlag) {
            case kEditBoxInputFlagPassword:
                this.mInputFlagConstraints = InputType.TYPE_CLASS_TEXT | InputType.TYPE_TEXT_VARIATION_PASSWORD;
                this.setTypeface(Typeface.DEFAULT);
                this.setTransformationMethod(new PasswordTransformationMethod());
                break;
            case kEditBoxInputFlagSensitive:
                this.mInputFlagConstraints = InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS;
                break;
            case kEditBoxInputFlagInitialCapsWord:
                this.mInputFlagConstraints = InputType.TYPE_TEXT_FLAG_CAP_WORDS;
                break;
            case kEditBoxInputFlagInitialCapsSentence:
                this.mInputFlagConstraints = InputType.TYPE_TEXT_FLAG_CAP_SENTENCES;
                break;
            case kEditBoxInputFlagInitialCapsAllCharacters:
                this.mInputFlagConstraints = InputType.TYPE_TEXT_FLAG_CAP_CHARACTERS;
                break;
            default:
                break;
        }

        this.setInputType(this.mInputFlagConstraints | this.mInputModeConstraints);
    }
}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/Cocos2dxEditBoxHelper.java #-}
/****************************************************************************
Copyright (c) 2010-2012 cocos2d-x.org
Copyright (c) 2013-2015 Chukong Technologies Inc.

http://www.cocos2d-x.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 ****************************************************************************/
package org.cocos2dx.lib;

import android.content.Context;
import android.content.res.Resources;
import android.graphics.Color;
import android.graphics.Typeface;
import android.text.Editable;
import android.text.InputType;
import android.text.TextWatcher;
import android.util.Log;
import android.util.SparseArray;
import android.util.TypedValue;
import android.view.Gravity;
import android.view.KeyEvent;
import android.view.View;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.FrameLayout;
import android.widget.TextView;


public class Cocos2dxEditBoxHelper {
    private static final String TAG = Cocos2dxEditBoxHelper.class.getSimpleName();
    private static Cocos2dxActivity mCocos2dxActivity;
    private static ResizeLayout mFrameLayout;

    private static SparseArray<Cocos2dxEditBox> mEditBoxArray;
    private static int mViewTag = 0;

    //Call native methods
    private static native void editBoxEditingDidBegin(int index);
    public static void __editBoxEditingDidBegin(int index){
        editBoxEditingDidBegin(index);
    }

    private static native void editBoxEditingChanged(int index, String text);
    public static void __editBoxEditingChanged(int index, String text){
        editBoxEditingChanged(index, text);
    }

    private static native void editBoxEditingDidEnd(int index, String text);
    public static void __editBoxEditingDidEnd(int index, String text){
        editBoxEditingDidEnd(index, text);
    }


    public Cocos2dxEditBoxHelper(ResizeLayout layout) {
        Cocos2dxEditBoxHelper.mFrameLayout = layout;

        Cocos2dxEditBoxHelper.mCocos2dxActivity = (Cocos2dxActivity) Cocos2dxActivity.getContext();
        Cocos2dxEditBoxHelper.mEditBoxArray = new SparseArray<Cocos2dxEditBox>();
    }

    public static int convertToSP(float point){
        Resources r = mCocos2dxActivity.getResources();

        int convertedValue = (int)TypedValue.applyDimension(
                TypedValue.COMPLEX_UNIT_SP, point, r.getDisplayMetrics());

        return  convertedValue;

    }

    public static int createEditBox(final int left, final int top, final int width, final int height, final float scaleX) {
        final int index = mViewTag;
        mCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                final Cocos2dxEditBox editBox = new Cocos2dxEditBox(mCocos2dxActivity);
                editBox.setFocusable(true);
                editBox.setFocusableInTouchMode(true);
                editBox.setInputFlag(4); //kEditBoxInputFlagInitialCapsAllCharacters
                editBox.setInputMode(6); //kEditBoxInputModeSingleLine
                editBox.setReturnType(0);  //kKeyboardReturnTypeDefault
                editBox.setHintTextColor(Color.GRAY);
                editBox.setVisibility(View.INVISIBLE);
                editBox.setBackgroundColor(Color.TRANSPARENT);
                editBox.setTextColor(Color.WHITE);
                editBox.setSingleLine();
                editBox.setOpenGLViewScaleX(scaleX);
                Resources r = mCocos2dxActivity.getResources();
                float density =  r.getDisplayMetrics().density;
                int paddingBottom = (int)(height * 0.33f / density);
                paddingBottom = convertToSP(paddingBottom  - 5 * scaleX / density);
                paddingBottom = paddingBottom / 2;
                int paddingTop = paddingBottom;
                int paddingLeft = (int)(5 * scaleX / density);
                paddingLeft = convertToSP(paddingLeft);

                editBox.setPadding(paddingLeft,paddingTop, 0, paddingBottom);


                FrameLayout.LayoutParams lParams = new FrameLayout.LayoutParams(
                        FrameLayout.LayoutParams.WRAP_CONTENT,
                        FrameLayout.LayoutParams.WRAP_CONTENT);

                lParams.leftMargin = left;
                lParams.topMargin = top;
                lParams.width = width;
                lParams.height = height;
                lParams.gravity = Gravity.TOP | Gravity.LEFT;

                mFrameLayout.addView(editBox, lParams);

                editBox.addTextChangedListener(new TextWatcher() {
                    @Override
                    public void beforeTextChanged(CharSequence s, int start, int count, int after) {
                    }

                    @Override
                    public void onTextChanged(final CharSequence s, int start, int before, int count) {
                        //The optimization can't be turn on due to unknown keyboard hide in some custom keyboard
//                        mFrameLayout.setEnableForceDoLayout(false);

                        mCocos2dxActivity.runOnGLThread(new Runnable() {
                            @Override
                            public void run() {
                                Cocos2dxEditBoxHelper.__editBoxEditingChanged(index, s.toString());
                            }
                        });
                    }

                    @Override
                    public void afterTextChanged(Editable s) {

                    }
                });


                editBox.setOnFocusChangeListener(new View.OnFocusChangeListener() {

                    @Override
                    public void onFocusChange(View v, boolean hasFocus) {
                        if (hasFocus) {
                            mCocos2dxActivity.runOnGLThread(new Runnable() {
                                @Override
                                public void run() {
                                    Cocos2dxEditBoxHelper.__editBoxEditingDidBegin(index);
                                }
                            });
                            editBox.setSelection(editBox.getText().length());
                            mFrameLayout.setEnableForceDoLayout(true);
                            mCocos2dxActivity.getGLSurfaceView().setSoftKeyboardShown(true);
                            Log.d(TAG, "edit box get focus");
                        } else {
                            editBox.setVisibility(View.GONE);
                            mCocos2dxActivity.runOnGLThread(new Runnable() {
                                @Override
                                public void run() {
                                    Cocos2dxEditBoxHelper.__editBoxEditingDidEnd(index, editBox.getText().toString());
                                }
                            });
                            mFrameLayout.setEnableForceDoLayout(false);
                            Log.d(TAG, "edit box lose focus");
                        }
                    }
                });

                editBox.setOnKeyListener(new View.OnKeyListener() {
                    public boolean onKey(View v, int keyCode, KeyEvent event) {
                        // If the event is a key-down event on the "enter" button
                        if ((event.getAction() == KeyEvent.ACTION_DOWN) &&
                                (keyCode == KeyEvent.KEYCODE_ENTER)) {
                            //if editbox doesn't support multiline, just hide the keyboard
                            if ((editBox.getInputType() & InputType.TYPE_TEXT_FLAG_MULTI_LINE) != InputType.TYPE_TEXT_FLAG_MULTI_LINE) {
                                Cocos2dxEditBoxHelper.closeKeyboard(index);
                                mCocos2dxActivity.getGLSurfaceView().requestFocus();
                                return true;
                            }
                        }
                        return false;
                    }
                });


                editBox.setOnEditorActionListener(new TextView.OnEditorActionListener() {
                    @Override
                    public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
                        if (actionId == EditorInfo.IME_ACTION_DONE) {
                            Cocos2dxEditBoxHelper.closeKeyboard(index);
                            mCocos2dxActivity.getGLSurfaceView().requestFocus();
                        }
                        return false;
                    }
                });

                mEditBoxArray.put(index, editBox);
            }
        });
        return mViewTag++;
    }

    public static void removeEditBox(final int index) {
        mCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxEditBox editBox = mEditBoxArray.get(index);
                if (editBox != null) {
                    mEditBoxArray.remove(index);
                    mFrameLayout.removeView(editBox);
                    Log.e(TAG, "remove EditBox");
                }
            }
        });
    }

    public static void setFont(final int index, final String fontName, final float fontSize){
        mCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxEditBox editBox = mEditBoxArray.get(index);
                if (editBox != null) {
                    Typeface tf;
                    if (!fontName.isEmpty()) {
                        tf  =  Typeface.create(fontName, Typeface.NORMAL);
                    }else{
                        tf = Typeface.DEFAULT;
                    }
                    //TODO: The font size is not the same across all the anroid devices...
                    if (fontSize >= 0){
                        float density =  mCocos2dxActivity.getResources().getDisplayMetrics().density;
//                        Log.e("XXX", "density is " + density);
                        editBox.setTextSize(TypedValue.COMPLEX_UNIT_SP,
                                fontSize / density );
                    }
                    editBox.setTypeface(tf);
                }
            }
        });
    }

    public static void setFontColor(final int index, final int red, final int green, final int blue, final int alpha){
        mCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxEditBox editBox = mEditBoxArray.get(index);
                if (editBox != null) {
                    editBox.setTextColor(Color.argb(alpha, red, green, blue));
                }
            }
        });
    }

    public static void setPlaceHolderText(final int index, final String text){
        mCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxEditBox editBox = mEditBoxArray.get(index);
                if (editBox != null) {
                    editBox.setHint(text);
                }
            }
        });
    }

    public static void setPlaceHolderTextColor(final int index, final int red, final int green, final int blue, final int alpha){
        mCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxEditBox editBox = mEditBoxArray.get(index);
                if (editBox != null) {
                    editBox.setHintTextColor(Color.argb(alpha, red, green, blue));
                }
            }
        });
    }

    public static void setMaxLength(final int index, final int maxLength) {
        mCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxEditBox editBox = mEditBoxArray.get(index);
                if (editBox != null) {
                    editBox.setMaxLength(maxLength);
                }
            }
        });
    }

    public static void setVisible(final int index, final boolean visible) {
        mCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxEditBox editBox = mEditBoxArray.get(index);
                if (editBox != null) {
                    editBox.setVisibility(visible ? View.VISIBLE : View.GONE);
                    if (visible) {
                        editBox.requestFocus();
                        Cocos2dxEditBoxHelper.openKeyboard(index);
                    }else{
                        mCocos2dxActivity.getGLSurfaceView().requestFocus();
                        Cocos2dxEditBoxHelper.closeKeyboard(index);
                    }
                }
            }
        });
    }


    public static void setText(final int index, final String text){
        mCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxEditBox editBox = mEditBoxArray.get(index);
                if (editBox != null) {
                    editBox.setText(text);
                }
            }
        });
    }

    public static void setReturnType(final int index, final int returnType) {
        mCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxEditBox editBox = mEditBoxArray.get(index);
                if (editBox != null) {
                    editBox.setReturnType(returnType);
                }
            }
        });
    }

    public static void setInputMode(final int index, final int inputMode) {
        mCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxEditBox editBox = mEditBoxArray.get(index);
                if (editBox != null) {
                    editBox.setInputMode(inputMode);
                }
            }
        });
    }

    public static void setInputFlag(final int index, final int inputFlag) {
        mCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxEditBox editBox = mEditBoxArray.get(index);
                if (editBox != null) {
                    editBox.setInputFlag(inputFlag);
                }
            }
        });
    }


    public static void setEditBoxViewRect(final int index, final int left, final int top, final int maxWidth, final int maxHeight) {
        mCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxEditBox editBox = mEditBoxArray.get(index);
                if (editBox != null) {
                    editBox.setEditBoxViewRect(left, top, maxWidth, maxHeight);
                }
            }
        });
    }



    public static void openKeyboard(int index) {
        final InputMethodManager imm = (InputMethodManager) mCocos2dxActivity.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
        Cocos2dxEditBox editBox = mEditBoxArray.get(index);
        if (null != editBox) {
            imm.showSoftInput(editBox, 0);
            mCocos2dxActivity.getGLSurfaceView().setSoftKeyboardShown(true);
        }
    }

    public static void closeKeyboard(int index) {
        final InputMethodManager imm = (InputMethodManager) mCocos2dxActivity.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
        Cocos2dxEditBox editBox = mEditBoxArray.get(index);
        if (null != editBox) {
            imm.hideSoftInputFromWindow(editBox.getWindowToken(), 0);
            mCocos2dxActivity.getGLSurfaceView().setSoftKeyboardShown(false);
        }
    }
}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/Cocos2dxGLSurfaceView.java #-}
/****************************************************************************
Copyright (c) 2010-2011 cocos2d-x.org

http://www.cocos2d-x.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 ****************************************************************************/
package org.cocos2dx.lib;

import android.app.Activity;
import android.content.Context;
import android.opengl.GLSurfaceView;
import android.os.Handler;
import android.os.Message;
import android.util.AttributeSet;
import android.util.Log;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.View;
import android.view.inputmethod.InputMethodManager;

public class Cocos2dxGLSurfaceView extends GLSurfaceView {
    // ===========================================================
    // Constants
    // ===========================================================

    private static final String TAG = Cocos2dxGLSurfaceView.class.getSimpleName();

    private final static int HANDLER_OPEN_IME_KEYBOARD = 2;
    private final static int HANDLER_CLOSE_IME_KEYBOARD = 3;

    // ===========================================================
    // Fields
    // ===========================================================

    // TODO Static handler -> Potential leak!
    private static Handler sHandler;

    private static Cocos2dxGLSurfaceView mCocos2dxGLSurfaceView;
    private static Cocos2dxTextInputWraper sCocos2dxTextInputWraper;

    private Cocos2dxRenderer mCocos2dxRenderer;
    private Cocos2dxEditBox mCocos2dxEditText;

    public boolean isSoftKeyboardShown() {
        return mSoftKeyboardShown;
    }

    public void setSoftKeyboardShown(boolean softKeyboardShown) {
        this.mSoftKeyboardShown = softKeyboardShown;
    }

    private boolean mSoftKeyboardShown = false;


    // ===========================================================
    // Constructors
    // ===========================================================

    public Cocos2dxGLSurfaceView(final Context context) {
        super(context);

        this.initView();
    }

    public Cocos2dxGLSurfaceView(final Context context, final AttributeSet attrs) {
        super(context, attrs);
        
        this.initView();
    }

    protected void initView() {
        this.setEGLContextClientVersion(2);
        this.setFocusableInTouchMode(true);

        Cocos2dxGLSurfaceView.mCocos2dxGLSurfaceView = this;
        Cocos2dxGLSurfaceView.sCocos2dxTextInputWraper = new Cocos2dxTextInputWraper(this);

        Cocos2dxGLSurfaceView.sHandler = new Handler() {
            @Override
            public void handleMessage(final Message msg) {
                switch (msg.what) {
                    case HANDLER_OPEN_IME_KEYBOARD:
                        if (null != Cocos2dxGLSurfaceView.this.mCocos2dxEditText && Cocos2dxGLSurfaceView.this.mCocos2dxEditText.requestFocus()) {
                            Cocos2dxGLSurfaceView.this.mCocos2dxEditText.removeTextChangedListener(Cocos2dxGLSurfaceView.sCocos2dxTextInputWraper);
                            Cocos2dxGLSurfaceView.this.mCocos2dxEditText.setText("");
                            final String text = (String) msg.obj;
                            Cocos2dxGLSurfaceView.this.mCocos2dxEditText.append(text);
                            Cocos2dxGLSurfaceView.sCocos2dxTextInputWraper.setOriginText(text);
                            Cocos2dxGLSurfaceView.this.mCocos2dxEditText.addTextChangedListener(Cocos2dxGLSurfaceView.sCocos2dxTextInputWraper);
                            final InputMethodManager imm = (InputMethodManager) Cocos2dxGLSurfaceView.mCocos2dxGLSurfaceView.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
                            imm.showSoftInput(Cocos2dxGLSurfaceView.this.mCocos2dxEditText, 0);
                            Log.d("GLSurfaceView", "showSoftInput");
                        }
                        break;

                    case HANDLER_CLOSE_IME_KEYBOARD:
                        if (null != Cocos2dxGLSurfaceView.this.mCocos2dxEditText) {
                            Cocos2dxGLSurfaceView.this.mCocos2dxEditText.removeTextChangedListener(Cocos2dxGLSurfaceView.sCocos2dxTextInputWraper);
                            final InputMethodManager imm = (InputMethodManager) Cocos2dxGLSurfaceView.mCocos2dxGLSurfaceView.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
                            imm.hideSoftInputFromWindow(Cocos2dxGLSurfaceView.this.mCocos2dxEditText.getWindowToken(), 0);
                            Cocos2dxGLSurfaceView.this.requestFocus();
                            Log.d("GLSurfaceView", "HideSoftInput");
                        }
                        break;
                }
            }
        };
    }

    // ===========================================================
    // Getter & Setter
    // ===========================================================


       public static Cocos2dxGLSurfaceView getInstance() {
       return mCocos2dxGLSurfaceView;
       }

       public static void queueAccelerometer(final float x, final float y, final float z, final long timestamp) {   
       mCocos2dxGLSurfaceView.queueEvent(new Runnable() {
        @Override
            public void run() {
                Cocos2dxAccelerometer.onSensorChanged(x, y, z, timestamp);
        }
        });
    }

    public void setCocos2dxRenderer(final Cocos2dxRenderer renderer) {
        this.mCocos2dxRenderer = renderer;
        this.setRenderer(this.mCocos2dxRenderer);
    }

    private String getContentText() {
        return this.mCocos2dxRenderer.getContentText();
    }

    public Cocos2dxEditBox getCocos2dxEditText() {
        return this.mCocos2dxEditText;
    }

    public void setCocos2dxEditText(final Cocos2dxEditBox pCocos2dxEditText) {
        this.mCocos2dxEditText = pCocos2dxEditText;
        if (null != this.mCocos2dxEditText && null != Cocos2dxGLSurfaceView.sCocos2dxTextInputWraper) {
            this.mCocos2dxEditText.setOnEditorActionListener(Cocos2dxGLSurfaceView.sCocos2dxTextInputWraper);
            this.requestFocus();
        }
    }

    // ===========================================================
    // Methods for/from SuperClass/Interfaces
    // ===========================================================

    @Override
    public void onResume() {
        super.onResume();
        this.setRenderMode(RENDERMODE_CONTINUOUSLY);
        this.queueEvent(new Runnable() {
            @Override
            public void run() {
                Cocos2dxGLSurfaceView.this.mCocos2dxRenderer.handleOnResume();
            }
        });
    }

    @Override
    public void onPause() {
        this.queueEvent(new Runnable() {
            @Override
            public void run() {
                Cocos2dxGLSurfaceView.this.mCocos2dxRenderer.handleOnPause();
            }
        });
        this.setRenderMode(RENDERMODE_WHEN_DIRTY);
        //super.onPause();
    }

    @Override
    public boolean onTouchEvent(final MotionEvent pMotionEvent) {
        // these data are used in ACTION_MOVE and ACTION_CANCEL
        final int pointerNumber = pMotionEvent.getPointerCount();
        final int[] ids = new int[pointerNumber];
        final float[] xs = new float[pointerNumber];
        final float[] ys = new float[pointerNumber];

        if (mSoftKeyboardShown){
            InputMethodManager imm = (InputMethodManager)this.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
            View view = ((Activity)this.getContext()).getCurrentFocus();
            imm.hideSoftInputFromWindow(view.getWindowToken(),0);
            this.requestFocus();
            mSoftKeyboardShown = false;
        }

        for (int i = 0; i < pointerNumber; i++) {
            ids[i] = pMotionEvent.getPointerId(i);
            xs[i] = pMotionEvent.getX(i);
            ys[i] = pMotionEvent.getY(i);
        }

        switch (pMotionEvent.getAction() & MotionEvent.ACTION_MASK) {
            case MotionEvent.ACTION_POINTER_DOWN:
                final int indexPointerDown = pMotionEvent.getAction() >> MotionEvent.ACTION_POINTER_INDEX_SHIFT;
                final int idPointerDown = pMotionEvent.getPointerId(indexPointerDown);
                final float xPointerDown = pMotionEvent.getX(indexPointerDown);
                final float yPointerDown = pMotionEvent.getY(indexPointerDown);

                this.queueEvent(new Runnable() {
                    @Override
                    public void run() {
                        Cocos2dxGLSurfaceView.this.mCocos2dxRenderer.handleActionDown(idPointerDown, xPointerDown, yPointerDown);
                    }
                });
                break;

            case MotionEvent.ACTION_DOWN:
                // there are only one finger on the screen
                final int idDown = pMotionEvent.getPointerId(0);
                final float xDown = xs[0];
                final float yDown = ys[0];

                this.queueEvent(new Runnable() {
                    @Override
                    public void run() {
                        Cocos2dxGLSurfaceView.this.mCocos2dxRenderer.handleActionDown(idDown, xDown, yDown);
                    }
                });
                break;

            case MotionEvent.ACTION_MOVE:
                this.queueEvent(new Runnable() {
                    @Override
                    public void run() {
                        Cocos2dxGLSurfaceView.this.mCocos2dxRenderer.handleActionMove(ids, xs, ys);
                    }
                });
                break;

            case MotionEvent.ACTION_POINTER_UP:
                final int indexPointUp = pMotionEvent.getAction() >> MotionEvent.ACTION_POINTER_INDEX_SHIFT;
                final int idPointerUp = pMotionEvent.getPointerId(indexPointUp);
                final float xPointerUp = pMotionEvent.getX(indexPointUp);
                final float yPointerUp = pMotionEvent.getY(indexPointUp);

                this.queueEvent(new Runnable() {
                    @Override
                    public void run() {
                        Cocos2dxGLSurfaceView.this.mCocos2dxRenderer.handleActionUp(idPointerUp, xPointerUp, yPointerUp);
                    }
                });
                break;

            case MotionEvent.ACTION_UP:
                // there are only one finger on the screen
                final int idUp = pMotionEvent.getPointerId(0);
                final float xUp = xs[0];
                final float yUp = ys[0];

                this.queueEvent(new Runnable() {
                    @Override
                    public void run() {
                        Cocos2dxGLSurfaceView.this.mCocos2dxRenderer.handleActionUp(idUp, xUp, yUp);
                    }
                });
                break;

            case MotionEvent.ACTION_CANCEL:
                this.queueEvent(new Runnable() {
                    @Override
                    public void run() {
                        Cocos2dxGLSurfaceView.this.mCocos2dxRenderer.handleActionCancel(ids, xs, ys);
                    }
                });
                break;
        }

        /*
        if (BuildConfig.DEBUG) {
            Cocos2dxGLSurfaceView.dumpMotionEvent(pMotionEvent);
        }
        */
        return true;
    }

    /*
     * This function is called before Cocos2dxRenderer.nativeInit(), so the
     * width and height is correct.
     */
    @Override
    protected void onSizeChanged(final int pNewSurfaceWidth, final int pNewSurfaceHeight, final int pOldSurfaceWidth, final int pOldSurfaceHeight) {
        if(!this.isInEditMode()) {
            this.mCocos2dxRenderer.setScreenWidthAndHeight(pNewSurfaceWidth, pNewSurfaceHeight);
        }
    }

    @Override
    public boolean onKeyDown(final int pKeyCode, final KeyEvent pKeyEvent) {
        switch (pKeyCode) {
            case KeyEvent.KEYCODE_BACK:
                Cocos2dxVideoHelper.mVideoHandler.sendEmptyMessage(Cocos2dxVideoHelper.KeyEventBack);
            case KeyEvent.KEYCODE_MENU:
            case KeyEvent.KEYCODE_DPAD_LEFT:
            case KeyEvent.KEYCODE_DPAD_RIGHT:
            case KeyEvent.KEYCODE_DPAD_UP:
            case KeyEvent.KEYCODE_DPAD_DOWN:
            case KeyEvent.KEYCODE_ENTER:
            case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
            case KeyEvent.KEYCODE_DPAD_CENTER:
                this.queueEvent(new Runnable() {
                    @Override
                    public void run() {
                        Cocos2dxGLSurfaceView.this.mCocos2dxRenderer.handleKeyDown(pKeyCode);
                    }
                });
                return true;
            default:
                return super.onKeyDown(pKeyCode, pKeyEvent);
        }
    }

    @Override
    public boolean onKeyUp(final int keyCode, KeyEvent event) {
        switch (keyCode) {
            case KeyEvent.KEYCODE_BACK:
            case KeyEvent.KEYCODE_MENU:
            case KeyEvent.KEYCODE_DPAD_LEFT:
            case KeyEvent.KEYCODE_DPAD_RIGHT:
            case KeyEvent.KEYCODE_DPAD_UP:
            case KeyEvent.KEYCODE_DPAD_DOWN:
            case KeyEvent.KEYCODE_ENTER:
            case KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE:
            case KeyEvent.KEYCODE_DPAD_CENTER:
                this.queueEvent(new Runnable() {
                    @Override
                    public void run() {
                        Cocos2dxGLSurfaceView.this.mCocos2dxRenderer.handleKeyUp(keyCode);
                    }
                });
                return true;
            default:
                return super.onKeyUp(keyCode, event);
        }
    }

    // ===========================================================
    // Methods
    // ===========================================================

    // ===========================================================
    // Inner and Anonymous Classes
    // ===========================================================

    public static void openIMEKeyboard() {
        final Message msg = new Message();
        msg.what = Cocos2dxGLSurfaceView.HANDLER_OPEN_IME_KEYBOARD;
        msg.obj = Cocos2dxGLSurfaceView.mCocos2dxGLSurfaceView.getContentText();
        Cocos2dxGLSurfaceView.sHandler.sendMessage(msg);
    }

    public static void closeIMEKeyboard() {
        final Message msg = new Message();
        msg.what = Cocos2dxGLSurfaceView.HANDLER_CLOSE_IME_KEYBOARD;
        Cocos2dxGLSurfaceView.sHandler.sendMessage(msg);
    }

    public void insertText(final String pText) {
        this.queueEvent(new Runnable() {
            @Override
            public void run() {
                Cocos2dxGLSurfaceView.this.mCocos2dxRenderer.handleInsertText(pText);
            }
        });
    }

    public void deleteBackward() {
        this.queueEvent(new Runnable() {
            @Override
            public void run() {
                Cocos2dxGLSurfaceView.this.mCocos2dxRenderer.handleDeleteBackward();
            }
        });
    }

    private static void dumpMotionEvent(final MotionEvent event) {
        final String names[] = { "DOWN", "UP", "MOVE", "CANCEL", "OUTSIDE", "POINTER_DOWN", "POINTER_UP", "7?", "8?", "9?" };
        final StringBuilder sb = new StringBuilder();
        final int action = event.getAction();
        final int actionCode = action & MotionEvent.ACTION_MASK;
        sb.append("event ACTION_").append(names[actionCode]);
        if (actionCode == MotionEvent.ACTION_POINTER_DOWN || actionCode == MotionEvent.ACTION_POINTER_UP) {
            sb.append("(pid ").append(action >> MotionEvent.ACTION_POINTER_INDEX_SHIFT);
            sb.append(")");
        }
        sb.append("[");
        for (int i = 0; i < event.getPointerCount(); i++) {
            sb.append("#").append(i);
            sb.append("(pid ").append(event.getPointerId(i));
            sb.append(")=").append((int) event.getX(i));
            sb.append(",").append((int) event.getY(i));
            if (i + 1 < event.getPointerCount()) {
                sb.append(";");
            }
        }
        sb.append("]");
        Log.d(Cocos2dxGLSurfaceView.TAG, sb.toString());
    }
}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/Cocos2dxHandler.java #-}
/****************************************************************************
Copyright (c) 2010-2011 cocos2d-x.org

http://www.cocos2d-x.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 ****************************************************************************/

package org.cocos2dx.lib;

import android.app.AlertDialog;
import android.content.DialogInterface;
import android.os.Handler;
import android.os.Message;

import java.lang.ref.WeakReference;

public class Cocos2dxHandler extends Handler {
    // ===========================================================
    // Constants
    // ===========================================================
    public final static int HANDLER_SHOW_DIALOG = 1;

    // ===========================================================
    // Fields
    // ===========================================================
    private WeakReference<Cocos2dxActivity> mActivity;
    
    // ===========================================================
    // Constructors
    // ===========================================================
    public Cocos2dxHandler(Cocos2dxActivity activity) {
        this.mActivity = new WeakReference<Cocos2dxActivity>(activity);
    }

    // ===========================================================
    // Getter & Setter
    // ===========================================================

    // ===========================================================
    // Methods for/from SuperClass/Interfaces
    // ===========================================================
    
    // ===========================================================
    // Methods
    // ===========================================================

    public void handleMessage(Message msg) {
        switch (msg.what) {
            case Cocos2dxHandler.HANDLER_SHOW_DIALOG:
                showDialog(msg);
                break;
        }
    }
    
    private void showDialog(Message msg) {
        Cocos2dxActivity theActivity = this.mActivity.get();
        DialogMessage dialogMessage = (DialogMessage)msg.obj;
        new AlertDialog.Builder(theActivity)
        .setTitle(dialogMessage.titile)
        .setMessage(dialogMessage.message)
        .setPositiveButton("Ok", 
                new DialogInterface.OnClickListener() {
                    
                    @Override
                    public void onClick(DialogInterface dialog, int which) {
                        // TODO Auto-generated method stub
                        
                    }
                }).create().show();
    }

    
    // ===========================================================
    // Inner and Anonymous Classes
    // ===========================================================
    
    public static class DialogMessage {
        public String titile;
        public String message;
        
        public DialogMessage(String title, String message) {
            this.titile = title;
            this.message = message;
        }
    }
}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/Cocos2dxHelper.java #-}
/****************************************************************************
Copyright (c) 2010-2012 cocos2d-x.org
Copyright (c) 2013-2014 Chukong Technologies Inc.

http://www.cocos2d-x.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 ****************************************************************************/
package org.cocos2dx.lib;

import android.app.Activity;
import android.content.ComponentName;
import android.content.Context;
import android.content.Intent;
import android.content.ServiceConnection;
import android.content.SharedPreferences;
import android.content.pm.ApplicationInfo;
import android.content.res.AssetManager;
import android.net.Uri;
import android.os.Build;
import android.os.IBinder;
import android.os.Vibrator;
import android.preference.PreferenceManager.OnActivityResultListener;
import android.util.DisplayMetrics;
import android.view.Display;
import android.view.WindowManager;

import com.chukong.cocosplay.client.CocosPlayClient;
import com.enhance.gameservice.IGameTuningService;

import java.io.UnsupportedEncodingException;
import java.util.LinkedHashSet;
import java.util.Locale;
import java.util.Map;
import java.util.Set;

public class Cocos2dxHelper {
    // ===========================================================
    // Constants
    // ===========================================================
    private static final String PREFS_NAME = "Cocos2dxPrefsFile";
    private static final int RUNNABLES_PER_FRAME = 5;

    // ===========================================================
    // Fields
    // ===========================================================

    private static Cocos2dxMusic sCocos2dMusic;
    private static Cocos2dxSound sCocos2dSound;
    private static AssetManager sAssetManager;
    private static Cocos2dxAccelerometer sCocos2dxAccelerometer;
    private static boolean sAccelerometerEnabled;
    private static boolean sActivityVisible;
    private static String sPackageName;
    private static String sFileDirectory;
    private static Activity sActivity = null;
    private static Cocos2dxHelperListener sCocos2dxHelperListener;
    private static Set<OnActivityResultListener> onActivityResultListeners = new LinkedHashSet<OnActivityResultListener>();
    private static Vibrator sVibrateService = null;
    //Enhance API modification begin
    private static IGameTuningService mGameServiceBinder = null;
    private static final int BOOST_TIME = 7;
    //Enhance API modification end

    // ===========================================================
    // Constructors
    // ===========================================================

    public static void runOnGLThread(final Runnable r) {
        ((Cocos2dxActivity)sActivity).runOnGLThread(r);
    }

    private static boolean sInited = false;
    public static void init(final Activity activity) {
        sActivity = activity;
        Cocos2dxHelper.sCocos2dxHelperListener = (Cocos2dxHelperListener)activity;
        if (!sInited) {
            final ApplicationInfo applicationInfo = activity.getApplicationInfo();
                    
            Cocos2dxHelper.sPackageName = applicationInfo.packageName;
            if (CocosPlayClient.isEnabled() && !CocosPlayClient.isDemo()) {
                Cocos2dxHelper.sFileDirectory = CocosPlayClient.getGameRoot();
            }
            else {
                Cocos2dxHelper.sFileDirectory = activity.getFilesDir().getAbsolutePath();
            }
            
            Cocos2dxHelper.nativeSetApkPath(applicationInfo.sourceDir);
    
            Cocos2dxHelper.sCocos2dxAccelerometer = new Cocos2dxAccelerometer(activity);
            Cocos2dxHelper.sCocos2dMusic = new Cocos2dxMusic(activity);
            Cocos2dxHelper.sCocos2dSound = new Cocos2dxSound(activity);
            Cocos2dxHelper.sAssetManager = activity.getAssets();
            Cocos2dxHelper.nativeSetContext((Context)activity, Cocos2dxHelper.sAssetManager);
    
            Cocos2dxBitmap.setContext(activity);

            Cocos2dxHelper.sVibrateService = (Vibrator)activity.getSystemService(Context.VIBRATOR_SERVICE);

            sInited = true;
            
            //Enhance API modification begin
            Intent serviceIntent = new Intent(IGameTuningService.class.getName());
            serviceIntent.setPackage("com.enhance.gameservice");
            boolean suc = activity.getApplicationContext().bindService(serviceIntent, connection, Context.BIND_AUTO_CREATE);
            //Enhance API modification end
        }
    }
    
    //Enhance API modification begin
    private static ServiceConnection connection = new ServiceConnection() {
        public void onServiceConnected(ComponentName name, IBinder service) {
            mGameServiceBinder = IGameTuningService.Stub.asInterface(service);
            fastLoading(BOOST_TIME);
        }

        public void onServiceDisconnected(ComponentName name) {
            sActivity.getApplicationContext().unbindService(connection);
        }
    };
    //Enhance API modification end
    
    public static Activity getActivity() {
        return sActivity;
    }
    
    public static void addOnActivityResultListener(OnActivityResultListener listener) {
        onActivityResultListeners.add(listener);
    }
    
    public static Set<OnActivityResultListener> getOnActivityResultListeners() {
        return onActivityResultListeners;
    }
    
    public static boolean isActivityVisible(){
        return sActivityVisible;
    }

    // ===========================================================
    // Getter & Setter
    // ===========================================================

    // ===========================================================
    // Methods for/from SuperClass/Interfaces
    // ===========================================================

    // ===========================================================
    // Methods
    // ===========================================================

    private static native void nativeSetApkPath(final String pApkPath);

    private static native void nativeSetEditTextDialogResult(final byte[] pBytes);

    private static native void nativeSetContext(final Context pContext, final AssetManager pAssetManager);

    public static String getCocos2dxPackageName() {
        return Cocos2dxHelper.sPackageName;
    }
    public static String getCocos2dxWritablePath() {
        return Cocos2dxHelper.sFileDirectory;
    }

    public static String getCurrentLanguage() {
        return Locale.getDefault().getLanguage();
    }
    
    public static String getDeviceModel(){
        return Build.MODEL;
    }

    public static AssetManager getAssetManager() {
        return Cocos2dxHelper.sAssetManager;
    }

    public static void enableAccelerometer() {
        Cocos2dxHelper.sAccelerometerEnabled = true;
        Cocos2dxHelper.sCocos2dxAccelerometer.enable();
    }


    public static void setAccelerometerInterval(float interval) {
        Cocos2dxHelper.sCocos2dxAccelerometer.setInterval(interval);
    }

    public static void disableAccelerometer() {
        Cocos2dxHelper.sAccelerometerEnabled = false;
        Cocos2dxHelper.sCocos2dxAccelerometer.disable();
    }

    public static void setKeepScreenOn(boolean value) {
        ((Cocos2dxActivity)sActivity).setKeepScreenOn(value);
    }

    public static void vibrate(float duration) {
        sVibrateService.vibrate((long)(duration * 1000));
    }

    public static boolean openURL(String url) { 
        boolean ret = false;
        try {
            Intent i = new Intent(Intent.ACTION_VIEW);
            i.setData(Uri.parse(url));
            sActivity.startActivity(i);
            ret = true;
        } catch (Exception e) {
        }
        return ret;
    }

    public static void preloadBackgroundMusic(final String pPath) {
        Cocos2dxHelper.sCocos2dMusic.preloadBackgroundMusic(pPath);
    }

    public static void playBackgroundMusic(final String pPath, final boolean isLoop) {
        Cocos2dxHelper.sCocos2dMusic.playBackgroundMusic(pPath, isLoop);
    }

    public static void resumeBackgroundMusic() {
        Cocos2dxHelper.sCocos2dMusic.resumeBackgroundMusic();
    }

    public static void pauseBackgroundMusic() {
        Cocos2dxHelper.sCocos2dMusic.pauseBackgroundMusic();
    }

    public static void stopBackgroundMusic() {
        Cocos2dxHelper.sCocos2dMusic.stopBackgroundMusic();
    }

    public static void rewindBackgroundMusic() {
        Cocos2dxHelper.sCocos2dMusic.rewindBackgroundMusic();
    }

    public static boolean isBackgroundMusicPlaying() {
        return Cocos2dxHelper.sCocos2dMusic.isBackgroundMusicPlaying();
    }

    public static float getBackgroundMusicVolume() {
        return Cocos2dxHelper.sCocos2dMusic.getBackgroundVolume();
    }

    public static void setBackgroundMusicVolume(final float volume) {
        Cocos2dxHelper.sCocos2dMusic.setBackgroundVolume(volume);
    }

    public static void preloadEffect(final String path) {
        Cocos2dxHelper.sCocos2dSound.preloadEffect(path);
    }

    public static int playEffect(final String path, final boolean isLoop, final float pitch, final float pan, final float gain) {
        return Cocos2dxHelper.sCocos2dSound.playEffect(path, isLoop, pitch, pan, gain);
    }

    public static void resumeEffect(final int soundId) {
        Cocos2dxHelper.sCocos2dSound.resumeEffect(soundId);
    }

    public static void pauseEffect(final int soundId) {
        Cocos2dxHelper.sCocos2dSound.pauseEffect(soundId);
    }

    public static void stopEffect(final int soundId) {
        Cocos2dxHelper.sCocos2dSound.stopEffect(soundId);
    }

    public static float getEffectsVolume() {
        return Cocos2dxHelper.sCocos2dSound.getEffectsVolume();
    }

    public static void setEffectsVolume(final float volume) {
        Cocos2dxHelper.sCocos2dSound.setEffectsVolume(volume);
    }

    public static void unloadEffect(final String path) {
        Cocos2dxHelper.sCocos2dSound.unloadEffect(path);
    }

    public static void pauseAllEffects() {
        Cocos2dxHelper.sCocos2dSound.pauseAllEffects();
    }

    public static void resumeAllEffects() {
        Cocos2dxHelper.sCocos2dSound.resumeAllEffects();
    }

    public static void stopAllEffects() {
        Cocos2dxHelper.sCocos2dSound.stopAllEffects();
    }

    public static void end() {
        Cocos2dxHelper.sCocos2dMusic.end();
        Cocos2dxHelper.sCocos2dSound.end();
    }

    public static void onResume() {
        sActivityVisible = true;
        if (Cocos2dxHelper.sAccelerometerEnabled) {
            Cocos2dxHelper.sCocos2dxAccelerometer.enable();
        }
    }

    public static void onPause() {
        sActivityVisible = false;
        if (Cocos2dxHelper.sAccelerometerEnabled) {
            Cocos2dxHelper.sCocos2dxAccelerometer.disable();
        }
    }

    public static void onEnterBackground() {
        sCocos2dSound.onEnterBackground();
        sCocos2dMusic.onEnterBackground();
    }
    
    public static void onEnterForeground() {
        sCocos2dSound.onEnterForeground();
        sCocos2dMusic.onEnterForeground();
    }
    
    public static void terminateProcess() {
        android.os.Process.killProcess(android.os.Process.myPid());
    }

    private static void showDialog(final String pTitle, final String pMessage) {
        Cocos2dxHelper.sCocos2dxHelperListener.showDialog(pTitle, pMessage);
    }


    public static void setEditTextDialogResult(final String pResult) {
        try {
            final byte[] bytesUTF8 = pResult.getBytes("UTF8");

            Cocos2dxHelper.sCocos2dxHelperListener.runOnGLThread(new Runnable() {
                @Override
                public void run() {
                    Cocos2dxHelper.nativeSetEditTextDialogResult(bytesUTF8);
                }
            });
        } catch (UnsupportedEncodingException pUnsupportedEncodingException) {
            /* Nothing. */
        }
    }

    public static int getDPI()
    {
        if (sActivity != null)
        {
            DisplayMetrics metrics = new DisplayMetrics();
            WindowManager wm = sActivity.getWindowManager();
            if (wm != null)
            {
                Display d = wm.getDefaultDisplay();
                if (d != null)
                {
                    d.getMetrics(metrics);
                    return (int)(metrics.density*160.0f);
                }
            }
        }
        return -1;
    }
    
    // ===========================================================
    // Functions for CCUserDefault
    // ===========================================================
    
    public static boolean getBoolForKey(String key, boolean defaultValue) {
        SharedPreferences settings = sActivity.getSharedPreferences(Cocos2dxHelper.PREFS_NAME, 0);
        try {
            return settings.getBoolean(key, defaultValue);
        }
        catch (Exception ex) {
            ex.printStackTrace();

            Map allValues = settings.getAll();
            Object value = allValues.get(key);
            if ( value instanceof String)
            {
                return  Boolean.parseBoolean(value.toString());
            }
            else if (value instanceof Integer)
            {
                int intValue = ((Integer) value).intValue();
                return (intValue !=  0) ;
            }
            else if (value instanceof Float)
            {
                float floatValue = ((Float) value).floatValue();
                return (floatValue != 0.0f);
            }
        }

        return false;
    }
    
    public static int getIntegerForKey(String key, int defaultValue) {
        SharedPreferences settings = sActivity.getSharedPreferences(Cocos2dxHelper.PREFS_NAME, 0);
        try {
            return settings.getInt(key, defaultValue);
        }
        catch (Exception ex) {
            ex.printStackTrace();

            Map allValues = settings.getAll();
            Object value = allValues.get(key);
            if ( value instanceof String) {
                return  Integer.parseInt(value.toString());
            }
            else if (value instanceof Float)
            {
                return ((Float) value).intValue();
            }
            else if (value instanceof Boolean)
            {
                boolean booleanValue = ((Boolean) value).booleanValue();
                if (booleanValue)
                    return 1;
            }
        }

        return 0;
    }
    
    public static float getFloatForKey(String key, float defaultValue) {
        SharedPreferences settings = sActivity.getSharedPreferences(Cocos2dxHelper.PREFS_NAME, 0);
        try {
            return settings.getFloat(key, defaultValue);
        }
        catch (Exception ex) {
            ex.printStackTrace();;

            Map allValues = settings.getAll();
            Object value = allValues.get(key);
            if ( value instanceof String) {
                return  Float.parseFloat(value.toString());
            }
            else if (value instanceof Integer)
            {
                return ((Integer) value).floatValue();
            }
            else if (value instanceof Boolean)
            {
                boolean booleanValue = ((Boolean) value).booleanValue();
                if (booleanValue)
                    return 1.0f;
            }
        }

        return 0.0f;
    }
    
    public static double getDoubleForKey(String key, double defaultValue) {
        // SharedPreferences doesn't support saving double value
        return getFloatForKey(key, (float) defaultValue);
    }
    
    public static String getStringForKey(String key, String defaultValue) {
        SharedPreferences settings = sActivity.getSharedPreferences(Cocos2dxHelper.PREFS_NAME, 0);
        try {
            return settings.getString(key, defaultValue);
        }
        catch (Exception ex) {
            ex.printStackTrace();
            
            return settings.getAll().get(key).toString();
        }
    }
    
    public static void setBoolForKey(String key, boolean value) {
        SharedPreferences settings = sActivity.getSharedPreferences(Cocos2dxHelper.PREFS_NAME, 0);
        SharedPreferences.Editor editor = settings.edit();
        editor.putBoolean(key, value);
        editor.commit();
    }
    
    public static void setIntegerForKey(String key, int value) {
        SharedPreferences settings = sActivity.getSharedPreferences(Cocos2dxHelper.PREFS_NAME, 0);
        SharedPreferences.Editor editor = settings.edit();
        editor.putInt(key, value);
        editor.commit();
    }
    
    public static void setFloatForKey(String key, float value) {
        SharedPreferences settings = sActivity.getSharedPreferences(Cocos2dxHelper.PREFS_NAME, 0);
        SharedPreferences.Editor editor = settings.edit();
        editor.putFloat(key, value);
        editor.commit();
    }
    
    public static void setDoubleForKey(String key, double value) {
        // SharedPreferences doesn't support recording double value
        SharedPreferences settings = sActivity.getSharedPreferences(Cocos2dxHelper.PREFS_NAME, 0);
        SharedPreferences.Editor editor = settings.edit();
        editor.putFloat(key, (float)value);
        editor.commit();
    }
    
    public static void setStringForKey(String key, String value) {
        SharedPreferences settings = sActivity.getSharedPreferences(Cocos2dxHelper.PREFS_NAME, 0);
        SharedPreferences.Editor editor = settings.edit();
        editor.putString(key, value);
        editor.commit();
    }
    
    public static void deleteValueForKey(String key) {
        SharedPreferences settings = sActivity.getSharedPreferences(Cocos2dxHelper.PREFS_NAME, 0);
        SharedPreferences.Editor editor = settings.edit();
        editor.remove(key);
        editor.commit();
    }

    public static byte[] conversionEncoding(byte[] text, String fromCharset,String newCharset)
    {
        try {
            String str = new String(text,fromCharset);
            return str.getBytes(newCharset);
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }

        return null;
    }
    
    // ===========================================================
    // Inner and Anonymous Classes
    // ===========================================================

    public static interface Cocos2dxHelperListener {
        public void showDialog(final String pTitle, final String pMessage);

        public void runOnGLThread(final Runnable pRunnable);
    }

    //Enhance API modification begin
    public static int setResolutionPercent(int per) {
        try {
            if (mGameServiceBinder != null) {
                return mGameServiceBinder.setPreferredResolution(per);
            }
            return -1;
        } catch (Exception e) {
            e.printStackTrace();
            return -1;
        }
    }

    public static int setFPS(int fps) {
        try {
            if (mGameServiceBinder != null) {
                return mGameServiceBinder.setFramePerSecond(fps);
            }
            return -1;
        } catch (Exception e) {
            e.printStackTrace();
            return -1;
        }
    }

    public static int fastLoading(int sec) {
        try {
            if (mGameServiceBinder != null) {
                return mGameServiceBinder.boostUp(sec);
            }
            return -1;
        } catch (Exception e) {
            e.printStackTrace();
            return -1;
        }
    }

    public static int getTemperature() {
        try {
            if (mGameServiceBinder != null) {
                return mGameServiceBinder.getAbstractTemperature();
            }
            return -1;
        } catch (Exception e) {
            e.printStackTrace();
            return -1;
        }
    }

    public static int setLowPowerMode(boolean enable) {
        try {
            if (mGameServiceBinder != null) {
                return mGameServiceBinder.setGamePowerSaving(enable);
            }
            return -1;
        } catch (Exception e) {
            e.printStackTrace();
            return -1;
        }
    }
    //Enhance API modification end     
}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/Cocos2dxHttpURLConnection.java #-}
/****************************************************************************
Copyright (c) 2010-2014 cocos2d-x.org

http://www.cocos2d-x.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 ****************************************************************************/
package org.cocos2dx.lib;

import android.util.Log;

import java.io.BufferedInputStream;
import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.ProtocolException;
import java.net.URL;
import java.security.KeyStore;
import java.security.cert.Certificate;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Map.Entry;
import java.util.zip.GZIPInputStream;
import java.util.zip.InflaterInputStream;

import javax.net.ssl.HttpsURLConnection;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManagerFactory;

public class Cocos2dxHttpURLConnection
{
    private static final String POST_METHOD = "POST" ;
    private static final String PUT_METHOD = "PUT" ;

    static HttpURLConnection createHttpURLConnection(String linkURL) {
        URL url;
        HttpURLConnection urlConnection;
        try {
            url = new URL(linkURL);
            urlConnection = (HttpURLConnection) url.openConnection();
            //Accept-Encoding
            urlConnection.setRequestProperty("Accept-Encoding", "identity");
            urlConnection.setDoInput(true);
        } catch (Exception e) {
            Log.e("URLConnection exception", e.toString());
            return null;
        }

        return urlConnection;
    }

    static void setReadAndConnectTimeout(HttpURLConnection urlConnection, int readMiliseconds, int connectMiliseconds) {
        urlConnection.setReadTimeout(readMiliseconds);
        urlConnection.setConnectTimeout(connectMiliseconds);
    }

    static void setRequestMethod(HttpURLConnection urlConnection, String method){
        try {
            urlConnection.setRequestMethod(method);
            if(method.equalsIgnoreCase(POST_METHOD) || method.equalsIgnoreCase(PUT_METHOD)) {
                urlConnection.setDoOutput(true);
            }
        } catch (ProtocolException e) {
            Log.e("URLConnection exception", e.toString());
        }

    }

    static void setVerifySSL(HttpURLConnection urlConnection, String sslFilename) {
        if(!(urlConnection instanceof HttpsURLConnection))
            return;
        

        HttpsURLConnection httpsURLConnection = (HttpsURLConnection)urlConnection;

        try {
            InputStream caInput = null;
            if (sslFilename.startsWith("/")) {
                caInput = new BufferedInputStream(new FileInputStream(sslFilename));
            }else {
                String assetString = "assets/";
                String assetsfilenameString = sslFilename.substring(assetString.length());
                caInput = new BufferedInputStream(Cocos2dxHelper.getActivity().getAssets().open(assetsfilenameString));
            }

            CertificateFactory cf = CertificateFactory.getInstance("X.509");
            Certificate ca;
            ca = cf.generateCertificate(caInput);
            System.out.println("ca=" + ((X509Certificate) ca).getSubjectDN());
            caInput.close();

            // Create a KeyStore containing our trusted CAs
            String keyStoreType = KeyStore.getDefaultType();
            KeyStore keyStore = KeyStore.getInstance(keyStoreType);
            keyStore.load(null, null);
            keyStore.setCertificateEntry("ca", ca);

            // Create a TrustManager that trusts the CAs in our KeyStore
            String tmfAlgorithm = TrustManagerFactory.getDefaultAlgorithm();
            TrustManagerFactory tmf = TrustManagerFactory.getInstance(tmfAlgorithm);
            tmf.init(keyStore);

            // Create an SSLContext that uses our TrustManager
            SSLContext context = SSLContext.getInstance("TLS");
            context.init(null, tmf.getTrustManagers(), null);

            httpsURLConnection.setSSLSocketFactory(context.getSocketFactory());
        } catch (Exception e) {
            Log.e("URLConnection exception", e.toString());
        }
    }

    //Add header
    static void addRequestHeader(HttpURLConnection urlConnection, String key, String value) {
        urlConnection.setRequestProperty(key, value);
    }

    static int connect(HttpURLConnection http) {
        int suc = 0;

        try {
            http.connect();
        } catch (IOException e) {
            Log.e("cocos2d-x debug info", "come in connect");
            Log.e("cocos2d-x debug info", e.toString());
            suc = 1;
        }

        return suc;
    }

    static void disconnect(HttpURLConnection http) {
        http.disconnect();
    }

    static void sendRequest(HttpURLConnection http, byte[] byteArray) {
        try {
            OutputStream out = http.getOutputStream();
            if(null !=  byteArray) {
                out.write(byteArray);
                out.flush();
            }
            out.close();
        } catch (IOException e) {
            Log.e("URLConnection exception", e.toString());
        }
    }

    static String getResponseHeaders(HttpURLConnection http) {
        Map<String, List<String>> headers = http.getHeaderFields();
        if (null == headers) {
            return null;
        }

        String header = "";

        for (Entry<String, List<String>> entry: headers.entrySet()) {
            String key = entry.getKey();
            if (null == key) {
                header += listToString(entry.getValue(), ",") + "\n";
            } else {
                header += key + ":" + listToString(entry.getValue(), ",") + "\n";
            }
        }

        return header;
    }

    static String getResponseHeaderByIdx(HttpURLConnection http, int idx) {
        Map<String, List<String>> headers = http.getHeaderFields();
        if (null == headers) {
            return null;
        }

        String header = null;

        int counter = 0;
        for (Entry<String, List<String>> entry: headers.entrySet()) {
            if (counter == idx) {
                String key = entry.getKey();
                if (null == key) {
                    header = listToString(entry.getValue(), ",") + "\n";
                } else {
                    header = key + ":" + listToString(entry.getValue(), ",") + "\n";
                }
                break;
            }
            counter++;
        }

        return header;
    }

    static String getResponseHeaderByKey(HttpURLConnection http, String key) {
        if (null == key) {
            return null;
        }

        Map<String, List<String>> headers = http.getHeaderFields();
        if (null == headers) {
            return null;
        }

        String header = null;

        for (Entry<String, List<String>> entry: headers.entrySet()) {
            if (key.equalsIgnoreCase(entry.getKey())) {
                if ("set-cookie".equalsIgnoreCase(key)) {
                    header = combinCookies(entry.getValue(), http.getURL().getHost());
                } else {
                    header = listToString(entry.getValue(), ",");
                }
                break;
            }
        }

        return header;
    }

    static int getResponseHeaderByKeyInt(HttpURLConnection http, String key) {
        String value = http.getHeaderField(key);

        if (null == value) {
            return 0;
        } else {
            return Integer.parseInt(value);
        }
    }

    static byte[] getResponseContent(HttpURLConnection http) {
        InputStream in;
        try {            
            in = http.getInputStream();
            String contentEncoding = http.getContentEncoding();
            if (contentEncoding != null) {
                if(contentEncoding.equalsIgnoreCase("gzip")){
                    in = new GZIPInputStream(http.getInputStream()); //reads 2 bytes to determine GZIP stream!
                }
                else if(contentEncoding.equalsIgnoreCase("deflate")){
                    in = new InflaterInputStream(http.getInputStream());
                }
            }       
        } catch (IOException e) {
            in = http.getErrorStream();
        } catch (Exception e) {
            Log.e("URLConnection exception", e.toString());
            return null;
        }

        try {
            byte[] buffer = new byte[1024];
            int size   = 0;
            ByteArrayOutputStream bytestream = new ByteArrayOutputStream();
            while((size = in.read(buffer, 0 , 1024)) != -1)
            {
                bytestream.write(buffer, 0, size);
            }
            byte retbuffer[] = bytestream.toByteArray();
            bytestream.close();
            return retbuffer;
        } catch (Exception e) {
            Log.e("URLConnection exception", e.toString());
        }

        return null;
    }
    
    static int getResponseCode(HttpURLConnection http) {
        int code = 0;
        try {
            code = http.getResponseCode();
        } catch (IOException e) {
            Log.e("URLConnection exception", e.toString());
        }
        return code;
    }

    static String getResponseMessage(HttpURLConnection http) {
        String msg;
        try {
            msg = http.getResponseMessage();
        } catch (IOException e) {
            msg = e.toString();
            Log.e("URLConnection exception", msg);
        }

        return msg;
    }

    public static String listToString(List<String> list, String strInterVal) {
        if (list == null) {
            return null;
        }
        StringBuilder result = new StringBuilder();
        boolean flag = false;
        for (String str : list) {
            if (flag) {
                result.append(strInterVal);
            }
            if (null == str) {
                str = "";
            }
            result.append(str);
            flag = true;
        }
        return result.toString();
    }

    public static String combinCookies(List<String> list, String hostDomain) {
        StringBuilder sbCookies = new StringBuilder();
        String domain    = hostDomain;
        String tailmatch = "FALSE";
        String path      = "/";
        String secure    = "FALSE";
        String key = null;
        String value = null;
        String expires = null;
        for (String str : list) {
            String[] parts = str.split(";");
            for (String part : parts) {
                int firstIndex = part.indexOf("=");
                if (-1 == firstIndex)
                    continue;

                String[] item =  {part.substring(0, firstIndex), part.substring(firstIndex + 1)};
                if ("expires".equalsIgnoreCase(item[0].trim())) {
                    expires = str2Seconds(item[1].trim());
                } else if("path".equalsIgnoreCase(item[0].trim())) {
                    path = item[1];
                } else if("secure".equalsIgnoreCase(item[0].trim())) {
                    secure = item[1];
                } else if("domain".equalsIgnoreCase(item[0].trim())) {
                    domain = item[1];
                } else if("version".equalsIgnoreCase(item[0].trim()) || "max-age".equalsIgnoreCase(item[0].trim())) {
                    //do nothing
                } else {
                    key = item[0];
                    value = item[1];
                }
            }

            if (null == domain) {
                domain = "none";
            }

            sbCookies.append(domain);
            sbCookies.append('\t');
            sbCookies.append(tailmatch);  //access
            sbCookies.append('\t');
            sbCookies.append(path);      //path
            sbCookies.append('\t');
            sbCookies.append(secure);    //secure
            sbCookies.append('\t');
            sbCookies.append(expires);   //expires
            sbCookies.append("\t");
            sbCookies.append(key);       //key
            sbCookies.append("\t");
            sbCookies.append(value);     //value
            sbCookies.append('\n');
        }

        return sbCookies.toString();
    }

    private static String str2Seconds(String strTime) {
        Calendar c = Calendar.getInstance();
        long millisSecond = 0;

        try {
            c.setTime(new SimpleDateFormat("EEE, dd-MMM-yy hh:mm:ss zzz", Locale.US).parse(strTime));
            millisSecond = c.getTimeInMillis()/1000;
        } catch (ParseException e) {
            Log.e("URLConnection exception", e.toString());
        }

        return Long.toString(millisSecond);
    }
}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/Cocos2dxJavascriptJavaBridge.java #-}
/*
 * Copyright (c) 2013-2014 Chukong Technologies Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

package org.cocos2dx.lib;

public class Cocos2dxJavascriptJavaBridge {
    public static native int evalString(String value);
}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/Cocos2dxLocalStorage.java #-}
/****************************************************************************
Copyright (c) 2013-2014 Chukong Technologies Inc.

http://www.cocos2d-x.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
****************************************************************************/
package org.cocos2dx.lib;

import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.util.Log;


public class Cocos2dxLocalStorage {

    private static final String TAG = "Cocos2dxLocalStorage";

    private static String DATABASE_NAME = "jsb.sqlite";
    private static String TABLE_NAME = "data";
    private static final int DATABASE_VERSION = 1;
    
    private static DBOpenHelper mDatabaseOpenHelper = null;
    private static SQLiteDatabase mDatabase = null;
    /**
     * Constructor
     * @param context The Context within which to work, used to create the DB
     * @return 
     */
    public static boolean init(String dbName, String tableName) {
        if (Cocos2dxActivity.getContext() != null) {
            DATABASE_NAME = dbName;
            TABLE_NAME = tableName;
            mDatabaseOpenHelper = new DBOpenHelper(Cocos2dxActivity.getContext());
            mDatabase = mDatabaseOpenHelper.getWritableDatabase();
            return true;
        }
        return false;
    }
    
    public static void destory() {
        if (mDatabase != null) {
            mDatabase.close();
        }
    }
    
    public static void setItem(String key, String value) {
        try {
            String sql = "replace into "+TABLE_NAME+"(key,value)values(?,?)";
            mDatabase.execSQL(sql, new Object[] { key, value });
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    public static String getItem(String key) {
        String ret = null;
        try {
        String sql = "select value from "+TABLE_NAME+" where key=?";
        Cursor c = mDatabase.rawQuery(sql, new String[]{key});  
        while (c.moveToNext()) {
            // only return the first value
            if (ret != null) 
            {
                Log.e(TAG, "The key contains more than one value.");
                break;
            }
            ret = c.getString(c.getColumnIndex("value"));  
        }  
        c.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return ret == null ? "" : ret;
    }
    
    public static void removeItem(String key) {
        try {
            String sql = "delete from "+TABLE_NAME+" where key=?";
            mDatabase.execSQL(sql, new Object[] {key});
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    public static void clear() {
        try {
            String sql = "delete from "+TABLE_NAME;
            mDatabase.execSQL(sql);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    

    /**
     * This creates/opens the database.
     */
    private static class DBOpenHelper extends SQLiteOpenHelper {

        DBOpenHelper(Context context) {
            super(context, DATABASE_NAME, null, DATABASE_VERSION);
        }

        @Override
        public void onCreate(SQLiteDatabase db) {
            db.execSQL("CREATE TABLE IF NOT EXISTS "+TABLE_NAME+"(key TEXT PRIMARY KEY,value TEXT);");
        }
        
        @Override
        public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
            Log.w(TAG, "Upgrading database from version " + oldVersion + " to "
                    + newVersion + ", which will destroy all old data");
            //db.execSQL("DROP TABLE IF EXISTS " + VIRTUAL_TABLE);
            //onCreate(db);
        }
    }
}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/Cocos2dxLuaJavaBridge.java #-}
/****************************************************************************
Copyright (c) 2013-2014 Chukong Technologies Inc.

http://www.cocos2d-x.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
****************************************************************************/

package org.cocos2dx.lib;

public class Cocos2dxLuaJavaBridge
{
    public static native int callLuaFunctionWithString(int luaFunctionId, String value);
    public static native int callLuaGlobalFunctionWithString(String luaFunctionName, String value);
    public static native int retainLuaFunction(int luaFunctionId);
    public static native int releaseLuaFunction(int luaFunctionId);
}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/Cocos2dxMusic.java #-}
/****************************************************************************
Copyright (c) 2010-2012 cocos2d-x.org
Copyright (c) 2013-2014 Chukong Technologies Inc.

http://www.cocos2d-x.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 ****************************************************************************/

package org.cocos2dx.lib;

import android.content.Context;
import android.content.res.AssetFileDescriptor;
import android.media.MediaPlayer;
import android.util.Log;

import com.chukong.cocosplay.client.CocosPlayClient;

import java.io.FileInputStream;

public class Cocos2dxMusic {
    // ===========================================================
    // Constants
    // ===========================================================

    private static final String TAG = Cocos2dxMusic.class.getSimpleName();

    // ===========================================================
    // Fields
    // ===========================================================

    private final Context mContext;
    private MediaPlayer mBackgroundMediaPlayer;
    private float mLeftVolume;
    private float mRightVolume;
    private boolean mPaused; // whether music is paused state.
    private boolean mIsLoop = false;
    private boolean mManualPaused = false; // whether music is paused manually before the program is switched to the background.
    private String mCurrentPath;

    // ===========================================================
    // Constructors
    // ===========================================================

    public Cocos2dxMusic(final Context context) {
        this.mContext = context;

        this.initData();
    }

    // ===========================================================
    // Getter & Setter
    // ===========================================================

    // ===========================================================
    // Methods for/from SuperClass/Interfaces
    // ===========================================================

    // ===========================================================
    // Methods
    // ===========================================================

    public void preloadBackgroundMusic(final String path) {
        if ((this.mCurrentPath == null) || (!this.mCurrentPath.equals(path))) {
            // preload new background music

            // release old resource and create a new one
            if (this.mBackgroundMediaPlayer != null) {
                this.mBackgroundMediaPlayer.release();
            }

            this.mBackgroundMediaPlayer = this.createMediaplayer(path);

            // record the path
            this.mCurrentPath = path;
        }
    }

    public void playBackgroundMusic(final String path, final boolean isLoop) {
        if (mCurrentPath == null) {
            // it is the first time to play background music or end() was called
            mBackgroundMediaPlayer = createMediaplayer(path);
            mCurrentPath = path;
        } else {
            if (!mCurrentPath.equals(path)) {
                // play new background music

                // release old resource and create a new one
                if (mBackgroundMediaPlayer != null) {
                    mBackgroundMediaPlayer.release();
                }
                mBackgroundMediaPlayer = createMediaplayer(path);

                // record the path
                mCurrentPath = path;
            }
        }

        if (mBackgroundMediaPlayer == null) {
            Log.e(Cocos2dxMusic.TAG, "playBackgroundMusic: background media player is null");
        } else {
            try {
                // if the music is playing or paused, stop it
                if (mPaused) {
                    mBackgroundMediaPlayer.seekTo(0);
                    mBackgroundMediaPlayer.start();
                } else if (mBackgroundMediaPlayer.isPlaying()) {
                    mBackgroundMediaPlayer.seekTo(0);
                } else {
                    mBackgroundMediaPlayer.start();
                }
                mBackgroundMediaPlayer.setLooping(isLoop);
                mPaused = false;
                mIsLoop = isLoop;
            } catch (final Exception e) {
                Log.e(Cocos2dxMusic.TAG, "playBackgroundMusic: error state");
            }
        }
    }

    public void stopBackgroundMusic() {
        if (this.mBackgroundMediaPlayer != null) {
        	mBackgroundMediaPlayer.release();
        	mBackgroundMediaPlayer = createMediaplayer(mCurrentPath);
        	
            /**
             * should set the state, if not, the following sequence will be error
             * play -> pause -> stop -> resume
             */
            this.mPaused = false;
        }
    }

    public void pauseBackgroundMusic() {
        if (this.mBackgroundMediaPlayer != null && this.mBackgroundMediaPlayer.isPlaying()) {
            this.mBackgroundMediaPlayer.pause();
            this.mPaused = true;
            this.mManualPaused = true;
        }
    }

    public void resumeBackgroundMusic() {
        if (this.mBackgroundMediaPlayer != null && this.mPaused) {
            this.mBackgroundMediaPlayer.start();
            this.mPaused = false;
            this.mManualPaused = false;
        }
    }

    public void rewindBackgroundMusic() {
        if (this.mBackgroundMediaPlayer != null) {
        	playBackgroundMusic(mCurrentPath, mIsLoop);
        }
    }

    public boolean isBackgroundMusicPlaying() {
        boolean ret = false;

        if (this.mBackgroundMediaPlayer == null) {
            ret = false;
        } else {
            ret = this.mBackgroundMediaPlayer.isPlaying();
        }

        return ret;
    }

    public void end() {
        if (this.mBackgroundMediaPlayer != null) {
            this.mBackgroundMediaPlayer.release();
        }

        this.initData();
    }

    public float getBackgroundVolume() {
        if (this.mBackgroundMediaPlayer != null) {
            return (this.mLeftVolume + this.mRightVolume) / 2;
        } else {
            return 0.0f;
        }
    }

    public void setBackgroundVolume(float volume) {
        if (volume < 0.0f) {
            volume = 0.0f;
        }

        if (volume > 1.0f) {
            volume = 1.0f;
        }

        this.mLeftVolume = this.mRightVolume = volume;
        if (this.mBackgroundMediaPlayer != null) {
            this.mBackgroundMediaPlayer.setVolume(this.mLeftVolume, this.mRightVolume);
        }
    }

    public void onEnterBackground(){
        if (this.mBackgroundMediaPlayer != null && this.mBackgroundMediaPlayer.isPlaying()) {
            this.mBackgroundMediaPlayer.pause();
            this.mPaused = true;
        }
    }
    
    public void onEnterForeground(){
        if(!this.mManualPaused){
            if (this.mBackgroundMediaPlayer != null && this.mPaused) {
                this.mBackgroundMediaPlayer.start();
                this.mPaused = false;
            }
        }
    }
    
    private void initData() {
        this.mLeftVolume = 0.5f;
        this.mRightVolume = 0.5f;
        this.mBackgroundMediaPlayer = null;
        this.mPaused = false;
        this.mCurrentPath = null;
    }

    /**
     * create mediaplayer for music
     * 
     * @param pPath
     *            the pPath relative to assets
     * @return
     */
    private MediaPlayer createMediaplayer(final String path) {
        MediaPlayer mediaPlayer = new MediaPlayer();

        try {
            if (CocosPlayClient.isEnabled() && !CocosPlayClient.isDemo()) {
                CocosPlayClient.updateAssets(path);
            }
            CocosPlayClient.notifyFileLoaded(path);
            if (path.startsWith("/")) {
                final FileInputStream fis = new FileInputStream(path);
                mediaPlayer.setDataSource(fis.getFD());
                fis.close();
            } else {
                final AssetFileDescriptor assetFileDescritor = this.mContext.getAssets().openFd(path);
                mediaPlayer.setDataSource(assetFileDescritor.getFileDescriptor(), assetFileDescritor.getStartOffset(), assetFileDescritor.getLength());
            }

            mediaPlayer.prepare();

            mediaPlayer.setVolume(this.mLeftVolume, this.mRightVolume);
        } catch (final Exception e) {
            mediaPlayer = null;
            Log.e(Cocos2dxMusic.TAG, "error: " + e.getMessage(), e);
        }

        return mediaPlayer;
    }

    // ===========================================================
    // Inner and Anonymous Classes
    // ===========================================================
}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/Cocos2dxRenderer.java #-}
/****************************************************************************
Copyright (c) 2010-2011 cocos2d-x.org

http://www.cocos2d-x.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 ****************************************************************************/
package org.cocos2dx.lib;

import android.opengl.GLSurfaceView;

import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;
public class Cocos2dxRenderer implements GLSurfaceView.Renderer {
    // ===========================================================
    // Constants
    // ===========================================================

    private final static long NANOSECONDSPERSECOND = 1000000000L;
    private final static long NANOSECONDSPERMICROSECOND = 1000000;

    private static long sAnimationInterval = (long) (1.0 / 60 * Cocos2dxRenderer.NANOSECONDSPERSECOND);

    // ===========================================================
    // Fields
    // ===========================================================

    private long mLastTickInNanoSeconds;
    private int mScreenWidth;
    private int mScreenHeight;
    private boolean mNativeInitCompleted = false;

    // ===========================================================
    // Constructors
    // ===========================================================

    // ===========================================================
    // Getter & Setter
    // ===========================================================

    public static void setAnimationInterval(final float animationInterval) {
        Cocos2dxRenderer.sAnimationInterval = (long) (animationInterval * Cocos2dxRenderer.NANOSECONDSPERSECOND);
    }

    public void setScreenWidthAndHeight(final int surfaceWidth, final int surfaceHeight) {
        this.mScreenWidth = surfaceWidth;
        this.mScreenHeight = surfaceHeight;
    }

    // ===========================================================
    // Methods for/from SuperClass/Interfaces
    // ===========================================================

    @Override
    public void onSurfaceCreated(final GL10 GL10, final EGLConfig EGLConfig) {
        Cocos2dxRenderer.nativeInit(this.mScreenWidth, this.mScreenHeight);
        this.mLastTickInNanoSeconds = System.nanoTime();
        mNativeInitCompleted = true;
    }

    @Override
    public void onSurfaceChanged(final GL10 GL10, final int width, final int height) {
        Cocos2dxRenderer.nativeOnSurfaceChanged(width, height);
    }

    @Override
    public void onDrawFrame(final GL10 gl) {
        /*
         * No need to use algorithm in default(60 FPS) situation,
         * since onDrawFrame() was called by system 60 times per second by default.
         */
        if (sAnimationInterval <= 1.0 / 60 * Cocos2dxRenderer.NANOSECONDSPERSECOND) {
            Cocos2dxRenderer.nativeRender();
        } else {
            final long now = System.nanoTime();
            final long interval = now - this.mLastTickInNanoSeconds;
        
            if (interval < Cocos2dxRenderer.sAnimationInterval) {
                try {
                    Thread.sleep((Cocos2dxRenderer.sAnimationInterval - interval) / Cocos2dxRenderer.NANOSECONDSPERMICROSECOND);
                } catch (final Exception e) {
                }
            }
            /*
             * Render time MUST be counted in, or the FPS will slower than appointed.
            */
            this.mLastTickInNanoSeconds = System.nanoTime();
            Cocos2dxRenderer.nativeRender();
        }
    }

    // ===========================================================
    // Methods
    // ===========================================================

    private static native void nativeTouchesBegin(final int id, final float x, final float y);
    private static native void nativeTouchesEnd(final int id, final float x, final float y);
    private static native void nativeTouchesMove(final int[] ids, final float[] xs, final float[] ys);
    private static native void nativeTouchesCancel(final int[] ids, final float[] xs, final float[] ys);
    private static native boolean nativeKeyEvent(final int keyCode,boolean isPressed);
    private static native void nativeRender();
    private static native void nativeInit(final int width, final int height);
    private static native void nativeOnSurfaceChanged(final int width, final int height);
    private static native void nativeOnPause();
    private static native void nativeOnResume();

    public void handleActionDown(final int id, final float x, final float y) {
        Cocos2dxRenderer.nativeTouchesBegin(id, x, y);
    }

    public void handleActionUp(final int id, final float x, final float y) {
        Cocos2dxRenderer.nativeTouchesEnd(id, x, y);
    }

    public void handleActionCancel(final int[] ids, final float[] xs, final float[] ys) {
        Cocos2dxRenderer.nativeTouchesCancel(ids, xs, ys);
    }

    public void handleActionMove(final int[] ids, final float[] xs, final float[] ys) {
        Cocos2dxRenderer.nativeTouchesMove(ids, xs, ys);
    }

    public void handleKeyDown(final int keyCode) {
        Cocos2dxRenderer.nativeKeyEvent(keyCode, true);
    }

    public void handleKeyUp(final int keyCode) {
        Cocos2dxRenderer.nativeKeyEvent(keyCode, false);
    }

    public void handleOnPause() {
        /**
         * onPause may be invoked before onSurfaceCreated, 
         * and engine will be initialized correctly after
         * onSurfaceCreated is invoked. Can not invoke any
         * native method before onSurfaceCreated is invoked
         */
        if (! mNativeInitCompleted)
            return;

        Cocos2dxHelper.onEnterBackground();
        Cocos2dxRenderer.nativeOnPause();
    }

    public void handleOnResume() {
        Cocos2dxHelper.onEnterForeground();
        Cocos2dxRenderer.nativeOnResume();
    }

    private static native void nativeInsertText(final String text);
    private static native void nativeDeleteBackward();
    private static native String nativeGetContentText();

    public void handleInsertText(final String text) {
        Cocos2dxRenderer.nativeInsertText(text);
    }

    public void handleDeleteBackward() {
        Cocos2dxRenderer.nativeDeleteBackward();
    }

    public String getContentText() {
        return Cocos2dxRenderer.nativeGetContentText();
    }

    // ===========================================================
    // Inner and Anonymous Classes
    // ===========================================================
}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/Cocos2dxSound.java #-}
/****************************************************************************
Copyright (c) 2010-2012 cocos2d-x.org
Copyright (c) 2013-2014 Chukong Technologies Inc.

http://www.cocos2d-x.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 ****************************************************************************/
package org.cocos2dx.lib;

import android.content.Context;
import android.media.AudioManager;
import android.media.SoundPool;
import android.util.Log;

import com.chukong.cocosplay.client.CocosPlayClient;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.concurrent.ConcurrentHashMap;

public class Cocos2dxSound {
    // ===========================================================
    // Constants
    // ===========================================================

    private static final String TAG = "Cocos2dxSound";

    // ===========================================================
    // Fields
    // ===========================================================

    private final Context mContext;
    private SoundPool mSoundPool;
    private float mLeftVolume;
    private float mRightVolume;

    // sound path and stream ids map
    // a file may be played many times at the same time
    // so there is an array map to a file path
    private final HashMap<String, ArrayList<Integer>> mPathStreamIDsMap = new HashMap<String, ArrayList<Integer>>();

    private final HashMap<String, Integer> mPathSoundIDMap = new HashMap<String, Integer>();

    private ConcurrentHashMap<Integer, SoundInfoForLoadedCompleted>  mPlayWhenLoadedEffects =
            new ConcurrentHashMap<Integer, SoundInfoForLoadedCompleted>();

    private static final int MAX_SIMULTANEOUS_STREAMS_DEFAULT = 5;
    private static final int MAX_SIMULTANEOUS_STREAMS_I9100 = 3;
    private static final float SOUND_RATE = 1.0f;
    private static final int SOUND_PRIORITY = 1;
    private static final int SOUND_QUALITY = 5;

    private final static int INVALID_SOUND_ID = -1;
    private final static int INVALID_STREAM_ID = -1;

    // ===========================================================
    // Constructors
    // ===========================================================

    public Cocos2dxSound(final Context context) {
        this.mContext = context;

        this.initData();
    }

    private void initData() {
        if (Cocos2dxHelper.getDeviceModel().contains("GT-I9100")) {
            this.mSoundPool = new SoundPool(Cocos2dxSound.MAX_SIMULTANEOUS_STREAMS_I9100, AudioManager.STREAM_MUSIC, Cocos2dxSound.SOUND_QUALITY);
        }
        else {
            this.mSoundPool = new SoundPool(Cocos2dxSound.MAX_SIMULTANEOUS_STREAMS_DEFAULT, AudioManager.STREAM_MUSIC, Cocos2dxSound.SOUND_QUALITY);
        }
        
        this.mSoundPool.setOnLoadCompleteListener(new OnLoadCompletedListener());

        this.mLeftVolume = 0.5f;
        this.mRightVolume = 0.5f;
    }

    public int preloadEffect(final String path) {
        if (CocosPlayClient.isEnabled() && !CocosPlayClient.isDemo()) {
            CocosPlayClient.updateAssets(path);
        }
        CocosPlayClient.notifyFileLoaded(path);
        Integer soundID = this.mPathSoundIDMap.get(path);

        if (soundID == null) {
            soundID = this.createSoundIDFromAsset(path);
            // save value just in case if file is really loaded
            if (soundID != Cocos2dxSound.INVALID_SOUND_ID) {
                this.mPathSoundIDMap.put(path, soundID);
            }
        }

        return soundID;
    }

    public void unloadEffect(final String path) {
        // stop effects
        final ArrayList<Integer> streamIDs = this.mPathStreamIDsMap.get(path);
        if (streamIDs != null) {
            for (final Integer steamID : streamIDs) {
                this.mSoundPool.stop(steamID);
            }
        }
        this.mPathStreamIDsMap.remove(path);

        // unload effect
        final Integer soundID = this.mPathSoundIDMap.get(path);
        if(soundID != null){
            this.mSoundPool.unload(soundID);
            this.mPathSoundIDMap.remove(path);
        }
    }

    private static int LOAD_TIME_OUT = 500;

    public int playEffect(final String path, final boolean loop, float pitch, float pan, float gain){
        Integer soundID = this.mPathSoundIDMap.get(path);
        int streamID = Cocos2dxSound.INVALID_STREAM_ID;

        if (soundID != null) {
            // parameters; pan = -1 for left channel, 1 for right channel, 0 for both channels

            // play sound
            streamID = this.doPlayEffect(path, soundID, loop, pitch, pan, gain);
        } else {
            // the effect is not prepared
            soundID = this.preloadEffect(path);
            if (soundID == Cocos2dxSound.INVALID_SOUND_ID) {
                // can not preload effect
                return Cocos2dxSound.INVALID_SOUND_ID;
            }

            SoundInfoForLoadedCompleted info = new SoundInfoForLoadedCompleted(path, loop, pitch, pan, gain);
            mPlayWhenLoadedEffects.putIfAbsent(soundID, info);

            synchronized(info) {
                try {
                    info.wait(LOAD_TIME_OUT);
                }
                catch (Exception e) {
                    e.printStackTrace();
                }
            }
            streamID = info.effectID;
            mPlayWhenLoadedEffects.remove(soundID);
        }

        return streamID;
    }

    public void stopEffect(final int steamID) {
        this.mSoundPool.stop(steamID);

        // remove record
        for (final String pPath : this.mPathStreamIDsMap.keySet()) {
            if (this.mPathStreamIDsMap.get(pPath).contains(steamID)) {
                this.mPathStreamIDsMap.get(pPath).remove(this.mPathStreamIDsMap.get(pPath).indexOf(steamID));
                break;
            }
        }
    }

    public void pauseEffect(final int steamID) {
        this.mSoundPool.pause(steamID);
    }

    public void resumeEffect(final int steamID) {
        this.mSoundPool.resume(steamID);
    }

    public void pauseAllEffects() {
        if (!this.mPathStreamIDsMap.isEmpty()) {
            final Iterator<Entry<String, ArrayList<Integer>>> iter = this.mPathStreamIDsMap.entrySet().iterator();
            while (iter.hasNext()) {
                final Entry<String, ArrayList<Integer>> entry = iter.next();
                for (final int steamID : entry.getValue()) {
                    this.mSoundPool.pause(steamID);
                }
            }
        }
    }

    public void resumeAllEffects() {
        // can not only invoke SoundPool.autoResume() here, because
        // it only resumes all effects paused by pauseAllEffects()
        if (!this.mPathStreamIDsMap.isEmpty()) {
            final Iterator<Entry<String, ArrayList<Integer>>> iter = this.mPathStreamIDsMap.entrySet().iterator();
            while (iter.hasNext()) {
                final Entry<String, ArrayList<Integer>> entry = iter.next();
                for (final int steamID : entry.getValue()) {
                    this.mSoundPool.resume(steamID);
                }
            }
        }
    }

    @SuppressWarnings("unchecked")
    public void stopAllEffects() {
        // stop effects
        if (!this.mPathStreamIDsMap.isEmpty()) {
            final Iterator<?> iter = this.mPathStreamIDsMap.entrySet().iterator();
            while (iter.hasNext()) {
                final Map.Entry<String, ArrayList<Integer>> entry = (Map.Entry<String, ArrayList<Integer>>) iter.next();
                for (final int steamID : entry.getValue()) {
                    this.mSoundPool.stop(steamID);
                }
            }
        }

        // remove records
        this.mPathStreamIDsMap.clear();
    }

    public float getEffectsVolume() {
        return (this.mLeftVolume + this.mRightVolume) / 2;
    }

    public void setEffectsVolume(float volume) {
        // volume should be in [0, 1.0]
        if (volume < 0) {
            volume = 0;
        }
        if (volume > 1) {
            volume = 1;
        }

        this.mLeftVolume = this.mRightVolume = volume;

        // change the volume of playing sounds
        if (!this.mPathStreamIDsMap.isEmpty()) {
            final Iterator<Entry<String, ArrayList<Integer>>> iter = this.mPathStreamIDsMap.entrySet().iterator();
            while (iter.hasNext()) {
                final Entry<String, ArrayList<Integer>> entry = iter.next();
                for (final int steamID : entry.getValue()) {
                    this.mSoundPool.setVolume(steamID, this.mLeftVolume, this.mRightVolume);
                }
            }
        }
    }

    public void end() {
        this.mSoundPool.release();
        this.mPathStreamIDsMap.clear();
        this.mPathSoundIDMap.clear();
        this.mPlayWhenLoadedEffects.clear();

        this.mLeftVolume = 0.5f;
        this.mRightVolume = 0.5f;

        this.initData();
    }

    public int createSoundIDFromAsset(final String path) {
        int soundID = Cocos2dxSound.INVALID_SOUND_ID;

        try {
            if (path.startsWith("/")) {
                soundID = this.mSoundPool.load(path, 0);
            } else {
                soundID = this.mSoundPool.load(this.mContext.getAssets().openFd(path), 0);
            }
        } catch (final Exception e) {
            soundID = Cocos2dxSound.INVALID_SOUND_ID;
            Log.e(Cocos2dxSound.TAG, "error: " + e.getMessage(), e);
        }

        // mSoundPool.load returns 0 if something goes wrong, for example a file does not exist
        if (soundID == 0) {
            soundID = Cocos2dxSound.INVALID_SOUND_ID;
        }

        return soundID;
    }

        private float clamp(float value, float min, float max) {
            return Math.max(min, (Math.min(value, max)));
        }

    private int doPlayEffect(final String path, final int soundId, final boolean loop, float pitch, float pan, float gain) {
        float leftVolume = this.mLeftVolume * gain * (1.0f - this.clamp(pan, 0.0f, 1.0f));
        float rightVolume = this.mRightVolume * gain * (1.0f - this.clamp(-pan, 0.0f, 1.0f));
        float soundRate = this.clamp(SOUND_RATE * pitch, 0.5f, 2.0f);

        // play sound
        int streamID = this.mSoundPool.play(soundId, this.clamp(leftVolume, 0.0f, 1.0f), this.clamp(rightVolume, 0.0f, 1.0f), Cocos2dxSound.SOUND_PRIORITY, loop ? -1 : 0, soundRate);

        // record stream id
        ArrayList<Integer> streamIDs = this.mPathStreamIDsMap.get(path);
        if (streamIDs == null) {
            streamIDs = new ArrayList<Integer>();
            this.mPathStreamIDsMap.put(path, streamIDs);
        }
        streamIDs.add(streamID);

        return streamID;
    }

    public void onEnterBackground(){
        this.mSoundPool.autoPause();
    }

    public void onEnterForeground(){
        this.mSoundPool.autoResume();
    }

    // ===========================================================
    // Inner and Anonymous Classes
    // ===========================================================

    public class SoundInfoForLoadedCompleted {
        public boolean isLoop;
        public float pitch;
        public float pan;
        public float gain;
        public String path;
        public int effectID;

        public SoundInfoForLoadedCompleted(String path, boolean isLoop, float pitch, float pan, float gain) {
            this.path = path;
            this.isLoop = isLoop;
            this.pitch = pitch;
            this.pan = pan;
            this.gain = gain;
            effectID = Cocos2dxSound.INVALID_SOUND_ID;
        }
    }

    public class OnLoadCompletedListener implements SoundPool.OnLoadCompleteListener {

        @Override
        public void onLoadComplete(SoundPool soundPool, int sampleId, int status) {
            if (status == 0)
            {
                SoundInfoForLoadedCompleted info =  mPlayWhenLoadedEffects.get(sampleId);
                if (info != null) {
                    info.effectID = doPlayEffect(info.path, sampleId, info.isLoop, info.pitch, info.pan, info.gain);
                    synchronized (info) {
                        info.notifyAll();
                    }
                }
            }
        }
    }
}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/Cocos2dxTextInputWraper.java #-}
/****************************************************************************
Copyright (c) 2010-2011 cocos2d-x.org

http://www.cocos2d-x.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 ****************************************************************************/
package org.cocos2dx.lib;

import android.content.Context;
import android.text.Editable;
import android.text.TextWatcher;
import android.util.Log;
import android.view.KeyEvent;
import android.view.inputmethod.EditorInfo;
import android.view.inputmethod.InputMethodManager;
import android.widget.TextView;
import android.widget.TextView.OnEditorActionListener;

public class Cocos2dxTextInputWraper implements TextWatcher, OnEditorActionListener {
    // ===========================================================
    // Constants
    // ===========================================================

    private static final String TAG = Cocos2dxTextInputWraper.class.getSimpleName();

    // ===========================================================
    // Fields
    // ===========================================================

    private final Cocos2dxGLSurfaceView mCocos2dxGLSurfaceView;
    private String mText;
    private String mOriginText;

    // ===========================================================
    // Constructors
    // ===========================================================

    public Cocos2dxTextInputWraper(final Cocos2dxGLSurfaceView pCocos2dxGLSurfaceView) {
        this.mCocos2dxGLSurfaceView = pCocos2dxGLSurfaceView;
    }

    // ===========================================================
    // Getter & Setter
    // ===========================================================

    private boolean isFullScreenEdit() {
        final TextView textField = this.mCocos2dxGLSurfaceView.getCocos2dxEditText();
        final InputMethodManager imm = (InputMethodManager) textField.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
        return imm.isFullscreenMode();
    }

    public void setOriginText(final String pOriginText) {
        this.mOriginText = pOriginText;
    }

    // ===========================================================
    // Methods for/from SuperClass/Interfaces
    // ===========================================================

    @Override
    public void afterTextChanged(final Editable s) {
        if (this.isFullScreenEdit()) {
            return;
        }
        int old_i = 0;
        int new_i = 0;
        while (old_i < this.mText.length() && new_i < s.length()) {
            if (this.mText.charAt(old_i) != s.charAt(new_i)) {
                break;
            }
            old_i += 1;
            new_i += 1;
        }

        for (; old_i < this.mText.length(); ++old_i) {
            this.mCocos2dxGLSurfaceView.deleteBackward();
        }

        int nModified = s.length() - new_i;
        if (nModified > 0) {
            final String insertText = s.subSequence(new_i, s.length()).toString();
            this.mCocos2dxGLSurfaceView.insertText(insertText);
        }

        this.mText = s.toString();
    }

    @Override
    public void beforeTextChanged(final CharSequence pCharSequence, final int start, final int count, final int after) {
        this.mText = pCharSequence.toString();
    }

    @Override
    public void onTextChanged(final CharSequence pCharSequence, final int start, final int before, final int count) {

    }

    @Override
    public boolean onEditorAction(final TextView pTextView, final int pActionID, final KeyEvent pKeyEvent) {
        if (this.mCocos2dxGLSurfaceView.getCocos2dxEditText() == pTextView && this.isFullScreenEdit()) {
            // user press the action button, delete all old text and insert new text
            if (null != mOriginText) {
                for (int i = this.mOriginText.length(); i > 0; i--) {
                    this.mCocos2dxGLSurfaceView.deleteBackward();
                }
            }
            
            String text = pTextView.getText().toString();
            
            if (text != null) {
                /* If user input nothing, translate "\n" to engine. */
                if ( text.compareTo("") == 0) {
                    text = "\n";
                }

                if ( '\n' != text.charAt(text.length() - 1)) {
                    text += '\n';
                }
            }
            
            final String insertText = text;
            this.mCocos2dxGLSurfaceView.insertText(insertText);

        }
        
        if (pActionID == EditorInfo.IME_ACTION_DONE) {
            this.mCocos2dxGLSurfaceView.requestFocus();
        }
        return false;
    }

}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/Cocos2dxTypefaces.java #-}
/****************************************************************************
Copyright (c) 2010-2012 cocos2d-x.org
Copyright (c) 2013-2014 Chukong Technologies Inc.

http://www.cocos2d-x.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 ****************************************************************************/
package org.cocos2dx.lib;

import android.content.Context;
import android.graphics.Typeface;

import java.util.HashMap;

public class Cocos2dxTypefaces {
    // ===========================================================
    // Constants
    // ===========================================================

    // ===========================================================
    // Fields
    // ===========================================================

    private static final HashMap<String, Typeface> sTypefaceCache = new HashMap<String, Typeface>();

    // ===========================================================
    // Constructors
    // ===========================================================

    // ===========================================================
    // Getter & Setter
    // ===========================================================

    // ===========================================================
    // Methods for/from SuperClass/Interfaces
    // ===========================================================

    // ===========================================================
    // Methods
    // ===========================================================

    public static synchronized Typeface get(final Context context, final String assetName) {
        if (!Cocos2dxTypefaces.sTypefaceCache.containsKey(assetName)) {
            Typeface typeface = null;
            if (assetName.startsWith("/"))
            {
                typeface = Typeface.createFromFile(assetName);
            }
            else
            {
                typeface = Typeface.createFromAsset(context.getAssets(), assetName);
            }
            Cocos2dxTypefaces.sTypefaceCache.put(assetName, typeface);
        }

        return Cocos2dxTypefaces.sTypefaceCache.get(assetName);
    }

    // ===========================================================
    // Inner and Anonymous Classes
    // ===========================================================

}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/Cocos2dxVideoHelper.java #-}
/****************************************************************************
Copyright (c) 2014 Chukong Technologies Inc.

http://www.cocos2d-x.org

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
 ****************************************************************************/

package org.cocos2dx.lib;

import android.graphics.Rect;
import android.os.Handler;
import android.os.Message;
import android.util.SparseArray;
import android.view.View;
import android.widget.FrameLayout;

import org.cocos2dx.lib.Cocos2dxVideoView.OnVideoEventListener;

import java.lang.ref.WeakReference;

public class Cocos2dxVideoHelper {

    private FrameLayout mLayout = null;
    private Cocos2dxActivity mActivity = null;  
    private SparseArray<Cocos2dxVideoView> sVideoViews = null;
    static VideoHandler mVideoHandler = null;
    
    Cocos2dxVideoHelper(Cocos2dxActivity activity,FrameLayout layout)
    {
        mActivity = activity;
        mLayout = layout;
        
        mVideoHandler = new VideoHandler(this);
        sVideoViews = new SparseArray<Cocos2dxVideoView>();
    }
    
    private static int videoTag = 0;
    private final static int VideoTaskCreate = 0;
    private final static int VideoTaskRemove = 1;
    private final static int VideoTaskSetSource = 2;
    private final static int VideoTaskSetRect = 3;
    private final static int VideoTaskStart = 4;
    private final static int VideoTaskPause = 5;
    private final static int VideoTaskResume = 6;
    private final static int VideoTaskStop = 7;
    private final static int VideoTaskSeek = 8;
    private final static int VideoTaskSetVisible = 9;
    private final static int VideoTaskRestart = 10;
    private final static int VideoTaskKeepRatio = 11;
    private final static int VideoTaskFullScreen = 12;
    final static int KeyEventBack = 1000;
    
    static class VideoHandler extends Handler{
        WeakReference<Cocos2dxVideoHelper> mReference;
        
        VideoHandler(Cocos2dxVideoHelper helper){
            mReference = new WeakReference<Cocos2dxVideoHelper>(helper);
        }
        
        @Override
        public void handleMessage(Message msg) {
            switch (msg.what) {
            case VideoTaskCreate: {
                Cocos2dxVideoHelper helper = mReference.get();
                helper._createVideoView(msg.arg1);
                break;
            }
            case VideoTaskRemove: {
                Cocos2dxVideoHelper helper = mReference.get();
                helper._removeVideoView(msg.arg1);
                break;
            }
            case VideoTaskSetSource: {
                Cocos2dxVideoHelper helper = mReference.get();
                helper._setVideoURL(msg.arg1, msg.arg2, (String)msg.obj);
                break;
            }
            case VideoTaskStart: {
                Cocos2dxVideoHelper helper = mReference.get();
                helper._startVideo(msg.arg1);
                break;
            }
            case VideoTaskSetRect: {
                Cocos2dxVideoHelper helper = mReference.get();
                Rect rect = (Rect)msg.obj;
                helper._setVideoRect(msg.arg1, rect.left, rect.top, rect.right, rect.bottom);
                break;
            }
            case VideoTaskFullScreen:{
                Cocos2dxVideoHelper helper = mReference.get();
                Rect rect = (Rect)msg.obj;
                if (msg.arg2 == 1) {
                    helper._setFullScreenEnabled(msg.arg1, true, rect.right, rect.bottom);
                } else {
                    helper._setFullScreenEnabled(msg.arg1, false, rect.right, rect.bottom);
                }
                break;
            }
            case VideoTaskPause: {
                Cocos2dxVideoHelper helper = mReference.get();
                helper._pauseVideo(msg.arg1);
                break;
            }
            case VideoTaskResume: {
                Cocos2dxVideoHelper helper = mReference.get();
                helper._resumeVideo(msg.arg1);
                break;
            }
            case VideoTaskStop: {
                Cocos2dxVideoHelper helper = mReference.get();
                helper._stopVideo(msg.arg1);
                break;
            }
            case VideoTaskSeek: {
                Cocos2dxVideoHelper helper = mReference.get();
                helper._seekVideoTo(msg.arg1, msg.arg2);
                break;
            }
            case VideoTaskSetVisible: {
                Cocos2dxVideoHelper helper = mReference.get();
                if (msg.arg2 == 1) {
                    helper._setVideoVisible(msg.arg1, true);
                } else {
                    helper._setVideoVisible(msg.arg1, false);
                }
                break;
            }
            case VideoTaskRestart: {
                Cocos2dxVideoHelper helper = mReference.get();
                helper._restartVideo(msg.arg1);
                break;
            }
            case VideoTaskKeepRatio: {
                Cocos2dxVideoHelper helper = mReference.get();
                if (msg.arg2 == 1) {
                    helper._setVideoKeepRatio(msg.arg1, true);
                } else {
                    helper._setVideoKeepRatio(msg.arg1, false);
                }
                break;
            }
            case KeyEventBack: {
                Cocos2dxVideoHelper helper = mReference.get();
                helper.onBackKeyEvent();
                break;
            }
            default:
                break;
            }
            
            super.handleMessage(msg);
        }
    }
    
    private class VideoEventRunnable implements Runnable
    {
        private int mVideoTag;
        private int mVideoEvent;
        
        public VideoEventRunnable(int tag,int event) {
            mVideoTag = tag;
            mVideoEvent = event;
        }
        @Override
        public void run() {
            nativeExecuteVideoCallback(mVideoTag, mVideoEvent);
        }
        
    }
    
    public static native void nativeExecuteVideoCallback(int index,int event);
    
    OnVideoEventListener videoEventListener = new OnVideoEventListener() {
        
        @Override
        public void onVideoEvent(int tag,int event) {
            mActivity.runOnGLThread(new VideoEventRunnable(tag, event));
        }
    };
    
    
    public static int createVideoWidget() {
        Message msg = new Message();
        msg.what = VideoTaskCreate;
        msg.arg1 = videoTag;
        mVideoHandler.sendMessage(msg);
        
        return videoTag++;
    }
    
    private void _createVideoView(int index) {
        Cocos2dxVideoView videoView = new Cocos2dxVideoView(mActivity,index);
        sVideoViews.put(index, videoView);
        FrameLayout.LayoutParams lParams = new FrameLayout.LayoutParams(
                FrameLayout.LayoutParams.WRAP_CONTENT,
                FrameLayout.LayoutParams.WRAP_CONTENT);
        mLayout.addView(videoView, lParams);
        videoView.setZOrderOnTop(true);
        videoView.setOnCompletionListener(videoEventListener);
    }
    
    public static void removeVideoWidget(int index){
        Message msg = new Message();
        msg.what = VideoTaskRemove;
        msg.arg1 = index;
        mVideoHandler.sendMessage(msg);
    }
    
    private void _removeVideoView(int index) {
        Cocos2dxVideoView view = sVideoViews.get(index);
        if (view != null) {
            view.stopPlayback();
            sVideoViews.remove(index);
            mLayout.removeView(view);
        }
    }
    
    public static void setVideoUrl(int index, int videoSource, String videoUrl) {
        Message msg = new Message();
        msg.what = VideoTaskSetSource;
        msg.arg1 = index;
        msg.arg2 = videoSource;
        msg.obj = videoUrl;
        mVideoHandler.sendMessage(msg);
    }
    
    private void _setVideoURL(int index, int videoSource, String videoUrl) {
        Cocos2dxVideoView videoView = sVideoViews.get(index);
        if (videoView != null) {
            switch (videoSource) {
            case 0:
                videoView.setVideoFileName(videoUrl);
                break;
            case 1:
                videoView.setVideoURL(videoUrl);
                break;
            default:
                break;
            }
        }
    }
    
    public static void setVideoRect(int index, int left, int top, int maxWidth, int maxHeight) {
        Message msg = new Message();
        msg.what = VideoTaskSetRect;
        msg.arg1 = index;
        msg.obj = new Rect(left, top, maxWidth, maxHeight);
        mVideoHandler.sendMessage(msg);
    }
    
    private void _setVideoRect(int index, int left, int top, int maxWidth, int maxHeight) {
        Cocos2dxVideoView videoView = sVideoViews.get(index);
        if (videoView != null) {
            videoView.setVideoRect(left,top,maxWidth,maxHeight);
        }
    }
    
    public static void setFullScreenEnabled(int index, boolean enabled, int width, int height) {
        Message msg = new Message();
        msg.what = VideoTaskFullScreen;
        msg.arg1 = index;
        if (enabled) {
            msg.arg2 = 1;
        } else {
            msg.arg2 = 0;
        }
        msg.obj = new Rect(0, 0, width, height);
        mVideoHandler.sendMessage(msg);
    }
    
    private void _setFullScreenEnabled(int index, boolean enabled, int width,int height) {
        Cocos2dxVideoView videoView = sVideoViews.get(index);
        if (videoView != null) {
            videoView.setFullScreenEnabled(enabled, width, height);
        }
    }
    
    private void onBackKeyEvent() {
        int viewCount = sVideoViews.size();
        for (int i = 0; i < viewCount; i++) {
            int key = sVideoViews.keyAt(i);
            Cocos2dxVideoView videoView = sVideoViews.get(key);
            if (videoView != null) {
                videoView.setFullScreenEnabled(false, 0, 0);
                mActivity.runOnGLThread(new VideoEventRunnable(key, KeyEventBack));
            }
        }
    }
    
    public static void startVideo(int index) {
        Message msg = new Message();
        msg.what = VideoTaskStart;
        msg.arg1 = index;
        mVideoHandler.sendMessage(msg);
    }
    
    private void _startVideo(int index) {
        Cocos2dxVideoView videoView = sVideoViews.get(index);
        if (videoView != null) {
            videoView.start();
        }
    }
    
    public static void pauseVideo(int index) {
        Message msg = new Message();
        msg.what = VideoTaskPause;
        msg.arg1 = index;
        mVideoHandler.sendMessage(msg);
    }
    
    private void _pauseVideo(int index) {
        Cocos2dxVideoView videoView = sVideoViews.get(index);
        if (videoView != null) {
            videoView.pause();
        }
    }

    public static void resumeVideo(int index) {
        Message msg = new Message();
        msg.what = VideoTaskResume;
        msg.arg1 = index;
        mVideoHandler.sendMessage(msg);
    }
    
    private void _resumeVideo(int index) {
        Cocos2dxVideoView videoView = sVideoViews.get(index);
        if (videoView != null) {
            videoView.resume();
        }
    }
    
    public static void stopVideo(int index) {
        Message msg = new Message();
        msg.what = VideoTaskStop;
        msg.arg1 = index;
        mVideoHandler.sendMessage(msg);
    }
    
    private void _stopVideo(int index) {
        Cocos2dxVideoView videoView = sVideoViews.get(index);
        if (videoView != null) {
            videoView.stop();
        }
    }
    
    public static void restartVideo(int index) {
        Message msg = new Message();
        msg.what = VideoTaskRestart;
        msg.arg1 = index;
        mVideoHandler.sendMessage(msg);
    }
    
    private void _restartVideo(int index) {
        Cocos2dxVideoView videoView = sVideoViews.get(index);
        if (videoView != null) {
            videoView.restart();
        }
    }
    
    public static void seekVideoTo(int index,int msec) {
        Message msg = new Message();
        msg.what = VideoTaskSeek;
        msg.arg1 = index;
        msg.arg2 = msec;
        mVideoHandler.sendMessage(msg);
    }
    
    private void _seekVideoTo(int index,int msec) {
        Cocos2dxVideoView videoView = sVideoViews.get(index);
        if (videoView != null) {
            videoView.seekTo(msec);
        }
    }
    
    public static void setVideoVisible(int index, boolean visible) {
        Message msg = new Message();
        msg.what = VideoTaskSetVisible;
        msg.arg1 = index;
        if (visible) {
            msg.arg2 = 1;
        } else {
            msg.arg2 = 0;
        }
        
        mVideoHandler.sendMessage(msg);
    }
    
    private void _setVideoVisible(int index, boolean visible) {
        Cocos2dxVideoView videoView = sVideoViews.get(index);
        if (videoView != null) {
            if (visible) {
                videoView.fixSize();
                videoView.setVisibility(View.VISIBLE);
            } else {
                videoView.setVisibility(View.INVISIBLE);
            }
        }
    }
    
    public static void setVideoKeepRatioEnabled(int index, boolean enable) {
        Message msg = new Message();
        msg.what = VideoTaskKeepRatio;
        msg.arg1 = index;
        if (enable) {
            msg.arg2 = 1;
        } else {
            msg.arg2 = 0;
        }
        mVideoHandler.sendMessage(msg);
    }
    
    private void _setVideoKeepRatio(int index, boolean enable) {
        Cocos2dxVideoView videoView = sVideoViews.get(index);
        if (videoView != null) {
            videoView.setKeepRatio(enable);
        }
    }
}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/Cocos2dxVideoView.java #-}
/*
 * Copyright (C) 2006 The Android Open Source Project
 * Copyright (c) 2014 Chukong Technologies Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.cocos2dx.lib;

import android.app.AlertDialog;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.res.AssetFileDescriptor;
import android.content.res.Resources;
import android.media.AudioManager;
import android.media.MediaPlayer;
import android.media.MediaPlayer.OnErrorListener;
import android.net.Uri;
import android.util.Log;
import android.view.Gravity;
import android.view.MotionEvent;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.widget.FrameLayout;
import android.widget.MediaController.MediaPlayerControl;

import com.chukong.cocosplay.client.CocosPlayClient;

import java.io.IOException;
import java.util.Map;

public class Cocos2dxVideoView extends SurfaceView implements MediaPlayerControl {
    private String TAG = "Cocos2dxVideoView";
    
    private Uri         mVideoUri;   
    private int         mDuration;

    // all possible internal states
    private static final int STATE_ERROR              = -1;
    private static final int STATE_IDLE               = 0;
    private static final int STATE_PREPARING          = 1;
    private static final int STATE_PREPARED           = 2;
    private static final int STATE_PLAYING            = 3;
    private static final int STATE_PAUSED             = 4;
    private static final int STATE_PLAYBACK_COMPLETED = 5;

    /**
     * mCurrentState is a VideoView object's current state.
     * mTargetState is the state that a method caller intends to reach.
     * For instance, regardless the VideoView object's current state,
     * calling pause() intends to bring the object to a target state
     * of STATE_PAUSED.
     */
    private int mCurrentState = STATE_IDLE;
    private int mTargetState  = STATE_IDLE;

    // All the stuff we need for playing and showing a video
    private SurfaceHolder mSurfaceHolder = null;
    private MediaPlayer mMediaPlayer = null;
    private int         mVideoWidth = 0;
    private int         mVideoHeight = 0;
    
    private OnVideoEventListener mOnVideoEventListener;
    private MediaPlayer.OnPreparedListener mOnPreparedListener;
    private int         mCurrentBufferPercentage;
    private OnErrorListener mOnErrorListener;
    
    // recording the seek position while preparing
    private int         mSeekWhenPrepared;  

    protected Cocos2dxActivity mCocos2dxActivity = null;
    
    protected int mViewLeft = 0;
    protected int mViewTop = 0;
    protected int mViewWidth = 0;
    protected int mViewHeight = 0;
    
    protected int mVisibleLeft = 0;
    protected int mVisibleTop = 0;
    protected int mVisibleWidth = 0;
    protected int mVisibleHeight = 0;
    
    protected boolean mFullScreenEnabled = false;
    protected int mFullScreenWidth = 0;
    protected int mFullScreenHeight = 0;
    
    private int mViewTag = 0;
    
    public Cocos2dxVideoView(Cocos2dxActivity activity,int tag) {
        super(activity);
        
        mViewTag = tag;
        mCocos2dxActivity = activity;
        initVideoView();
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        if (mVideoWidth == 0 || mVideoHeight == 0) {
            setMeasuredDimension(mViewWidth, mViewHeight);
            Log.i(TAG, ""+mViewWidth+ ":" +mViewHeight);
        }
        else {
            setMeasuredDimension(mVisibleWidth, mVisibleHeight);
            Log.i(TAG, ""+mVisibleWidth+ ":" +mVisibleHeight);
        }
        
    }
    
    public void setVideoRect(int left, int top, int maxWidth, int maxHeight) {
        mViewLeft = left;
        mViewTop = top;
        mViewWidth = maxWidth;
        mViewHeight = maxHeight;
        
        fixSize(mViewLeft, mViewTop, mViewWidth, mViewHeight);
    }
    
    public void setFullScreenEnabled(boolean enabled, int width, int height) {
        if (mFullScreenEnabled != enabled) {
            mFullScreenEnabled = enabled;
            if (width != 0 && height != 0) {
                mFullScreenWidth = width;
                mFullScreenHeight = height;
            }
            
            fixSize();
        }
    }
    
    public int resolveAdjustedSize(int desiredSize, int measureSpec) {
        int result = desiredSize;
        int specMode = MeasureSpec.getMode(measureSpec);
        int specSize =  MeasureSpec.getSize(measureSpec);

        switch (specMode) {
            case MeasureSpec.UNSPECIFIED:
                /* Parent says we can be as big as we want. Just don't be larger
                 * than max size imposed on ourselves.
                 */
                result = desiredSize;
                break;

            case MeasureSpec.AT_MOST:
                /* Parent says we can be as big as we want, up to specSize.
                 * Don't be larger than specSize, and don't be larger than
                 * the max size imposed on ourselves.
                 */
                result = Math.min(desiredSize, specSize);
                break;

            case MeasureSpec.EXACTLY:
                // No choice. Do what we are told.
                result = specSize;
                break;
        }
        
        return result;
    }

    private boolean mNeedResume = false;
    
    @Override
    public void setVisibility(int visibility) {
        if (visibility == INVISIBLE) {
            mNeedResume = isPlaying();
            if (mNeedResume) {
                mSeekWhenPrepared = getCurrentPosition();
            }
        }
        else if (mNeedResume){
            start();
            mNeedResume = false;
        }
        super.setVisibility(visibility);
    }
    
    private void initVideoView() {
        mVideoWidth = 0;
        mVideoHeight = 0;
        getHolder().addCallback(mSHCallback);
        //Fix issue#11516:Can't play video on Android 2.3.x
        getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);
        setFocusable(true);
        setFocusableInTouchMode(true);
        mCurrentState = STATE_IDLE;
        mTargetState  = STATE_IDLE;
    }
    
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if((event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_UP)
        {
            if (isPlaying()) {
                pause();
            } else if(mCurrentState == STATE_PAUSED){
                resume();
            }
        }
        
        return true;
    }
    
    private boolean mIsAssetRouse = false;
    private String mVideoFilePath = null;
    private static final String AssetResourceRoot = "assets/";
    
    public void setVideoFileName(String path) {
        if (path.startsWith(AssetResourceRoot)) {
            path = path.substring(AssetResourceRoot.length());
        }
        if (CocosPlayClient.isEnabled() && !CocosPlayClient.isDemo()) {
            CocosPlayClient.updateAssets(path);
        }
        CocosPlayClient.notifyFileLoaded(path);
        if (path.startsWith("/")) {
            mIsAssetRouse = false;
            setVideoURI(Uri.parse(path),null);
        }
        else {
            mVideoFilePath = path;
            mIsAssetRouse = true;
            setVideoURI(Uri.parse(path),null);
        }
    }
    
    public void setVideoURL(String url) {
        mIsAssetRouse = false;
        setVideoURI(Uri.parse(url), null);
    }

    /**
     * @hide
     */
    private void setVideoURI(Uri uri, Map<String, String> headers) {
        mVideoUri = uri;
        mSeekWhenPrepared = 0;
        mVideoWidth = 0;
        mVideoHeight = 0;
        openVideo();
        requestLayout();
        invalidate();
    }
    
    public void stopPlayback() {
        if (mMediaPlayer != null) {
            mMediaPlayer.stop();
            mMediaPlayer.release();
            mMediaPlayer = null;
            mCurrentState = STATE_IDLE;
            mTargetState  = STATE_IDLE;
        }
    }

    private void openVideo() {
        if (mSurfaceHolder == null) {
            // not ready for playback just yet, will try again later
            return;
        }
        if (mIsAssetRouse) {
            if(mVideoFilePath == null)
                return;
        } else if(mVideoUri == null) {
            return;
        }
        
        // Tell the music playback service to pause
        // TODO: these constants need to be published somewhere in the framework.
        Intent i = new Intent("com.android.music.musicservicecommand");
        i.putExtra("command", "pause");
        mCocos2dxActivity.sendBroadcast(i);

        // we shouldn't clear the target state, because somebody might have
        // called start() previously
        release(false);
        
        try {
            //if (mMediaPlayer == null) {
                mMediaPlayer = new MediaPlayer();
                mMediaPlayer.setOnPreparedListener(mPreparedListener);
                mMediaPlayer.setOnVideoSizeChangedListener(mSizeChangedListener);                
                mMediaPlayer.setOnCompletionListener(mCompletionListener);
                mMediaPlayer.setOnErrorListener(mErrorListener);
                mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener);
                
                mMediaPlayer.setDisplay(mSurfaceHolder);
                mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
                mMediaPlayer.setScreenOnWhilePlaying(true);
            //}
            
            mDuration = -1;
            mCurrentBufferPercentage = 0;
            if (mIsAssetRouse) {
                AssetFileDescriptor afd = mCocos2dxActivity.getAssets().openFd(mVideoFilePath);
                mMediaPlayer.setDataSource(afd.getFileDescriptor(),afd.getStartOffset(),afd.getLength());
            } else {
                mMediaPlayer.setDataSource(mCocos2dxActivity, mVideoUri);
            }
            
            mMediaPlayer.prepareAsync();

            /**
             * Don't set the target state here either, but preserve the target state that was there before.
             */
            mCurrentState = STATE_PREPARING;
        } catch (IOException ex) {
            Log.w(TAG, "Unable to open content: " + mVideoUri, ex);
            mCurrentState = STATE_ERROR;
            mTargetState = STATE_ERROR;
            mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
            return;
        } catch (IllegalArgumentException ex) {
            Log.w(TAG, "Unable to open content: " + mVideoUri, ex);
            mCurrentState = STATE_ERROR;
            mTargetState = STATE_ERROR;
            mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);
            return;
        }
    }
    
    private boolean mKeepRatio = false;
    
    public void setKeepRatio(boolean enabled) {
        mKeepRatio = enabled;
        fixSize();
    }

    public void fixSize() {
        if (mFullScreenEnabled) {
            fixSize(0, 0, mFullScreenWidth, mFullScreenHeight);
        } else {
            fixSize(mViewLeft, mViewTop, mViewWidth, mViewHeight);
        }
    }
    
    public void fixSize(int left, int top, int width, int height) {
        if (mVideoWidth == 0 || mVideoHeight == 0) {
            mVisibleLeft = left;
            mVisibleTop = top;
            mVisibleWidth = width;
            mVisibleHeight = height;
        }
        else if (width != 0 && height != 0) {
            if (mKeepRatio) {
                if ( mVideoWidth * height  > width * mVideoHeight ) {
                    mVisibleWidth = width;
                    mVisibleHeight = width * mVideoHeight / mVideoWidth;
                } else if ( mVideoWidth * height  < width * mVideoHeight ) {
                    mVisibleWidth = height * mVideoWidth / mVideoHeight;
                    mVisibleHeight = height;
                }
                mVisibleLeft = left + (width - mVisibleWidth) / 2;
                mVisibleTop = top + (height - mVisibleHeight) / 2;
            } else {
                mVisibleLeft = left;
                mVisibleTop = top;
                mVisibleWidth = width;
                mVisibleHeight = height;
            }
        }
        else {
            mVisibleLeft = left;
            mVisibleTop = top;
            mVisibleWidth = mVideoWidth;
            mVisibleHeight = mVideoHeight;
        }
        
        getHolder().setFixedSize(mVisibleWidth, mVisibleHeight);
        
        FrameLayout.LayoutParams lParams = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT,
                FrameLayout.LayoutParams.WRAP_CONTENT);
        lParams.leftMargin = mVisibleLeft;
        lParams.topMargin = mVisibleTop;
        lParams.gravity = Gravity.TOP | Gravity.LEFT;
        setLayoutParams(lParams);
    }

    protected 
    MediaPlayer.OnVideoSizeChangedListener mSizeChangedListener =
        new MediaPlayer.OnVideoSizeChangedListener() {
            public void onVideoSizeChanged(MediaPlayer mp, int width, int height) {
                mVideoWidth = mp.getVideoWidth();
                mVideoHeight = mp.getVideoHeight();
                if (mVideoWidth != 0 && mVideoHeight != 0) {
                    getHolder().setFixedSize(mVideoWidth, mVideoHeight);
                }
            }
    };
    

    MediaPlayer.OnPreparedListener mPreparedListener = new MediaPlayer.OnPreparedListener() {
        public void onPrepared(MediaPlayer mp) {
            mCurrentState = STATE_PREPARED;

            if (mOnPreparedListener != null) {
                mOnPreparedListener.onPrepared(mMediaPlayer);
            }
            
            mVideoWidth = mp.getVideoWidth();
            mVideoHeight = mp.getVideoHeight();

            // mSeekWhenPrepared may be changed after seekTo() call
            int seekToPosition = mSeekWhenPrepared;  
            if (seekToPosition != 0) {
                seekTo(seekToPosition);
            }
            
            if (mVideoWidth != 0 && mVideoHeight != 0) {
                fixSize();
            } 
            
            if (mTargetState == STATE_PLAYING) {
                start();
            }
        }
    };

    private MediaPlayer.OnCompletionListener mCompletionListener =
        new MediaPlayer.OnCompletionListener() {
        public void onCompletion(MediaPlayer mp) {
            mCurrentState = STATE_PLAYBACK_COMPLETED;
            mTargetState = STATE_PLAYBACK_COMPLETED;
            
            release(true);
            if (mOnVideoEventListener != null) {
                mOnVideoEventListener.onVideoEvent(mViewTag,EVENT_COMPLETED);
            }
        }
    };
    
    
    private static final int EVENT_PLAYING = 0;
    private static final int EVENT_PAUSED = 1;
    private static final int EVENT_STOPPED = 2;
    private static final int EVENT_COMPLETED = 3;
    
    public interface OnVideoEventListener
    {
        void onVideoEvent(int tag,int event);
    }

    private MediaPlayer.OnErrorListener mErrorListener =
        new MediaPlayer.OnErrorListener() {
        public boolean onError(MediaPlayer mp, int framework_err, int impl_err) {
            Log.d(TAG, "Error: " + framework_err + "," + impl_err);
            mCurrentState = STATE_ERROR;
            mTargetState = STATE_ERROR;

            /* If an error handler has been supplied, use it and finish. */
            if (mOnErrorListener != null) {
                if (mOnErrorListener.onError(mMediaPlayer, framework_err, impl_err)) {
                    return true;
                }
            }

            /* Otherwise, pop up an error dialog so the user knows that
             * something bad has happened. Only try and pop up the dialog
             * if we're attached to a window. When we're going away and no
             * longer have a window, don't bother showing the user an error.
             */
            if (getWindowToken() != null) {
                Resources r = mCocos2dxActivity.getResources();
                int messageId;
                
                if (framework_err == MediaPlayer.MEDIA_ERROR_NOT_VALID_FOR_PROGRESSIVE_PLAYBACK) {
                    // messageId = com.android.internal.R.string.VideoView_error_text_invalid_progressive_playback;
                    messageId = r.getIdentifier("VideoView_error_text_invalid_progressive_playback", "string", "android");
                } else {
                    // messageId = com.android.internal.R.string.VideoView_error_text_unknown;
                    messageId = r.getIdentifier("VideoView_error_text_unknown", "string", "android");
                }
                
                int titleId = r.getIdentifier("VideoView_error_title", "string", "android");
                int buttonStringId = r.getIdentifier("VideoView_error_button", "string", "android");
                
                new AlertDialog.Builder(mCocos2dxActivity)
                        .setTitle(r.getString(titleId))
                        .setMessage(messageId)
                        .setPositiveButton(r.getString(buttonStringId),
                                new DialogInterface.OnClickListener() {
                                    public void onClick(DialogInterface dialog, int whichButton) {
                                        /* If we get here, there is no onError listener, so
                                         * at least inform them that the video is over.
                                         */
                                        if (mOnVideoEventListener != null) {
                                            mOnVideoEventListener.onVideoEvent(mViewTag,EVENT_COMPLETED);
                                        }
                                    }
                                })
                        .setCancelable(false)
                        .show();
            }
            return true;
        }
    };

    private MediaPlayer.OnBufferingUpdateListener mBufferingUpdateListener =
        new MediaPlayer.OnBufferingUpdateListener() {
        public void onBufferingUpdate(MediaPlayer mp, int percent) {
            mCurrentBufferPercentage = percent;
        }
    };

    /**
     * Register a callback to be invoked when the media file
     * is loaded and ready to go.
     *
     * @param l The callback that will be run
     */
    public void setOnPreparedListener(MediaPlayer.OnPreparedListener l)
    {
        mOnPreparedListener = l;
    }

    /**
     * Register a callback to be invoked when the end of a media file
     * has been reached during play back.
     *
     * @param l The callback that will be run
     */
    public void setOnCompletionListener(OnVideoEventListener l)
    {
        mOnVideoEventListener = l;
    }

    /**
     * Register a callback to be invoked when an error occurs
     * during play back or setup.  If no listener is specified,
     * or if the listener returned false, VideoView will inform
     * the user of any errors.
     *
     * @param l The callback that will be run
     */
    public void setOnErrorListener(OnErrorListener l)
    {
        mOnErrorListener = l;
    }

    SurfaceHolder.Callback mSHCallback = new SurfaceHolder.Callback()
    {
        public void surfaceChanged(SurfaceHolder holder, int format,
                                    int w, int h)
        {
            boolean isValidState =  (mTargetState == STATE_PLAYING);
            boolean hasValidSize = (mVideoWidth == w && mVideoHeight == h);
            if (mMediaPlayer != null && isValidState && hasValidSize) {
                if (mSeekWhenPrepared != 0) {
                    seekTo(mSeekWhenPrepared);
                }
                start();
            }
        }

        public void surfaceCreated(SurfaceHolder holder)
        {
            mSurfaceHolder = holder;
            openVideo();
        }

        public void surfaceDestroyed(SurfaceHolder holder)
        {
            // after we return from this we can't use the surface any more
            mSurfaceHolder = null;
            
            release(true);
        }
    };

    /*
     * release the media player in any state
     */
    private void release(boolean cleartargetstate) {
        if (mMediaPlayer != null) {
            mMediaPlayer.reset();
            mMediaPlayer.release();
            mMediaPlayer = null;
            mCurrentState = STATE_IDLE;
            if (cleartargetstate) {
                mTargetState  = STATE_IDLE;
            }
        }
    }
    
    public void start() {
        if (isInPlaybackState()) {
            mMediaPlayer.start();
            mCurrentState = STATE_PLAYING;
            if (mOnVideoEventListener != null) {
                mOnVideoEventListener.onVideoEvent(mViewTag, EVENT_PLAYING);
            }
        }
        mTargetState = STATE_PLAYING;
    }

    public void pause() {
        if (isInPlaybackState()) {
            if (mMediaPlayer.isPlaying()) {
                mMediaPlayer.pause();
                mCurrentState = STATE_PAUSED;
                if (mOnVideoEventListener != null) {
                    mOnVideoEventListener.onVideoEvent(mViewTag, EVENT_PAUSED);
                }
            }
        }
        mTargetState = STATE_PAUSED;
    }
    
    public void stop() {
        if (isInPlaybackState()) {
            if (mMediaPlayer.isPlaying()) {
               stopPlayback();
                if (mOnVideoEventListener != null) {
                    mOnVideoEventListener.onVideoEvent(mViewTag, EVENT_STOPPED);
                }
            }
        }
    }

    public void suspend() {
        release(false);
    }

    public void resume() {
        if (isInPlaybackState()) {
            if (mCurrentState == STATE_PAUSED) {
                mMediaPlayer.start();
                mCurrentState = STATE_PLAYING;
                if (mOnVideoEventListener != null) {
                    mOnVideoEventListener.onVideoEvent(mViewTag, EVENT_PLAYING);
                }
            }
        }
    }

    public void restart() {
        if (isInPlaybackState()) {
            mMediaPlayer.seekTo(0);
            mMediaPlayer.start();
            mCurrentState = STATE_PLAYING;
            mTargetState = STATE_PLAYING;
        }
    }
    // cache duration as mDuration for faster access
    public int getDuration() {
        if (isInPlaybackState()) {
            if (mDuration > 0) {
                return mDuration;
            }
            mDuration = mMediaPlayer.getDuration();
            return mDuration;
        }
        mDuration = -1;
        return mDuration;
    }

    public int getCurrentPosition() {
        if (isInPlaybackState()) {
            return mMediaPlayer.getCurrentPosition();
        }
        return 0;
    }

    public void seekTo(int msec) {
        if (isInPlaybackState()) {
            mMediaPlayer.seekTo(msec);
            mSeekWhenPrepared = 0;
        } else {
            mSeekWhenPrepared = msec;
        }
    }

    public boolean isPlaying() {
        return isInPlaybackState() && mMediaPlayer.isPlaying();
    }

    public int getBufferPercentage() {
        if (mMediaPlayer != null) {
            return mCurrentBufferPercentage;
        }
        return 0;
    }

    public boolean isInPlaybackState() {
        return (mMediaPlayer != null &&
                mCurrentState != STATE_ERROR &&
                mCurrentState != STATE_IDLE &&
                mCurrentState != STATE_PREPARING);
    }

    @Override
    public boolean canPause() {
        return true;
    }

    @Override
    public boolean canSeekBackward() {
        return true;
    }

    @Override
    public boolean canSeekForward() {
        return true;
    }
        
    public int getAudioSessionId () {
       return mMediaPlayer.getAudioSessionId();
    }
}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/Cocos2dxWebView.java #-}
package org.cocos2dx.lib;

import android.annotation.SuppressLint;
import android.content.Context;
import android.util.Log;
import android.view.Gravity;
import android.webkit.WebChromeClient;
import android.webkit.WebView;
import android.webkit.WebViewClient;
import android.widget.FrameLayout;

import java.lang.reflect.Method;
import java.net.URI;
import java.util.concurrent.CountDownLatch;

class ShouldStartLoadingWorker implements Runnable {
    private CountDownLatch mLatch;
    private boolean[] mResult;
    private final int mViewTag;
    private final String mUrlString;

    ShouldStartLoadingWorker(CountDownLatch latch, boolean[] result, int viewTag, String urlString) {
        this.mLatch = latch;
        this.mResult = result;
        this.mViewTag = viewTag;
        this.mUrlString = urlString;
    }

    @Override
    public void run() {
        this.mResult[0] = Cocos2dxWebViewHelper._shouldStartLoading(mViewTag, mUrlString);
        this.mLatch.countDown(); // notify that result is ready
    }
}

public class Cocos2dxWebView extends WebView {
    private static final String TAG = Cocos2dxWebViewHelper.class.getSimpleName();

    private int mViewTag;
    private String mJSScheme;

    public Cocos2dxWebView(Context context) {
        this(context, -1);
    }

    @SuppressLint("SetJavaScriptEnabled")
    public Cocos2dxWebView(Context context, int viewTag) {
        super(context);
        this.mViewTag = viewTag;
        this.mJSScheme = "";

        this.setFocusable(true);
        this.setFocusableInTouchMode(true);

        this.getSettings().setSupportZoom(false);

        this.getSettings().setJavaScriptEnabled(true);

        // `searchBoxJavaBridge_` has big security risk. http://jvn.jp/en/jp/JVN53768697
        try {
            Method method = this.getClass().getMethod("removeJavascriptInterface", new Class[]{String.class});
            method.invoke(this, "searchBoxJavaBridge_");
        } catch (Exception e) {
            Log.d(TAG, "This API level do not support `removeJavascriptInterface`");
        }

        this.setWebViewClient(new Cocos2dxWebViewClient());
        this.setWebChromeClient(new WebChromeClient());
    }

    public void setJavascriptInterfaceScheme(String scheme) {
        this.mJSScheme = scheme != null ? scheme : "";
    }

    public void setScalesPageToFit(boolean scalesPageToFit) {
        this.getSettings().setSupportZoom(scalesPageToFit);
    }

    class Cocos2dxWebViewClient extends WebViewClient {
        @Override
        public boolean shouldOverrideUrlLoading(WebView view, final String urlString) {
            Cocos2dxActivity activity = (Cocos2dxActivity)getContext();

            try {
                URI uri = URI.create(urlString);
                if (uri != null && uri.getScheme().equals(mJSScheme)) {
                    activity.runOnGLThread(new Runnable() {
                        @Override
                        public void run() {
                            Cocos2dxWebViewHelper._onJsCallback(mViewTag, urlString);
                        }
                    });
                    return true;
                }
            } catch (Exception e) {
                Log.d(TAG, "Failed to create URI from url");
            }

            boolean[] result = new boolean[] { true };
            CountDownLatch latch = new CountDownLatch(1);

            // run worker on cocos thread
            activity.runOnGLThread(new ShouldStartLoadingWorker(latch, result, mViewTag, urlString));

            // wait for result from cocos thread
            try {
                latch.await();
            } catch (InterruptedException ex) {
                Log.d(TAG, "'shouldOverrideUrlLoading' failed");
            }

            return result[0];
        }

        @Override
        public void onPageFinished(WebView view, final String url) {
            super.onPageFinished(view, url);
            Cocos2dxActivity activity = (Cocos2dxActivity)getContext();
            activity.runOnGLThread(new Runnable() {
                @Override
                public void run() {
                    Cocos2dxWebViewHelper._didFinishLoading(mViewTag, url);
                }
            });
        }

        @Override
        public void onReceivedError(WebView view, int errorCode, String description, final String failingUrl) {
            super.onReceivedError(view, errorCode, description, failingUrl);
            Cocos2dxActivity activity = (Cocos2dxActivity)getContext();
            activity.runOnGLThread(new Runnable() {
                @Override
                public void run() {
                    Cocos2dxWebViewHelper._didFailLoading(mViewTag, failingUrl);
                }
            });
        }
    }

    public void setWebViewRect(int left, int top, int maxWidth, int maxHeight) {
        FrameLayout.LayoutParams layoutParams = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.WRAP_CONTENT,
                FrameLayout.LayoutParams.WRAP_CONTENT);
        layoutParams.leftMargin = left;
        layoutParams.topMargin = top;
        layoutParams.width = maxWidth;
        layoutParams.height = maxHeight;
        layoutParams.gravity = Gravity.TOP | Gravity.LEFT;
        this.setLayoutParams(layoutParams);
    }
}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/Cocos2dxWebViewHelper.java #-}
package org.cocos2dx.lib;

import android.os.Handler;
import android.os.Looper;
import android.util.SparseArray;
import android.view.View;
import android.widget.FrameLayout;

import com.chukong.cocosplay.client.CocosPlayClient;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;


public class Cocos2dxWebViewHelper {
    private static final String TAG = Cocos2dxWebViewHelper.class.getSimpleName();
    private static Handler sHandler;
    private static Cocos2dxActivity sCocos2dxActivity;
    private static FrameLayout sLayout;

    private static SparseArray<Cocos2dxWebView> webViews;
    private static int viewTag = 0;

    public Cocos2dxWebViewHelper(FrameLayout layout) {
        Cocos2dxWebViewHelper.sLayout = layout;
        Cocos2dxWebViewHelper.sHandler = new Handler(Looper.myLooper());

        Cocos2dxWebViewHelper.sCocos2dxActivity = (Cocos2dxActivity) Cocos2dxActivity.getContext();
        Cocos2dxWebViewHelper.webViews = new SparseArray<Cocos2dxWebView>();
    }

    private static native boolean shouldStartLoading(int index, String message);

    public static boolean _shouldStartLoading(int index, String message) {
        return !shouldStartLoading(index, message);
    }

    private static native void didFinishLoading(int index, String message);

    public static void _didFinishLoading(int index, String message) {
        didFinishLoading(index, message);
    }

    private static native void didFailLoading(int index, String message);

    public static void _didFailLoading(int index, String message) {
        didFailLoading(index, message);
    }

    private static native void onJsCallback(int index, String message);

    public static void _onJsCallback(int index, String message) {
        onJsCallback(index, message);
    }

    public static int createWebView() {
        final int index = viewTag;
        sCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxWebView webView = new Cocos2dxWebView(sCocos2dxActivity, index);
                FrameLayout.LayoutParams lParams = new FrameLayout.LayoutParams(
                        FrameLayout.LayoutParams.WRAP_CONTENT,
                        FrameLayout.LayoutParams.WRAP_CONTENT);
                sLayout.addView(webView, lParams);

                webViews.put(index, webView);
            }
        });
        return viewTag++;
    }

    public static void removeWebView(final int index) {
        sCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxWebView webView = webViews.get(index);
                if (webView != null) {
                    webViews.remove(index);
                    sLayout.removeView(webView);
                }
            }
        });
    }

    public static void setVisible(final int index, final boolean visible) {
        sCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxWebView webView = webViews.get(index);
                if (webView != null) {
                    webView.setVisibility(visible ? View.VISIBLE : View.GONE);
                }
            }
        });
    }

    public static void setWebViewRect(final int index, final int left, final int top, final int maxWidth, final int maxHeight) {
        sCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxWebView webView = webViews.get(index);
                if (webView != null) {
                    webView.setWebViewRect(left, top, maxWidth, maxHeight);
                }
            }
        });
    }

    public static void setJavascriptInterfaceScheme(final int index, final String scheme) {
        sCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxWebView webView = webViews.get(index);
                if (webView != null) {
                    webView.setJavascriptInterfaceScheme(scheme);
                }
            }
        });
    }

    public static void loadData(final int index, final String data, final String mimeType, final String encoding, final String baseURL) {
        sCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxWebView webView = webViews.get(index);
                if (webView != null) {
                    webView.loadDataWithBaseURL(baseURL, data, mimeType, encoding, null);
                }
            }
        });
    }

    public static void loadHTMLString(final int index, final String data, final String baseUrl) {
        sCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxWebView webView = webViews.get(index);
                if (webView != null) {
                    webView.loadDataWithBaseURL(baseUrl, data, null, null, null);
                }
            }
        });
    }

    public static void loadUrl(final int index, final String url) {
        sCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxWebView webView = webViews.get(index);
                if (webView != null) {
                    webView.loadUrl(url);
                }
            }
        });
    }

    public static void loadFile(final int index, final String filePath) {
        if (CocosPlayClient.isEnabled() && !CocosPlayClient.isDemo()) {
            CocosPlayClient.updateAssets(filePath);
        }
        CocosPlayClient.notifyFileLoaded(filePath);
        sCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxWebView webView = webViews.get(index);
                if (webView != null) {
                    webView.loadUrl(filePath);
                }
            }
        });
    }

    public static void stopLoading(final int index) {
        sCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxWebView webView = webViews.get(index);
                if (webView != null) {
                    webView.stopLoading();
                }
            }
        });

    }

    public static void reload(final int index) {
        sCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxWebView webView = webViews.get(index);
                if (webView != null) {
                    webView.reload();
                }
            }
        });
    }

    public static <T> T callInMainThread(Callable<T> call) throws ExecutionException, InterruptedException {
        FutureTask<T> task = new FutureTask<T>(call);
        sHandler.post(task);
        return task.get();
    }

    public static boolean canGoBack(final int index) {
        Callable<Boolean> callable = new Callable<Boolean>() {
            @Override
            public Boolean call() throws Exception {
                Cocos2dxWebView webView = webViews.get(index);
                return webView != null && webView.canGoBack();
            }
        };
        try {
            return callInMainThread(callable);
        } catch (ExecutionException e) {
            return false;
        } catch (InterruptedException e) {
            return false;
        }
    }

    public static boolean canGoForward(final int index) {
        Callable<Boolean> callable = new Callable<Boolean>() {
            @Override
            public Boolean call() throws Exception {
                Cocos2dxWebView webView = webViews.get(index);
                return webView != null && webView.canGoForward();
            }
        };
        try {
            return callInMainThread(callable);
        } catch (ExecutionException e) {
            return false;
        } catch (InterruptedException e) {
            return false;
        }
    }

    public static void goBack(final int index) {
        sCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxWebView webView = webViews.get(index);
                if (webView != null) {
                    webView.goBack();
                }
            }
        });
    }

    public static void goForward(final int index) {
        sCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxWebView webView = webViews.get(index);
                if (webView != null) {
                    webView.goForward();
                }
            }
        });
    }

    public static void evaluateJS(final int index, final String js) {
        sCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxWebView webView = webViews.get(index);
                if (webView != null) {
                    webView.loadUrl("javascript:" + js);
                }
            }
        });
    }

    public static void setScalesPageToFit(final int index, final boolean scalesPageToFit) {
        sCocos2dxActivity.runOnUiThread(new Runnable() {
            @Override
            public void run() {
                Cocos2dxWebView webView = webViews.get(index);
                if (webView != null) {
                    webView.setScalesPageToFit(scalesPageToFit);
                }
            }
        });
    }
}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/GameControllerAdapter.java #-}
package org.cocos2dx.lib;

import java.util.ArrayList;

public class GameControllerAdapter {
    private static ArrayList<Runnable> sRunnableFrameStartList = null;
    
    public static void addRunnableToFrameStartList(Runnable runnable) {
        if (sRunnableFrameStartList == null)
            sRunnableFrameStartList = new ArrayList<Runnable>();
        sRunnableFrameStartList.add(runnable);
    }

    public static void removeRunnableFromFrameStartList(Runnable runnable) {
        if (sRunnableFrameStartList != null)
            sRunnableFrameStartList.remove(runnable);
    }

    public static void onDrawFrameStart() {
        if (sRunnableFrameStartList != null)
        {
            int size = sRunnableFrameStartList.size();
            for (int i = 0; i < size; ++i) {
                sRunnableFrameStartList.get(i).run();
            }
        }
    }
    
    public static void onConnected(final String vendorName, final int controller)
    {
        Cocos2dxHelper.runOnGLThread(new Runnable() {

            @Override
            public void run() {
                nativeControllerConnected(vendorName, controller);
            }   
        });
    }
    
    public static void onDisconnected(final String vendorName, final int controller)
    {
        Cocos2dxHelper.runOnGLThread(new Runnable() {

            @Override
            public void run() {
                nativeControllerDisconnected(vendorName, controller);
            }   
        });
    }
    
    public static void onButtonEvent(final String vendorName, final int controller, final int button, final boolean isPressed, final float value, final boolean isAnalog)
    {
        Cocos2dxHelper.runOnGLThread(new Runnable() {

            @Override
            public void run() {
                nativeControllerButtonEvent(vendorName, controller, button, isPressed, value, isAnalog);
            }   
        });
    }
    
    public static void onAxisEvent(final String vendorName, final int controller, final int axisID, final float value, final boolean isAnalog)
    {
        Cocos2dxHelper.runOnGLThread(new Runnable() {

            @Override
            public void run() {
                nativeControllerAxisEvent(vendorName, controller, axisID, value, isAnalog);
            }   
        });
    }
    
    private static native void nativeControllerConnected(final String vendorName, final int controller);
    private static native void nativeControllerDisconnected(final String vendorName, final int controller);
    private static native void nativeControllerButtonEvent(final String vendorName, final int controller, final int button, final boolean isPressed, final float value, final boolean isAnalog);
    private static native void nativeControllerAxisEvent(final String vendorName, final int controller, final int axisID, final float value, final boolean isAnalog);
}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/GameControllerDelegate.java #-}
package org.cocos2dx.lib;

import android.content.Context;
import android.view.KeyEvent;
import android.view.MotionEvent;

public interface GameControllerDelegate {

    static final int KEY_BASE = 1000;
    
    public static final int THUMBSTICK_LEFT_X = KEY_BASE;
    public static final int THUMBSTICK_LEFT_Y = KEY_BASE + 1;
    public static final int THUMBSTICK_RIGHT_X = KEY_BASE + 2;
    public static final int THUMBSTICK_RIGHT_Y = KEY_BASE + 3;
    
    public static final int BUTTON_A = KEY_BASE + 4;
    public static final int BUTTON_B = KEY_BASE + 5;
    public static final int BUTTON_C = KEY_BASE + 6;
    public static final int BUTTON_X = KEY_BASE + 7;
    public static final int BUTTON_Y = KEY_BASE + 8;
    public static final int BUTTON_Z = KEY_BASE + 9;
    
    public static final int BUTTON_DPAD_UP = KEY_BASE + 10;
    public static final int BUTTON_DPAD_DOWN = KEY_BASE + 11;
    public static final int BUTTON_DPAD_LEFT = KEY_BASE + 12;
    public static final int BUTTON_DPAD_RIGHT = KEY_BASE + 13;
    public static final int BUTTON_DPAD_CENTER = KEY_BASE + 14;
    
    public static final int BUTTON_LEFT_SHOULDER = KEY_BASE + 15;
    public static final int BUTTON_RIGHT_SHOULDER = KEY_BASE + 16;
    public static final int BUTTON_LEFT_TRIGGER = KEY_BASE + 17;
    public static final int BUTTON_RIGHT_TRIGGER = KEY_BASE + 18;
    
    public static final int BUTTON_LEFT_THUMBSTICK = KEY_BASE + 19;
    public static final int BUTTON_RIGHT_THUMBSTICK = KEY_BASE + 20;
    
    public static final int BUTTON_START = KEY_BASE + 21;
    public static final int BUTTON_SELECT = KEY_BASE + 22;  
    
    void onCreate(Context context);
    void onPause();
    void onResume();
    void onDestroy();
    
    boolean dispatchKeyEvent(KeyEvent event);
    boolean dispatchGenericMotionEvent(MotionEvent event);
    
    void setControllerEventListener(ControllerEventListener listener);
    
    public interface ControllerEventListener {
        void onButtonEvent(String vendorName, int controller, int button, boolean isPressed, float value, boolean isAnalog);
        void onAxisEvent(String vendorName, int controller, int axisID, float value, boolean isAnalog);
        
        void onConnected(String vendorName, int controller);
        void onDisconnected(String vendorName, int controller);
    }
}
{-# START_FILE proj.android-studio/app/src/org/cocos2dx/lib/GameControllerUtils.java #-}
package org.cocos2dx.lib;

import java.io.File;
import java.io.FileInputStream;

public class GameControllerUtils {

    public static void ensureDirectoryExist(String path){
        
        File sdkDir = new File(path);
        if(!sdkDir.exists()){
            sdkDir.mkdirs();
        }
    }
    
    public static String readJsonFile(String filePath) {

        File file = new File(filePath);     
        
        if (!file.exists()){
            return null;
        }
        
        try {

            FileInputStream is = new FileInputStream(file);;

            int size = is.available();
            byte[] buffer = new byte[size];

            is.read(buffer);
            is.close();

            String jsonstr = new String(buffer, "UTF-8");

            return jsonstr;
        } catch (Exception e) {
            e.printStackTrace();
        }

        return null;
    }
}
{-# START_FILE proj.android-studio/build-cfg.json #-}
{
    "ndk_module_path" :[
        "${COCOS_FRAMEWORKS}/cocos2d-x-3.9",
        "${COCOS_FRAMEWORKS}/cocos2d-x-3.9/cocos",
        "${COCOS_FRAMEWORKS}/cocos2d-x-3.9/external"
    ],
    "copy_resources": [
        {
            "from": "../Resources",
            "to": ""
        }
    ]
}
{-# START_FILE proj.android-studio/build.gradle #-}
// Top-level build file where you can add configuration options common to all sub-projects/modules.
buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath 'com.android.tools.build:gradle:2.2.3'
    }
}

allprojects {
    repositories {
        jcenter()
    }
}
{-# START_FILE proj.android-studio/gradlew #-}
#!/usr/bin/env bash

##############################################################################
##
##  Gradle start up script for UN*X
##
##############################################################################

# Add default JVM options here. You can also use JAVA_OPTS and GRADLE_OPTS to pass JVM options to this script.
DEFAULT_JVM_OPTS=""

APP_NAME="Gradle"
APP_BASE_NAME=`basename "$0"`

# Use the maximum available, or set MAX_FD != -1 to use that value.
MAX_FD="maximum"

warn ( ) {
    echo "$*"
}

die ( ) {
    echo
    echo "$*"
    echo
    exit 1
}

# OS specific support (must be 'true' or 'false').
cygwin=false
msys=false
darwin=false
case "`uname`" in
  CYGWIN* )
    cygwin=true
    ;;
  Darwin* )
    darwin=true
    ;;
  MINGW* )
    msys=true
    ;;
esac

# Attempt to set APP_HOME
# Resolve links: $0 may be a link
PRG="$0"
# Need this for relative symlinks.
while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
        PRG="$link"
    else
        PRG=`dirname "$PRG"`"/$link"
    fi
done
SAVED="`pwd`"
cd "`dirname \"$PRG\"`/" >/dev/null
APP_HOME="`pwd -P`"
cd "$SAVED" >/dev/null

CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar

# Determine the Java command to use to start the JVM.
if [ -n "$JAVA_HOME" ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
        # IBM's JDK on AIX uses strange locations for the executables
        JAVACMD="$JAVA_HOME/jre/sh/java"
    else
        JAVACMD="$JAVA_HOME/bin/java"
    fi
    if [ ! -x "$JAVACMD" ] ; then
        die "ERROR: JAVA_HOME is set to an invalid directory: $JAVA_HOME

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
    fi
else
    JAVACMD="java"
    which java >/dev/null 2>&1 || die "ERROR: JAVA_HOME is not set and no 'java' command could be found in your PATH.

Please set the JAVA_HOME variable in your environment to match the
location of your Java installation."
fi

# Increase the maximum file descriptors if we can.
if [ "$cygwin" = "false" -a "$darwin" = "false" ] ; then
    MAX_FD_LIMIT=`ulimit -H -n`
    if [ $? -eq 0 ] ; then
        if [ "$MAX_FD" = "maximum" -o "$MAX_FD" = "max" ] ; then
            MAX_FD="$MAX_FD_LIMIT"
        fi
        ulimit -n $MAX_FD
        if [ $? -ne 0 ] ; then
            warn "Could not set maximum file descriptor limit: $MAX_FD"
        fi
    else
        warn "Could not query maximum file descriptor limit: $MAX_FD_LIMIT"
    fi
fi

# For Darwin, add options to specify how the application appears in the dock
if $darwin; then
    GRADLE_OPTS="$GRADLE_OPTS \"-Xdock:name=$APP_NAME\" \"-Xdock:icon=$APP_HOME/media/gradle.icns\""
fi

# For Cygwin, switch paths to Windows format before running java
if $cygwin ; then
    APP_HOME=`cygpath --path --mixed "$APP_HOME"`
    CLASSPATH=`cygpath --path --mixed "$CLASSPATH"`
    JAVACMD=`cygpath --unix "$JAVACMD"`

    # We build the pattern for arguments to be converted via cygpath
    ROOTDIRSRAW=`find -L / -maxdepth 1 -mindepth 1 -type d 2>/dev/null`
    SEP=""
    for dir in $ROOTDIRSRAW ; do
        ROOTDIRS="$ROOTDIRS$SEP$dir"
        SEP="|"
    done
    OURCYGPATTERN="(^($ROOTDIRS))"
    # Add a user-defined pattern to the cygpath arguments
    if [ "$GRADLE_CYGPATTERN" != "" ] ; then
        OURCYGPATTERN="$OURCYGPATTERN|($GRADLE_CYGPATTERN)"
    fi
    # Now convert the arguments - kludge to limit ourselves to /bin/sh
    i=0
    for arg in "$@" ; do
        CHECK=`echo "$arg"|egrep -c "$OURCYGPATTERN" -`
        CHECK2=`echo "$arg"|egrep -c "^-"`                                 ### Determine if an option

        if [ $CHECK -ne 0 ] && [ $CHECK2 -eq 0 ] ; then                    ### Added a condition
            eval `echo args$i`=`cygpath --path --ignore --mixed "$arg"`
        else
            eval `echo args$i`="\"$arg\""
        fi
        i=$((i+1))
    done
    case $i in
        (0) set -- ;;
        (1) set -- "$args0" ;;
        (2) set -- "$args0" "$args1" ;;
        (3) set -- "$args0" "$args1" "$args2" ;;
        (4) set -- "$args0" "$args1" "$args2" "$args3" ;;
        (5) set -- "$args0" "$args1" "$args2" "$args3" "$args4" ;;
        (6) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" ;;
        (7) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" ;;
        (8) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" ;;
        (9) set -- "$args0" "$args1" "$args2" "$args3" "$args4" "$args5" "$args6" "$args7" "$args8" ;;
    esac
fi

# Split up the JVM_OPTS And GRADLE_OPTS values into an array, following the shell quoting and substitution rules
function splitJvmOpts() {
    JVM_OPTS=("$@")
}
eval splitJvmOpts $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS
JVM_OPTS[${#JVM_OPTS[*]}]="-Dorg.gradle.appname=$APP_BASE_NAME"

exec "$JAVACMD" "${JVM_OPTS[@]}" -classpath "$CLASSPATH" org.gradle.wrapper.GradleWrapperMain "$@"
{-# START_FILE proj.android-studio/settings.gradle #-}
include ':libcocos2dx'
project(':libcocos2dx').projectDir = new File(settingsDir, '/Applications/Cocos/frameworks/cocos2d-x-3.9/cocos/platform/android/libcocos2dx')
include ':app'
{-# START_FILE proj.android-studio/gradle/wrapper/gradle-wrapper.properties #-}
#Sat Aug 12 10:33:54 BST 2017
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-3.3-all.zip
{-# START_FILE stack.yaml #-}
resolver: lts-8.5

# TODO: we should update the docker image to use more updated version of cocos2d-hs (now with master and android in the same branch)
packages:
- '.'
- location:
    git: https://github.com/lynnard/Hipmunk
    commit: c489b6f416866fb22e2aaa467ffa666b007faa27
  extra-dep: true
- location:
    git: https://github.com/reflex-frp/reflex
    commit: c617057bc4b9f6b75e4f4ebe2a4f2f818bd7d1a0
  extra-dep: true
- location:
    git: https://github.com/khumba/hoppy
    commit: 0c4d1086d9ddd5508395c1553f8f1ff94e27b50a
  subdirs: # we have to pull generator & std from git as the versions on hackage have some problem
    - generator
    - std
  extra-dep: true
- location:
    git: https://github.com/lynnard/cocos2d-hs
    commit: 5946b09e87636039bcbd30b96b02df1d446b954e
  extra-dep: true
- location:
    git: https://github.com/lynnard/reflex-cocos2d
    commit: a69f5c1e2afe66cc9365c0eb9334e525f7f8b421
  extra-dep: true

extra-deps:
# TODO: check if these are actually needed?
- directory-1.2.7.1
- haskell-src-exts-1.17.1
- haskell-src-meta-0.6.0.14
- hlint-1.9.35
- prim-uniq-0.1.0.1
- ref-tf-0.4.0.1
- hoppy-runtime-0.3.0
- hoppy-std-0.3.0

flags:
    reflex:
        specialize-to-spidertimeline-global: true

extra-package-dbs: []
{-# START_FILE .dockerignore #-}
# ignore files except those for android build
*
# haskell files
!hs-src
!*.cabal
!Makefile
!Dockerfile*
!*.hs
# the dist directory is like cabal's cache and can speed up build
!dist
# need these for ndk build
!Classes
!include
# android-studio project files
!proj.android-studio/app
proj.android-studio/app/build
proj.android-studio/app/obj
proj.android-studio/**/*.so
!proj.android-studio/build-cfg.json
{-# START_FILE .gitignore #-}
dist
dist-*
*.o
*.hi
*.chi
*.chs.h
*.dyn_o
*.dyn_hi
.cabal-sanbox/
cabal.sandbox.config
.stack-work/
*.a
*.so
/bin/
*.mp4
.DS_Store
*.o.d
/proj.android-studio/**/build/
/proj.android-studio/**/local.properties
/proj.android-studio/.idea/
/proj.android-studio/.gradle/
/proj.android-studio/**/*.iml
/proj.android-studio/**/gdb.setup
# ignore the assets
/proj.android-studio/app/assets/
{-# START_FILE BASE64 proj.android-studio/app/jars/android-async-http-1.4.8.jar #-}
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ZW50JDMuY2xhc3NQSwECFAMKAAAICAB7o/FGGC1lwfMBAABnAwAALgAAAAAAAAAAAAAApIEtDgAAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9Bc3luY0h0dHBDbGllbnQkNC5jbGFzc1BLAQIUAwoAAAgIAHuj8UaA26euKAMAACsGAAA8AAAAAAAAAAAAAACkgWwQAABjb20vbG9vcGovYW5kcm9pZC9odHRwL0FzeW5jSHR0cENsaWVudCRJbmZsYXRpbmdFbnRpdHkuY2xhc3NQSwECFAMKAAAICAB7o/FGRl54R/ctAADHfQAALAAAAAAAAAAAAAAApIHuEwAAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9Bc3luY0h0dHBDbGllbnQuY2xhc3NQSwECFAMKAAAICAB8o/FGL5X5FPYKAABNGAAALQAAAAAAAAAAAAAApIEvQgAAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9Bc3luY0h0dHBSZXF1ZXN0LmNsYXNzUEsBAhQDCgAACAgAfKPxRmdNH6eaAQAAcwMAAEYAAAAAAAAAAAAAAKSBcE0AAGNvbS9sb29wai9hbmRyb2lkL2h0dHAvQXN5bmNIdHRwUmVzcG9uc2VIYW5kbGVyJFJlc3BvbmRlckhhbmRsZXIuY2xhc3NQSwECFAMKAAAICAB8o/FGDLlIeFkUAADuKwAANQAAAAAAAAAAAAAApIFuTwAAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9Bc3luY0h0dHBSZXNwb25zZUhhbmRsZXIuY2xhc3NQSwECFAMKAAAICAB8o/FG+UljWT8BAADaAQAAKQAAAAAAAAAAAAAApIEaZAAAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9CYXNlNjQkQ29kZXIuY2xhc3NQSwECFAMKAAAICAB8o/FGgCKHKlUIAABmFAAAKwAAAAAAAAAAAAAApIGgZQAAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9CYXNlNjQkRGVjb2Rlci5jbGFzc1BLAQIUAwoAAAgIAHyj8UZ9sPMOXQcAAFEOAAArAAAAAAAAAAAAAACkgT5uAABjb20vbG9vcGovYW5kcm9pZC9odHRwL0Jhc2U2NCRFbmNvZGVyLmNsYXNzUEsBAhQDCgAACAgAfKPxRtNarQn+BQAAGgsAACMAAAAAAAAAAAAAAKSB5HUAAGNvbS9sb29wai9hbmRyb2lkL2h0dHAvQmFzZTY0LmNsYXNzUEsBAhQDCgAACAgAfKPxRi7wcTAJAQAAkQEAADAAAAAAAAAAAAAAAKSBI3wAAGNvbS9sb29wai9hbmRyb2lkL2h0dHAvQmFzZTY0RGF0YUV4Y2VwdGlvbi5jbGFzc1BLAQIUAwoAAAgIAHyj8UY95U3NlgUAAKMKAAAvAAAAAAAAAAAAAACkgXp9AABjb20vbG9vcGovYW5kcm9pZC9odHRwL0Jhc2U2NE91dHB1dFN0cmVhbS5jbGFzc1BLAQIUAwoAAAgIAHyj8UahGZmcOwIAAPoEAAA8AAAAAAAAAAAAAACkgV2DAABjb20vbG9vcGovYW5kcm9pZC9odHRwL0Jhc2VKc29uSHR0cFJlc3BvbnNlSGFuZGxlciQxJDEuY2xhc3NQSwECFAMKAAAICAB8o/FG1klHj0gCAAALBQAAPAAAAAAAAAAAAAAApIHyhQAAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9CYXNlSnNvbkh0dHBSZXNwb25zZUhhbmRsZXIkMSQyLmNsYXNzUEsBAhQDCgAACAgAfKPxRp7Ca+tvAwAA7gcAADoAAAAAAAAAAAAAAKSBlIgAAGNvbS9sb29wai9hbmRyb2lkL2h0dHAvQmFzZUpzb25IdHRwUmVzcG9uc2VIYW5kbGVyJDEuY2xhc3NQSwECFAMKAAAICAB8o/FGMzjjI1oCAABIBQAAPAAAAAAAAAAAAAAApIFbjAAAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9CYXNlSnNvbkh0dHBSZXNwb25zZUhhbmRsZXIkMiQxLmNsYXNzUEsBAhQDCgAACAgAfKPxRkJP7P0+AgAA9AQAADwAAAAAAAAAAAAAAKSBD48AAGNvbS9sb29wai9hbmRyb2lkL2h0dHAvQmFzZUpzb25IdHRwUmVzcG9uc2VIYW5kbGVyJDIkMi5jbGFzc1BLAQIUAwoAAAgIAHyj8UZARbPuiAMAACoIAAA6AAAAAAAAAAAAAACkgaeRAABjb20vbG9vcGovYW5kcm9pZC9odHRwL0Jhc2VKc29uSHR0cFJlc3BvbnNlSGFuZGxlciQyLmNsYXNzUEsBAhQDCgAACAgAfKPxRleoe2FaBAAA3AoAADgAAAAAAAAAAAAAAKSBh5UAAGNvbS9sb29wai9hbmRyb2lkL2h0dHAvQmFzZUpzb25IdHRwUmVzcG9uc2VIYW5kbGVyLmNsYXNzUEsBAhQDCgAACAgAfKPxRvC2eKrQBgAAOA4AADYAAAAAAAAAAAAAAKSBN5oAAGNvbS9sb29wai9hbmRyb2lkL2h0dHAvQmluYXJ5SHR0cFJlc3BvbnNlSGFuZGxlci5jbGFzc1BLAQIUAwoAAAgIAHyj8UY5mcZ4lwIAALkGAAA5AAAAAAAAAAAAAACkgVuhAABjb20vbG9vcGovYW5kcm9pZC9odHRwL0JsYWNraG9sZUh0dHBSZXNwb25zZUhhbmRsZXIuY2xhc3NQSwECFAMKAAAICAB8o/FGy1nCO3gBAABDAgAAKAAAAAAAAAAAAAAApIFJpAAAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9CdWlsZENvbmZpZy5jbGFzc1BLAQIUAwoAAAgIAHyj8UY6A9uN1wgAAPcPAAA5AAAAAAAAAAAAAACkgQemAABjb20vbG9vcGovYW5kcm9pZC9odHRwL0RhdGFBc3luY0h0dHBSZXNwb25zZUhhbmRsZXIuY2xhc3NQSwECFAMKAAAICAB8o/FGxDAMOKcLAAA0FwAAOQAAAAAAAAAAAAAApIE1rwAAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9GaWxlQXN5bmNIdHRwUmVzcG9uc2VIYW5kbGVyLmNsYXNzUEsBAhQDCgAACAgAfKPxRm6ViVHtAQAAVgMAACcAAAAAAAAAAAAAAKSBM7sAAGNvbS9sb29wai9hbmRyb2lkL2h0dHAvSHR0cERlbGV0ZS5jbGFzc1BLAQIUAwoAAAgIAHyj8Uaawqo/5wEAAEoDAAAkAAAAAAAAAAAAAACkgWW9AABjb20vbG9vcGovYW5kcm9pZC9odHRwL0h0dHBHZXQuY2xhc3NQSwECFAMKAAAICAB8o/FGeBh4VO0BAABSAwAAJgAAAAAAAAAAAAAApIGOvwAAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9IdHRwUGF0Y2guY2xhc3NQSwECFAMKAAAICAB8o/FGf/BIhvcDAADaCAAAOAAAAAAAAAAAAAAApIG/wQAAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9Kc29uSHR0cFJlc3BvbnNlSGFuZGxlciQxJDEuY2xhc3NQSwECFAMKAAAICAB8o/FG/s1EWjACAACHBAAAOAAAAAAAAAAAAAAApIEMxgAAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9Kc29uSHR0cFJlc3BvbnNlSGFuZGxlciQxJDIuY2xhc3NQSwECFAMKAAAICAB8o/FGR6tac9ECAAAUBgAANgAAAAAAAAAAAAAApIGSyAAAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9Kc29uSHR0cFJlc3BvbnNlSGFuZGxlciQxLmNsYXNzUEsBAhQDCgAACAgAfKPxRok2Ave3AwAARwgAADgAAAAAAAAAAAAAAKSBt8sAAGNvbS9sb29wai9hbmRyb2lkL2h0dHAvSnNvbkh0dHBSZXNwb25zZUhhbmRsZXIkMiQxLmNsYXNzUEsBAhQDCgAACAgAfKPxRtPxb+wvAgAAhwQAADgAAAAAAAAAAAAAAKSBxM8AAGNvbS9sb29wai9hbmRyb2lkL2h0dHAvSnNvbkh0dHBSZXNwb25zZUhhbmRsZXIkMiQyLmNsYXNzUEsBAhQDCgAACAgAfKPxRsqSpkf3AgAAfgYAADYAAAAAAAAAAAAAAKSBSdIAAGNvbS9sb29wai9hbmRyb2lkL2h0dHAvSnNvbkh0dHBSZXNwb25zZUhhbmRsZXIkMi5jbGFzc1BLAQIUAwoAAAgIAHyj8Ub/SD/ulwgAAK4VAAA0AAAAAAAAAAAAAACkgZTVAABjb20vbG9vcGovYW5kcm9pZC9odHRwL0pzb25IdHRwUmVzcG9uc2VIYW5kbGVyLmNsYXNzUEsBAhQDCgAACAgAfKPxRo6zFnckEwAAACYAAC8AAAAAAAAAAAAAAKSBfd4AAGNvbS9sb29wai9hbmRyb2lkL2h0dHAvSnNvblN0cmVhbWVyRW50aXR5LmNsYXNzUEsBAhQDCgAACAgAfKPxRtQFgOyTAAAAsQAAAC8AAAAAAAAAAAAAAKSB7vEAAGNvbS9sb29wai9hbmRyb2lkL2h0dHAvSnNvblZhbHVlSW50ZXJmYWNlLmNsYXNzUEsBAhQDCgAACAgAfKPxRiEGl2E/BQAAjA0AACcAAAAAAAAAAAAAAKSBzvIAAGNvbS9sb29wai9hbmRyb2lkL2h0dHAvTG9nSGFuZGxlci5jbGFzc1BLAQIUAwoAAAgIAHyj8UazvFmwfwEAAMMCAAApAAAAAAAAAAAAAACkgVL4AABjb20vbG9vcGovYW5kcm9pZC9odHRwL0xvZ0ludGVyZmFjZS5jbGFzc1BLAQIUAwoAAAgIAHyj8Uah889sdwkAAH8TAAAuAAAAAAAAAAAAAACkgRj6AABjb20vbG9vcGovYW5kcm9pZC9odHRwL015UmVkaXJlY3RIYW5kbGVyLmNsYXNzUEsBAhQDCgAACAgAfKPxRohh9rIwAgAAnQQAADEAAAAAAAAAAAAAAKSB2wMBAGNvbS9sb29wai9hbmRyb2lkL2h0dHAvTXlTU0xTb2NrZXRGYWN0b3J5JDEuY2xhc3NQSwECFAMKAAAICAB8o/FGe6Wp+iUKAACLFwAALwAAAAAAAAAAAAAApIFaBgEAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9NeVNTTFNvY2tldEZhY3RvcnkuY2xhc3NQSwECFAMKAAAICAB8o/FG4LladksOAACAHgAAMgAAAAAAAAAAAAAApIHMEAEAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9QZXJzaXN0ZW50Q29va2llU3RvcmUuY2xhc3NQSwECFAMKAAAICAB8o/FGyZZgmr8DAABqCAAASgAAAAAAAAAAAAAApIFnHwEAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9QcmVlbXB0aXZlQXV0aG9yaXphdGlvbkh0dHBSZXF1ZXN0SW50ZXJjZXB0b3IuY2xhc3NQSwECFAMKAAAICAB8o/FGTHN3PNMHAADnDwAAPgAAAAAAAAAAAAAApIGOIwEAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9SYW5nZUZpbGVBc3luY0h0dHBSZXNwb25zZUhhbmRsZXIuY2xhc3NQSwECFAMKAAAICAB8o/FG0fN5DtkBAACBAwAALAAAAAAAAAAAAAAApIG9KwEAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9SZXF1ZXN0SGFuZGxlJDEuY2xhc3NQSwECFAMKAAAICAB8o/FGvikTWikEAADdCAAAKgAAAAAAAAAAAAAApIHgLQEAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9SZXF1ZXN0SGFuZGxlLmNsYXNzUEsBAhQDCgAACAgAfKPxRppuK0ShAQAA2AIAACwAAAAAAAAAAAAAAKSBUTIBAGNvbS9sb29wai9hbmRyb2lkL2h0dHAvUmVxdWVzdFBhcmFtcyQxLmNsYXNzUEsBAhQDCgAACAgAfKPxRrUdf9yiAQAAuAIAADYAAAAAAAAAAAAAAKSBPDQBAGNvbS9sb29wai9hbmRyb2lkL2h0dHAvUmVxdWVzdFBhcmFtcyRGaWxlV3JhcHBlci5jbGFzc1BLAQIUAwoAAAgIAHyj8UZRvnAhTgIAAHwEAAA4AAAAAAAAAAAAAACkgTI2AQBjb20vbG9vcGovYW5kcm9pZC9odHRwL1JlcXVlc3RQYXJhbXMkU3RyZWFtV3JhcHBlci5jbGFzc1BLAQIUAwoAAAgIAHyj8UZlb/uQCxkAAGg+AAAqAAAAAAAAAAAAAACkgdY4AQBjb20vbG9vcGovYW5kcm9pZC9odHRwL1JlcXVlc3RQYXJhbXMuY2xhc3NQSwECFAMKAAAICAB8o/FGlFICkAoCAAByBAAANQAAAAAAAAAAAAAApIEpUgEAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9SZXNwb25zZUhhbmRsZXJJbnRlcmZhY2UuY2xhc3NQSwECFAMKAAAICAB8o/FGAlo/HBAGAADhCwAAKQAAAAAAAAAAAAAApIGGVAEAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9SZXRyeUhhbmRsZXIuY2xhc3NQSwECFAMKAAAICAB8o/FGU0Nkb8UGAABbDwAAOAAAAAAAAAAAAAAApIHdWgEAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9TYXhBc3luY0h0dHBSZXNwb25zZUhhbmRsZXIuY2xhc3NQSwECFAMKAAAICAB8o/FGo39bUoMEAABECQAALwAAAAAAAAAAAAAApIH4YQEAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9TZXJpYWxpemFibGVDb29raWUuY2xhc3NQSwECFAMKAAAICAB8o/FGrOIH2i0GAABUDQAAOwAAAAAAAAAAAAAApIHIZgEAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9TaW1wbGVNdWx0aXBhcnRFbnRpdHkkRmlsZVBhcnQuY2xhc3NQSwECFAMKAAAICAB8o/FGTQxEcNoOAAAUIQAAMgAAAAAAAAAAAAAApIFObQEAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9TaW1wbGVNdWx0aXBhcnRFbnRpdHkuY2xhc3NQSwECFAMKAAAICAB8o/FGFDbVg5MDAABWCQAAKwAAAAAAAAAAAAAApIF4fAEAY29tL2xvb3BqL2FuZHJvaWQvaHR0cC9TeW5jSHR0cENsaWVudC5jbGFzc1BLAQIUAwoAAAgIAHyj8UYiHIWQ9gMAAEkIAAA0AAAAAAAAAAAAAACkgVSAAQBjb20vbG9vcGovYW5kcm9pZC9odHRwL1RleHRIdHRwUmVzcG9uc2VIYW5kbGVyLmNsYXNzUEsBAhQDCgAACAgAfKPxRmAIg+lzAgAAeQQAACIAAAAAAAAAAAAAAKSBnIQBAGNvbS9sb29wai9hbmRyb2lkL2h0dHAvVXRpbHMuY2xhc3NQSwUGAAAAAEQARACuGAAAT4cBAAAA
{-# START_FILE BASE64 proj.android-studio/app/res/drawable-hdpi/icon.png #-}
iVBORw0KGgoAAAANSUhEUgAAAEgAAABICAYAAABV7bNHAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKT2lDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVNnVFPpFj333vRCS4iAlEtvUhUIIFJCi4AUkSYqIQkQSoghodkVUcERRUUEG8igiAOOjoCMFVEsDIoK2AfkIaKOg6OIisr74Xuja9a89+bN/rXXPues852zzwfACAyWSDNRNYAMqUIeEeCDx8TG4eQuQIEKJHAAEAizZCFz/SMBAPh+PDwrIsAHvgABeNMLCADATZvAMByH/w/qQplcAYCEAcB0kThLCIAUAEB6jkKmAEBGAYCdmCZTAKAEAGDLY2LjAFAtAGAnf+bTAICd+Jl7AQBblCEVAaCRACATZYhEAGg7AKzPVopFAFgwABRmS8Q5ANgtADBJV2ZIALC3AMDOEAuyAAgMADBRiIUpAAR7AGDIIyN4AISZABRG8lc88SuuEOcqAAB4mbI8uSQ5RYFbCC1xB1dXLh4ozkkXKxQ2YQJhmkAuwnmZGTKBNA/g88wAAKCRFRHgg/P9eM4Ors7ONo62Dl8t6r8G/yJiYuP+5c+rcEAAAOF0ftH+LC+zGoA7BoBt/qIl7gRoXgugdfeLZrIPQLUAoOnaV/Nw+H48PEWhkLnZ2eXk5NhKxEJbYcpXff5nwl/AV/1s+X48/Pf14L7iJIEyXYFHBPjgwsz0TKUcz5IJhGLc5o9H/LcL//wd0yLESWK5WCoU41EScY5EmozzMqUiiUKSKcUl0v9k4t8s+wM+3zUAsGo+AXuRLahdYwP2SycQWHTA4vcAAPK7b8HUKAgDgGiD4c93/+8//UegJQCAZkmScQAAXkQkLlTKsz/HCAAARKCBKrBBG/TBGCzABhzBBdzBC/xgNoRCJMTCQhBCCmSAHHJgKayCQiiGzbAdKmAv1EAdNMBRaIaTcA4uwlW4Dj1wD/phCJ7BKLyBCQRByAgTYSHaiAFiilgjjggXmYX4IcFIBBKLJCDJiBRRIkuRNUgxUopUIFVIHfI9cgI5h1xGupE7yAAygvyGvEcxlIGyUT3UDLVDuag3GoRGogvQZHQxmo8WoJvQcrQaPYw2oefQq2gP2o8+Q8cwwOgYBzPEbDAuxsNCsTgsCZNjy7EirAyrxhqwVqwDu4n1Y8+xdwQSgUXACTYEd0IgYR5BSFhMWE7YSKggHCQ0EdoJNwkDhFHCJyKTqEu0JroR+cQYYjIxh1hILCPWEo8TLxB7iEPENyQSiUMyJ7mQAkmxpFTSEtJG0m5SI+ksqZs0SBojk8naZGuyBzmULCAryIXkneTD5DPkG+Qh8lsKnWJAcaT4U+IoUspqShnlEOU05QZlmDJBVaOaUt2ooVQRNY9aQq2htlKvUYeoEzR1mjnNgxZJS6WtopXTGmgXaPdpr+h0uhHdlR5Ol9BX0svpR+iX6AP0dwwNhhWDx4hnKBmbGAcYZxl3GK+YTKYZ04sZx1QwNzHrmOeZD5lvVVgqtip8FZHKCpVKlSaVGyovVKmqpqreqgtV81XLVI+pXlN9rkZVM1PjqQnUlqtVqp1Q61MbU2epO6iHqmeob1Q/pH5Z/YkGWcNMw09DpFGgsV/jvMYgC2MZs3gsIWsNq4Z1gTXEJrHN2Xx2KruY/R27iz2qqaE5QzNKM1ezUvOUZj8H45hx+Jx0TgnnKKeX836K3hTvKeIpG6Y0TLkxZVxrqpaXllirSKtRq0frvTau7aedpr1Fu1n7gQ5Bx0onXCdHZ4/OBZ3nU9lT3acKpxZNPTr1ri6qa6UbobtEd79up+6Ynr5egJ5Mb6feeb3n+hx9L/1U/W36p/VHDFgGswwkBtsMzhg8xTVxbzwdL8fb8VFDXcNAQ6VhlWGX4YSRudE8o9VGjUYPjGnGXOMk423GbcajJgYmISZLTepN7ppSTbmmKaY7TDtMx83MzaLN1pk1mz0x1zLnm+eb15vft2BaeFostqi2uGVJsuRaplnutrxuhVo5WaVYVVpds0atna0l1rutu6cRp7lOk06rntZnw7Dxtsm2qbcZsOXYBtuutm22fWFnYhdnt8Wuw+6TvZN9un2N/T0HDYfZDqsdWh1+c7RyFDpWOt6azpzuP33F9JbpL2dYzxDP2DPjthPLKcRpnVOb00dnF2e5c4PziIuJS4LLLpc+Lpsbxt3IveRKdPVxXeF60vWdm7Obwu2o26/uNu5p7ofcn8w0nymeWTNz0MPIQ+BR5dE/C5+VMGvfrH5PQ0+BZ7XnIy9jL5FXrdewt6V3qvdh7xc+9j5yn+M+4zw33jLeWV/MN8C3yLfLT8Nvnl+F30N/I/9k/3r/0QCngCUBZwOJgUGBWwL7+Hp8Ib+OPzrbZfay2e1BjKC5QRVBj4KtguXBrSFoyOyQrSH355jOkc5pDoVQfujW0Adh5mGLw34MJ4WHhVeGP45wiFga0TGXNXfR3ENz30T6RJZE3ptnMU85ry1KNSo+qi5qPNo3ujS6P8YuZlnM1VidWElsSxw5LiquNm5svt/87fOH4p3iC+N7F5gvyF1weaHOwvSFpxapLhIsOpZATIhOOJTwQRAqqBaMJfITdyWOCnnCHcJnIi/RNtGI2ENcKh5O8kgqTXqS7JG8NXkkxTOlLOW5hCepkLxMDUzdmzqeFpp2IG0yPTq9MYOSkZBxQqohTZO2Z+pn5mZ2y6xlhbL+xW6Lty8elQfJa7OQrAVZLQq2QqboVFoo1yoHsmdlV2a/zYnKOZarnivN7cyzytuQN5zvn//tEsIS4ZK2pYZLVy0dWOa9rGo5sjxxedsK4xUFK4ZWBqw8uIq2Km3VT6vtV5eufr0mek1rgV7ByoLBtQFr6wtVCuWFfevc1+1dT1gvWd+1YfqGnRs+FYmKrhTbF5cVf9go3HjlG4dvyr+Z3JS0qavEuWTPZtJm6ebeLZ5bDpaql+aXDm4N2dq0Dd9WtO319kXbL5fNKNu7g7ZDuaO/PLi8ZafJzs07P1SkVPRU+lQ27tLdtWHX+G7R7ht7vPY07NXbW7z3/T7JvttVAVVN1WbVZftJ+7P3P66Jqun4lvttXa1ObXHtxwPSA/0HIw6217nU1R3SPVRSj9Yr60cOxx++/p3vdy0NNg1VjZzG4iNwRHnk6fcJ3/ceDTradox7rOEH0x92HWcdL2pCmvKaRptTmvtbYlu6T8w+0dbq3nr8R9sfD5w0PFl5SvNUyWna6YLTk2fyz4ydlZ19fi753GDborZ752PO32oPb++6EHTh0kX/i+c7vDvOXPK4dPKy2+UTV7hXmq86X23qdOo8/pPTT8e7nLuarrlca7nuer21e2b36RueN87d9L158Rb/1tWeOT3dvfN6b/fF9/XfFt1+cif9zsu72Xcn7q28T7xf9EDtQdlD3YfVP1v+3Njv3H9qwHeg89HcR/cGhYPP/pH1jw9DBY+Zj8uGDYbrnjg+OTniP3L96fynQ89kzyaeF/6i/suuFxYvfvjV69fO0ZjRoZfyl5O/bXyl/erA6xmv28bCxh6+yXgzMV70VvvtwXfcdx3vo98PT+R8IH8o/2j5sfVT0Kf7kxmTk/8EA5jz/GMzLdsAAAAgY0hSTQAAeiUAAICDAAD5/wAAgOkAAHUwAADqYAAAOpgAABdvkl/FRgAAJNNJREFUeNrEnGmUZddV33/nnDu8qV7NQ89zt1pDS7YsWZbkARt5BMfGDjbGYMAycVjgZZKGrORj8jUrJvmAY0gIIAcbg8ELsLFZBoPBE5qnVqvVXV3V1TVXvXm40zknH859r6oly0iypby17nqvXq16de++e//3f//33k/s+62/QPg+0vew1o5aY+5QldJPeSOVO0XgTYLVWAw/7MPmz0IgpMzfs1hrd/3yFX9IhPRsljV1p3u/bnX/XCj1D0LJbZummDjBG55/ls2IQvALwczMB1SltF/6/hRCyB/pyRvrDiWR5QpSepi4j4n7IAQgQLzSNhKAnfWq5Sk9Fp1JN2tfsXHyaeAK4AxkdbZHVUd+Mdgz9W+9ibH9Qu3c4R/Nw4JUCKkwcUT/3KNkm2sUjl1H6VWvxSYJpt/FZunQy15ZGwkhCuGkrJQnZeAfSNe2VNZqfwa45AFlGQY/HcxN/UowO73PZhk2zX7EZ2BBWETBR3geydJl6l/4P/j7DzH5M79M8eSNiFIJPLBJ7LzsFTaSBYRS+DMT42A/puM4tln/U6r6rg/fWtg3+xvBzORphMBm2cvjxtaC5yELRTCa9je/Tvdb36D/8D+jiiXUzBxyZAwhBBj9/weRrHX3slgogJjQrc68Gn/fL/1qMDNxt6qUqlbrH2FYPfefC6kQfoAA0ivzxPMXyGqbdB/+HtHlebzJaYpHTyEKRWwcgTU5JolX1EhSKawxvomSQE387Mf/izc2elyGvrKZfll9WAgBUiLCIvHKFZILT0KzDnFEPH+ezlOPIdKYwqFjeJPTLsNlWe7/r6CRlARrQ4wpqMkP/8p/VoVwTCgFxrx8JyJyFxYSVR0jWl+h+/D3mOo0eP099zA1PsbW449Qf+IRTK+LGpvAn55FhEVI0/xvxSuF2WCtsMZqD/Ct1tg0w1qDUBKEfJlYR+5BSiG8gEwbKqUib3vb2zhw4gR//Mef5y//5E/Z/r3/TrJyhckPfYzyLbchS2V0v+du4CsF2QKEUtbDWI22WG3AmsFNdhfzo7xjFoTyEEqRrl5FXzqPbdRoZBnbm5t89GMfY+/Ro8RByNf+7Iu0v/rnZLVtZn7pE4y8/i3IYhHT6ztceuXwyKrxf/3RszLwKyj5rDtkd9zth3VZa5GlCrJQIl1ZYuMPf5van92H3VhDKI/R8XHuvOMOrjt+nMk9e+gHPptbWzQff5j+lcv4Y2MUT14Pfggmg0y/rOEmpABjsEnaUWPv++hZ6XvPayDna/alGSrHDW9kFBEW6D3xIOv/61M0v/Q5/NoWylNEcYwFbrzxRq4/dYq5iQm8QpHS/gNsb26w/ehD9C5fRJVHKBw6iiyNYI1x4P0yGUlIAdpg07Sjxn/ql87KwK8IsWMgMbCP43d5BuLFs1ylUMUyQknaD3yL9d/9FN2//iI37N/DHa+7k1K1SqfTYXx8nLk9e7ju1CnGq1VkmjI+M8PIocM0GnXWH3qA/qULqFIZf99BvNEx0Bnol8eTdnuQh9ZYrd0/swaRF5A5krvXVrjnHGSRLwDEpQI/wEpB76Hvsv67nyL+h69x+uhhfvXsb1KpVPj2d77Dnr17OXPmDIUwpN3pMDM7y2ixyPTmJm+5/XaCcgURBpz/279j/X//FlZKxt7xXlSpgm4382L35Ui5Aiyosfd+5Kzw/ApSOgC0z4qwZ0fcAJv4QSAuEGEBoSTJhSdZ+cx/pf8PX+O6Y0f5xNmzfPjnPsL5p8+zurrKe97zHu69915GRkaoVqtUq1X8MKRZr9NfXWXm0GFGjh1ndXOT2iMPE60s4U/vITx6HcLzXP32I6YAQspdGPTu3Qay3794t89v5+ecmLWIcgXpecQXn2L1d/4bva//FScO7OfXf/M/8MGf+RD1ep0HH3yQubk53vrWtzI2Nsb4+DiVSgWlFFIpVBCwvb5O1m4xvXcfo6dPs7a6yuaD9xOtrxDM7aNw/Dr3PzP9I+VwOwZKOmrsJ3/uLJ5XGcQd2JzY2114ZIfPO78H4Shu7pEuJGWhgFep0L94no0//G06f/HHHN4zy6/9+q/zoQ//HOPj41y8eJF2u80NN9zA6dOnAfA8D6XUMHMWikXiNKW+vIxMU/YdPUrxyBHWriyw/eD9JLUtwiMnCOb2IpQ3VAKEVD+0vjQwkImTjhr9iQ+fFX4O0tY+F6QF1xgq51DD3w+9RuSgPDJKurzIxhd+n+YXfp+56gi/8olP8Isf+2UmJydJ05R+v8/09DRHjhyhVCo9D6d0Rmq2WtRXVihqzaFbboGpaZYvnKf+0P3oXofw+Cm8iSmEFNhMI3z/hy7drjXQO3/2rPC8igNls3PVu8HP2p1jd8hZ4X6wBqRAFl2RufWlz1P7v59h2qb8/L0f49c++Ummp6aGH1etVpmdnaVSqQz4GO12mziOkVIOPSn0fTIhqNVqNNfWmAgC5s6cIa6MsPjoI7Qevh85Mkp4+Bje5OxQV0KIH4q/OQNpZ6DqOz/keJB8Fg/aDcp2FzB/H5VQSIn0A4TyaT/wbdbu+58Ur1zi7T/5bv79b/wGBw4eHJ6wlBLP85C7MqExhu9973s8+eST+L7P1MCYedj2+n0a7TbJxgZT09OMHD9OI9Ncuf9+oiuL+PsPUrrxVdgso/vAd0BKZKmM9PyXxLx3PCjuqOo7fuas8LwKOQ8SuwF4YBb7XLQe4pQF4Yfge2RrK6z+3v8g+97fc+drbuXf/cf/xC2vehVKqWvSsRBi+LPI7/Z9993Hpz/9abrdLnfffTee59TgIAhI0pR6o0E/jlGNBhP79lE4fJi1rW3WH/xn0nab8k23IpVg+75PgzYEew6gxsd3VMoXYyAlIctDrPq2D54VnqqQh5gYqGv5BdjcQPbZhdyQG0lkoYhuNah/5Qu0/uyzHJka5+Of/CTvfd/78DwPrTXGmGuOLMuQUiKA9fV1vvzlL/PVr/41rVaLEydOcODAgaGnCaDZatHq9UjqdYpAde9e1OHDXH38MeqPPIQVEtNu0PjLz2OThMLpmwj2H8ImiRPgXkTICSlBDzzorR84K5RyGGTsteB7DWKz40m7wTksgk7pPXo/W5/9bQqNLT788z/PL/zyv2FsdJQoisjS1BlG650jywiCgCiOeejhh7m6dJUjR46wf/9+kjRldmaG0dHRIR71ej3qtRqRMWT1OgWlGL/hBtqex+pjj9B48nGypQWSxXlMp0XppldTOHbKwcOLLEt2G8izxrhKXhpnIIk7lIABZgsB0roK3+a6kbJ5de4RLz5D6++/ilm8xKtfcyvv+cAH2Ld3L/1+nyRJAYvMw8ruylLGGFrtNusbGxw6fJh7770X3/f4x29+k4WFBaanp5mcnERgGRsdpVwq0Ysiuv0+cmWFcrXKa9/5TpYvXOCB++6j/8SDAKSrS8TPnCN77etRYxNO534pjNuCqr7l/WdRXsUBk30WERzElnUhN+BBYsd7BJbW975J40v3MeEr7v34x3nHu95FsVCgVqvhez5BEGCtJU1SZ6ScLmRpRtTvE/g+R48e5fChQ4yNjlKtVilVKgS+jzU216gE7VaLZrNJai0kCabRYOy607Q8xfLlebrLKzs0YaRK4chJwn0HsTp7UQYagnQUdzyrratcM7OLCFqsFWCliysrEZ7CClflYgzCD0BK+ksLtB/6Nl5ji1ve+Abuees9jI+NUavVkEIgpaDb7ZImKUJIpNxFM61FKcXhQ4fwAp84jknimMmpKbI0RWtNv98ntCGe9ChXKvhS0TWGxGhsu0354jOcPnMz8299O41nLpI1Ghhric4/Rv+ZJym9+g4ncFn9IkoSMczecnDBZMYZSmswGmscsGKMe631IPawA0/TmvbD3yV+6NvsnRjjJ979rzh2/DhJmhD1+0gpufD003zly1/mqaeeIgiCIUAnaUKaJVhrkVKSZRndbpdWu0OcSyDGWtIsJY5itNZUymUKhQJWa2JryaSk/8QT7A1DTtx1N3vuvJP9R44wOzGOWF2m98QjpI26K5xfEi+ySGtcJW9zozgjOWOhtQsHYzCtJnpzDRP1EEERayzp5gbdh7+DV9/gzK238eP3vBWQtFotpKdYX1/nDz/7WT7zO7/DU089RaVSxlhDmqVkWYrWGXES02q36bQ77oZg6fV6tDvOUFprkjQhTmMKhQKlcgkpBKk2pECvXidYXWGyUuLgbbdx5rbbOH3rq6koRf/pc8TzF/LUrV6YCvFsRj8AaauNE6IG4TbwKGvBQFbboPfod0mXLiFLI6A1vQtPkC5cYG60wu133cXBgwfodDskcUKapNz/wAP80ec+x4MPPUSv10UI0FqTpZk7Mo3OD2tMjnkWayxG57/TmiRJiKMYpTyKpRLK8zBZRqY1ulAgW1lGLFxmTCmOHTvGiVe9mvHZGbL1q/TPPwomdbjyErzIw2hnHKHd3w8wQuSlqDQIKTFxQu+hb5JtLlO8+S6QPt3zj8D6VY6cuZ7X3HYbJtOY1KXUKwuLfPc730EKwYH9+zHGsLy8TBCEQ17kCKNLBlZKjDVgBUY7T7LWVTPCghUGI5Uraj0frQ2Z0HhBSNRoky4tUllfZ/bIEaKxMSp792CeeIpo/gKkCbZQzIn5C8Ah19TAGotnM4uQ2oGmdICMtQ6QrUUIiVUCpEdW3yLbXKF45k7CY9cTXXgCpVOOnb6ekydP0Ww1kVLSarU599Q5Go0m9370ozkpVMzPz3Pq1HVordE6cyxdSgpBQLvT5vzT50lTzamTJ5mcnHTYY03ePxDITKGUwvPUEMtUGNJst1G9iDnPo+J5VA4cYPToMXjkEaJnniJrtfDDgrumF+9BOUibPMQGPEiIvLthnMAhJdILiJcu0vza5ynd8nrM0jz7J8e5/szNjI+Ps7KyjO/7LC9fZWNjg+PHj/PBD36Q7e0trlxZot+P6PV6pGmKMRpjDWEQ4vkeKysr/Mmf/ClRFPMLH/kIe/fuIY4j0ryAlVIiVYKnFL7ngbXoLEMrSZwkjFRH8Col0JpCGDJx4gTFsTGiq1dI11bwxifB85x29KIMNJBcHblxLr9LckW7CRih89QO9B/7Lun6MrTrnHrjXZw8eRKjM9LUYUWz2WRkpMoNNxxkdHQUz1NIqcBaWq0W1ubYZi3G80nTlPn5eb79rW/R6/d53R2v5eZbzgAWYzRZljmdR4ASEl/5CHDZMBc2C+USwhjiKCJstRg7eIDRw4fon58nWbxEePQEKhzDyvRF9dccSOfgjLF59nLvWWMwg6xmzA7ZylKy5XmUEhw4dITJySmazRZJnBJFEcVikcOHD7Fnbo7V1WXa7TaFYoEwDEnimCzLyLIMYy1GGxr1BivLq4SFAuVymeWVFS5fXiBNM4RQJGlGFEX0Ol200SglEYidzzGWLM1I4phUa7JGg8r4JCP7D4DVJFcWsFEfIV+MDOJuoGeNQWiDxThAlGDJyaHNQ8yKnB8ZFKB8jyTN8H2fyalpSuUS7U6HJHW8ZnR0FCklBkPcTxG4ExsUGkILF15hSKY1m9tbtNotbnvNaxifmGBmZobFxUXKpRLFYgmMIYkT6r0OI5WyG3iTglRnCCkwA16WqxFZp4M/MUFhfBwhIFm7iun3c/3qRWKQ1Rqbg/QAvYUr510YSGconWXoNGW8FDJ35Dhr6xtITzEzO0OlUmF1dTXnMTh5wxiSWA/1H2tB6wyttUvjxuB7PomOqW3X8DyP197+Wk6dOkWqNZ12i36vl99LF2q1Wo0kjtHWUigW6XW7+f80O8WztWSdNp5QBKUyWEO2vYGJI3d7/iUPsuyadLMOg4zQSCtcijdiB6gHfWgJNjNkacpIscBNN93EmTOSx558AqUUAoijeIhjWmuU5yGFxBjrmLFlCLbGGrTWxEmMMYYoipiYmGDfvr3s2bOHNEtpFRwd6HY7FApF/NBHSMnm1hZaG5IoyrUk93nWuM8UQNLroYQgLJURQpC1m65gHerFL5xJe2gLQue6zyDGcgJiAaFzCUQ65cAYJicnuOOOO2m1W2xtbrK2tobnefTjCCz4vodNM+KoT6vVoNPugBVUqiNUR6uEYQELpFlGmqZIJZmcnEAqRaPZQADK80mzBJ3lFy4E1hiWr16lVqshrEX5AYVikSAMh2qBtpY0jhEC/HIZGQSYXg8bJ3kxLl4wBGHBM9YgjAXhsAZhEVYODSRErjIqBZ5Ht9EniSIOHNjPjTfewNbWFk+eO8cNN95Ip9fBU47EbW+uMX/xGbY21+m0uwghGKmOMD0zw979B5ie20MoC5jMUCwU8DxHAqMocmGTyyxBGJBlGbWtbS5fvMj5J59gc3MTISAMi5QrFWb27GFichIpJTZNyZIEtEaFAbJQwER9TBrl2UsONJwXmuZzgM6B1NHNQcs5J4wIhOeBH5Kmmk67jbWWm2++mYcfepjV1TX27d2HlE5aXV66wrnHH+HKwmWMNo7cKY+o06a+tcna6grHTp7i0JFjFAtFwjDE93yEEKRpOuzmBgWX9dZWlrn49HmWl67S2N4miSKMNfT6Per1Gu1OizQ5zNTsHgSg0wyTaYTnI4OArJ9gshT7gvRpe22IWa0R6J0m4ID/2PwZAVYgpI8MSyTG0qjVaLfaTIxOcOTwETqdNq1mk5HRMZr1Gk+fO8fi/DyepxitVJGewyIn8At67TaLFy9ijeXAocP4QYjWFpNpdxFC4Hk+cRSztrrMlcuXaNW28TxJoVgkM240T0pJEsc0a9ssC4nnBYyNVtHG5EzdFalWx661/mKn+WzuQeBqIKsG6ZgdDBp4k5LIYpkUQb1eo16vMzY2ztTEJOVyCWMN3V6XpSsLbK6v4fs+Y+PjJElCvdWhH/URSIqFAmHoY5tN1leWCcICU9OzTrzU2VD+AEGr3mBt+Sr17W2iOKLbj2l2OrQ7HTzlUS4XKZZKCAHddput9TXCwKeYG8hku0ih5SU1FD2skzuMdUYRIq/JZC6YWQfgKIUolDHKo91uUavXCQuhI1Oeq1hajTrbW+v4vsL3q2zXG1yYv8zWlrtAKSWlUonpyUn2791DqVymvrVFEIQUy2VHSq1FKUscR9S2N+m0mjRaTZZWVlld36DZbBEnCb7yGKmUmZqeYmK0CsbS7bRpt9sESmG0JosidBw7aRjhvChXJ1+orTxXyZvcYwRm8MeDELOO8AkLyiuSSp8ojmm1mkxPT2ONkyNA0G23sZnG833WNjd56JFHWdvYQmfZ8HzqjSbrm5ts1WoYYxgbGyOJeviB55IETquO+12SuM/q+jqPPnmOpeUVoigetov6QKfbodluYY8cYXJ8HKkUcT8iLRYcu44idBIji6MuO+tcTvV8bJo8f7yJXSHm1EFnIIHFCkcMrXG8SCgnNQhjkMUKolAiiXo0G02yNEVKQZK4rkUax3hK0Wy1uTi/wOraBpnWz55qI4kTVlbXEBaqI1UmJqfwCyFS+fmddZX68vIKjz95jsuLS/lNuPahraXT7XF1eQVPKfbOzboiGEGUxMTtNjZO8PdM4u09iL9/L7rVR2+tOSMo6UZ6nheYcpB2TDBXYqXroNpBNgOs0JBpVHkcURqj315ifX2NJLmOIPBJ0wRjHPM2wNLKCpcXFp9jnN3d0izLuLqyyuNPnmPv3r0cKZXwQ4UTMDNqtRrnzj/NpYXFHeMMEsizDF6vNyiXS0xNTFApWYyniKI+UauF1RYRFtD1LTr/9I/EV+aRhQLFG1+NkMHO5z0Pw74WpMknqyTD5RIrgMxiZYYqjyNHJuluXGTxygKdToexsVG0zlyJIiW9fsT6+ia9fn93myAX4vJiOKfy2mgWl5a4fHmBPXv34fkBVgjSJGFpaYmL85eJ4njn5Adi1zDT2rz7bWi1OnQ6HSZGR6FQIE5cgWu1Jt3epPWVL5IuL2C1pvrO91HME5DNXF03mOF+LgbtCjEXfhIrLUIJQGKxCGOwMkUWKsjqJJERXF26yvbWFqVSyZ1rnlY73S5RFF3rMUqB77vnoaJnodMlSVNW1zfodDsUKyNIKYj7MWvr67TaLfcZhSIoL+/b5UMWabIzPw2kWUq/H4Gx2GKJXhwT9SPQGdnVBZrry5heh/Ktd1I4cSMIme+k2B3gHswf5Law1uIJa4YEyuZF6q6y3r2WApsZZBDilSdIwjLNeoP19XWmpqeRQhLrFBAkaXZtaEnphKqwCBOTyLk5h/+rqxAvYbSm3W65uz9lkELS6/dpt9sYkxfR45OIfQeQ5TJ6fR221qGXe1CaDi8GwJOSVCnWFxZoLi3hSYk0mqSf4E3NUbnzHsKDxzFJ4gytBi3j/KblMwrDz7smpo11GQ2Zj9rafCZRACnW95GVccT4LL3NBa4uXeHQ4cOMVqukaYpS4jmTG7mwjTxwkNLb3sbIm96A0Zru332Dzp9/CbN0mSiK6PZ6GJ1ilSRNEqI4xqQJjE9QeMObGHnn2wmmp+g+8DCdr36F7InHIEmG4SYESE9hfI/tlWXsxgZHS2XsyZNcuXSRJMso3Hw7pdvf6Dp/WZY3RB3WWiGG2rfwvaHC6j2HEORtHmsAafOSwxmINEWVJ/BnjhKvXeLixQucOHWK6sgIOtNI5VEdqzp+dM2umMQ/dYqxd/8EM6+/iwzYLlfoP/o49sr8cAMxzQcarHALJWQG5uaovO0eZn76/RTDgO19+4mvLpGdPw+2M/wvvudRKBYxUpE0Guz1PMT0FKtGk6YZamKa0q134+09hO51EWm6i+vlzYoBmcz0UDiU338m0Q4NNZRkM41JEoRfxp88iA1LLC1fZXHxMu2uK0azTDMxPslkXjheg0NBgPQ8pNbITCPCEOF7CKBUqVAul0mTlKgfEfg+pVLZLTxKiQgC16U11vW3fN81A+3OoFe5VGZkpIqxlqLnMTU1RWotS0tL9DND6bU/RvHETa7H1+9j8+t67rHTBkMbvN3z4t9fddwhkSQpBAVkeQI1c5Ro6QkW5+c5dOgYczMz9Po9isUihw4cZH7+MrV6fRgC6TPP0Pz6N8BYjLE0/+ZvyC5epByGTM1MMTIyQhxFxEDgB4yPjRGOjNBfXaPz9b9la3SMcHaG5ne/R3ruKcgSd9c1KCGYmJhgZGQEkyQEYUgjyZhfusL62ipqbj/l238MNTmH6XbcTZdqgCvPMYDNO8zWaDzXJ7L/4sS8y3YZZCnCLxHsPU1/7RJXFhdYWJhnemqSJEnwPMWhQwc5euwotQcedPReZ5jVFTpf+xrxE4+7VH7uKbh6hdHJcQ4dOIinfJqdFlmWMTY+xuHDh5jdM0fjmUtEf/cNarUmshiSbqyRLS5AlkK+GTk7O8fsnj1IIUmTPmmpzOLyMksXn8EGRUbufifh/mOujIrjXKMU+YzTQL0Y9OgGBrJYbXeWel+QCqA1lhSkj5o8ghzfR2PjIpcunOfA/oNUq1W6nS7lUoXbXn0r/V6PJ889BVEfVpfR9W304567uF6XSrnCna97HSePHafZbtPt9dAmQ3YUszOzvP6uO+m02ywvXiTeWIUwdMNQcQRxDMDk5CQnTp1gtFwhjSJsocBKt8vChafpdfsUb34d5Tt+HFUewUYx1mQ538k7OTafi1K7SOgw3DJUeOKuswhVecErULmQJbwCAkO6dYWoVUMFIdPT02QmQ2tDdaTK3NwMcjBn2G67aa84IkxTDh86yBvf+AZuvfVWsjRjY2uLLM8scZLgScmhgwcZqY7QbrbobG6go74zjNZURyrs2buHkydPMjE6itSGREoansfFC0+zeekS3twhxt71IQqnbnYDGXlTQbDLW4YLNwxbXigJWYbpdDsqOH7nWSG9CuKFzBfvZrQSVRrD9BpEtVWiXotypUKlUiZNMuIkYWpyiuMnjjE+Nu4GD4pFZmamOH399bzpTT/GLbe8iiRJubywSJomrpWjM+J+RLfbpTrqpmHL5Qqp0QSBT7FYZHbGjRAfP36csWqVpNsllpK277Owtsbak4+DX6D65vdSvuud7pQHvGf3Newep7M7z0JJSDNMt9vxhsPQ4kXKJUYjwjL+gZvQnW22thd55JFHKBQKTE9O0+/1udJdYnxijJOnTnHLLbcMYTAoBGRJxsrysitos4wwDHI+1EVKiV+p8swzF10DQEluv/1211nJ9elMa9qdDvW1NVShSLdUYml7m9UnH0fHKeU3vJ3S7W92Q+Zx33EeKXP8yRBS5h0cl+atFDvzmdlOJvN4SQ/rdCKrUFOH8Q+eIelssbJ8lccfe4xbbnkVUxMTNFsttja36HS6FAtFNzFmLZ1el26ni9GGwPfxPUWSJjQaDeIkZrRaxRhNvdGg3WkPh8rdQKdAW0PW65P2+6hKhc7kBMubmyw/+hBps0XxzN1UbrsHb3wWG/VcGSTlDi0YNiR2RMGd91zmtkOiOOA8L2W+SGdIv0Cw5zS23yG9+G0uXbyAAK6//gbGRkdJ0pR2y0mynvIAQa/Xo9lqYoHRapVyuUi706XVbqGUIktTavU6zVaTOC9We3GMktJlxSRBKQ87Nka7WmVtdZX1xx4lqTconH4Nldf/JP6+427NNIl3Wlh2MJyx20D2WolZgM12eJEKjr/urJB+DtIvVpJ0QpoIyqjyBGBJGhs0Ntfo9rt4noenlBuf0YY0TdHaIITrq/f6PTfomaZ02p18TC8Pn3bHDYAKV0DqNMUkKTbLEGFIOj5GMwhZ3Vhn/fHHSBtNwtO3U33z+/EPX+9WE+J+DsrPbYkNmI3YPd1scaPQUmHTDNPrdlRw7HVnhXqpBhJu9g+LDEt4o3NYY0jbW9RrW9QbNYw2SCVdxyNHAKkkQkqyNKXb7dHv9tH5FxpkOiOKY7I0c0MUdqelLJBQLJFOjLMtBKuLi9TOPYGJMgrX3cbIm99PcPgGF1JJlJPAXV2a4TizfTY13NkmsAakwmYZptfreD/81r77pgSLRYQVCifvRoQlkvnvUqs36HXPM76+zuzsLOPj44RB4EIFgSfdKEscx1gjMJhrygeHBXl5USqhK1V6xQK17Q0aly4RbWyAkJRueQulO96Bt/cQptdFoHPBTyJs/lraoTB4rSYtdrT4QVGvd0aCvLyT9tKNI3Y29Ky1iHCE4PDtqMokyZVHiFbOs7G+Tqfdojo2xtjYOOViiSBwIyzCGtRgp17nU7ZSgacQnocOQxI/pGcN3VqN7vYm/fVVsn6Emj5I6ZY3EV53G97kHkSmsVZf096y5LPf2uxK7buwR4qdQ1jXeh8Os1rpYbLYDmefX/Dm/bUZzehcQ8lb2EKhqrP4+24Er0BWW6Td2aLX79NsNimERcJigUKpjF8suml6KZ1rS4mVggwny0b1GlEUEfci4lYT3W4h/DLB4ZsIj95EsP8kQkl0c9OFpOdhPYVQ7otUHCjLPNLsULATu9ZNyUuOwfizsGYwaS88m0aXRFCaBhnCC+w8DnfsMxfvOoUsxZr8WafDRqQ3sQ8hLZkQ6F6TTrdHp9tDSklYrhCUS3h+gPAUKM/tXAhnnDSOiVtNbLsz3IMVxVH82YME+06gSlWy7RVsbQXp+cighAhDCAJEWEQFBfAC8Dz3nSEqF+iHX//DTiFurg07kyQ629jY9GzS+7oIRw7hFQ87XzT/cuGaJaBjrE7c6zQBnWCzdOc9nYBJsUYjpMSrzmL8ENtvui9VMhn9dov+QFb9waPviLCEVxlFjEwiSyPodh3TaTm1MiggwwIiKCDCAiooIApFCEsQFhFhARmWEIEbfrc5biLtjoEGwptSYCy62aolVxa+pfy5k3VUcIfwC0eQ3g/erxK5RmSyPKyy4WFtmr9OwbrD6hR0ik1jN4rrvu7B9cyVcnrPro73YDVKCIlQHlL5KL+ELFRQhRG3diWEC2WTbx0JmU+Oyfx1/rkif5YufHfel8/qtF67JCiCEJukxAvzF6KLT3/KA33B9rb/wCrvIJXpY0L6+ff3mOcpVN33biAlZB5CeljlQ+aDTEH5CJ06j/JSrM4QWbrjTTpzFXUemtboazcdB9vUUiKEQigPVAC+j/SUe+0FCM9H+KFb5PNDCEJk4LxFBCEiKCKCAvgFhBe4ad2BCGjskFlbKxDGLeYQusZCNP/MWnT+iT8iSe73gBiT/oXpbo8Kaz8uihOnUR6uYzjoeDwLoIUH1kd4gC25VJqvMAw9S+sdjMrfszmYu/XzHNgHK0XWXrOzLuTg7itXPHruez+E8kH5SN93+6nKQ3o+1guQQYjwfWc8z3cX7XmInHdZIXduQO6p7vM9RyyjiP6lC4vxpQu/a9qtzyFEy8tHIOo27f+Bba11yNIPiqB8HD+YRcqSQ3zx/NlMKkAh1M5mkJNrnXHFsK1kd+3lm2Eo24GqZ8VuN83DQeTdT5lv/KjcSMplqkHoDIyoPOcZwg172Uy7ltXQGLn2PGjzCKc4W5NFNupt6kbtSrRw6Ysk8WdFWNi0/d5OsSqE17Qm+yPTWntA+MV3i7D0JoLiEbywyHCp/sWk/2dJJA6ABr2g57TBf+BevpA7vSo9mNbIhyqEzIngDpgN28lS7pr5ljvzT1IipDtZE0exbtUWs9rmP+lm46+EFzymCoXOoM/3/wYAvGMbUzy5a+sAAAAASUVORK5CYII=
{-# START_FILE BASE64 proj.android-studio/app/res/drawable-ldpi/icon.png #-}
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
{-# START_FILE BASE64 proj.android-studio/app/res/drawable-mdpi/icon.png #-}
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
{-# START_FILE BASE64 proj.android-studio/gradle/wrapper/gradle-wrapper.jar #-}
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gSRkAABvcmcvZ3JhZGxlL2NsaS9Db21tYW5kTGluZVBhcnNlciQxLmNsYXNzUEsBAhQDCgAACAgACrKVR1JCCR2oAgAA9wYAADwAAAAAAAAAAAAAALSBEGUAAG9yZy9ncmFkbGUvY2xpL0NvbW1hbmRMaW5lUGFyc2VyJE1pc3NpbmdPcHRpb25BcmdTdGF0ZS5jbGFzc1BLAQIUAwoAAAgIAAqylUe8rE0ykQIAAIMFAAA9AAAAAAAAAAAAAAC0gRJoAABvcmcvZ3JhZGxlL2NsaS9Db21tYW5kTGluZVBhcnNlciRPcHRpb25TdHJpbmdDb21wYXJhdG9yLmNsYXNzUEsBAhQDCgAACAgACrKVR+gjDfJHAQAASwIAADEAAAAAAAAAAAAAALSB/moAAG9yZy9ncmFkbGUvY2xpL0NvbW1hbmRMaW5lQXJndW1lbnRFeGNlcHRpb24uY2xhc3NQSwECFAMKAAAICAAKspVHPxdo/8cHAACHEwAAPQAAAAAAAAAAAAAAtIGUbAAAb3JnL2dyYWRsZS9jbGkvQ29tbWFuZExpbmVQYXJzZXIkS25vd25PcHRpb25QYXJzZXJTdGF0ZS5jbGFzc1BLAQIUAwoAAAgIAAqylUccaxaxzQIAANsGAAA3AAAAAAAAAAAAAAC0gbZ0AABvcmcvZ3JhZGxlL2NsaS9Db21tYW5kTGluZVBhcnNlciRPcHRpb25Db21wYXJhdG9yLmNsYXNzUEsBAhQDCgAACAgACrKVR+Ri1SfhAgAAbgcAAD8AAAAAAAAAAAAAALSB2HcAAG9yZy9ncmFkbGUvY2xpL0NvbW1hbmRMaW5lUGFyc2VyJFVua25vd25PcHRpb25QYXJzZXJTdGF0ZS5jbGFzc1BLAQIUAwoAAAgIAAqylUcieslakgUAAJkNAAAmAAAAAAAAAAAAAAC0gRZ7AABvcmcvZ3JhZGxlL2NsaS9Db21tYW5kTGluZU9wdGlvbi5jbGFzc1BLAQIUAwoAAAgIAAqylUecbFzPpwEAAKYDAAA4AAAAAAAAAAAAAAC0geyAAABvcmcvZ3JhZGxlL2NsaS9Db21tYW5kTGluZVBhcnNlciRPcHRpb25QYXJzZXJTdGF0ZS5jbGFzc1BLAQIUAwoAAAgIAAqylUdbeG6YlAcAAMcRAAAmAAAAAAAAAAAAAAC0gemCAABvcmcvZ3JhZGxlL2NsaS9QYXJzZWRDb21tYW5kTGluZS5jbGFzc1BLAQIUAwoAAAgIAAqylUeLQTVsfAEAAAsDAAA6AAAAAAAAAAAAAAC0gcGKAABvcmcvZ3JhZGxlL2NsaS9Qcm9qZWN0UHJvcGVydGllc0NvbW1hbmRMaW5lQ29udmVydGVyLmNsYXNzUEsBAhQDCgAACAgACrKVRzJsV7ZKAgAABAUAAEYAAAAAAAAAAAAAALSBlYwAAG9yZy9ncmFkbGUvY2xpL0NvbW1hbmRMaW5lUGFyc2VyJENhc2VJbnNlbnNpdGl2ZVN0cmluZ0NvbXBhcmF0b3IuY2xhc3NQSwECFAMKAAAICAAKspVHhaW0F2cSAADGKgAAJgAAAAAAAAAAAAAAtIFDjwAAb3JnL2dyYWRsZS9jbGkvQ29tbWFuZExpbmVQYXJzZXIuY2xhc3NQSwECFAMKAAAICAAKspVHXw8+0qMCAAApBwAAMwAAAAAAAAAAAAAAtIHuoQAAb3JnL2dyYWRsZS9jbGkvQ29tbWFuZExpbmVQYXJzZXIkQWZ0ZXJPcHRpb25zLmNsYXNzUEsBAhQDCgAACAgACrKVR0fRZuySAgAAnAUAADMAAAAAAAAAAAAAALSB4qQAAG9yZy9ncmFkbGUvY2xpL0NvbW1hbmRMaW5lUGFyc2VyJE9wdGlvblN0cmluZy5jbGFzc1BLAQIUAwoAAAgIAAqylUd4JuJUYAQAABoLAAA7AAAAAAAAAAAAAAC0gcWnAABvcmcvZ3JhZGxlL2NsaS9BYnN0cmFjdFByb3BlcnRpZXNDb21tYW5kTGluZUNvbnZlcnRlci5jbGFzc1BLAQIUAwoAAAgIAAqylUeTnbwVvAIAACAFAAAsAAAAAAAAAAAAAAC0gX6sAABvcmcvZ3JhZGxlL2NsaS9QYXJzZWRDb21tYW5kTGluZU9wdGlvbi5jbGFzc1BLAQIUAwoAAAgIAAqylUe2wLBzmAIAAKoGAAA9AAAAAAAAAAAAAAC0gYSvAABvcmcvZ3JhZGxlL2NsaS9Db21tYW5kTGluZVBhcnNlciRPcHRpb25Bd2FyZVBhcnNlclN0YXRlLmNsYXNzUEsBAhQDCgAACAgACrKVRycESAwZAQAAZwIAACkAAAAAAAAAAAAAALSBd7IAAG9yZy9ncmFkbGUvY2xpL0NvbW1hbmRMaW5lQ29udmVydGVyLmNsYXNzUEsBAhQDCgAACAgACrKVR0PRFubqAwAAfAsAADwAAAAAAAAAAAAAALSB17MAAG9yZy9ncmFkbGUvY2xpL0NvbW1hbmRMaW5lUGFyc2VyJEJlZm9yZUZpcnN0U3ViQ29tbWFuZC5jbGFzc1BLAQIUAwoAAAgIAAqylUeTADuZfAEAAPwCAAA5AAAAAAAAAAAAAAC0gRu4AABvcmcvZ3JhZGxlL2NsaS9TeXN0ZW1Qcm9wZXJ0aWVzQ29tbWFuZExpbmVDb252ZXJ0ZXIuY2xhc3NQSwECFAMKAAAICAAKspVHLRVoggcCAAC7BAAAMgAAAAAAAAAAAAAAtIHuuQAAb3JnL2dyYWRsZS9jbGkvQ29tbWFuZExpbmVQYXJzZXIkUGFyc2VyU3RhdGUuY2xhc3NQSwECFAMKAAAICAAKspVHRrYI9z0DAADKCQAAOwAAAAAAAAAAAAAAtIFFvAAAb3JnL2dyYWRsZS9jbGkvQ29tbWFuZExpbmVQYXJzZXIkQWZ0ZXJGaXJzdFN1YkNvbW1hbmQuY2xhc3NQSwECFAMKAAAICAAKspVHad59AEYAAABEAAAAHwAAAAAAAAAAAAAAtIHbvwAAZ3JhZGxlLWNsaS1jbGFzc3BhdGgucHJvcGVydGllc1BLBQYAAAAAMQAxABARAABewAAAAAA=
